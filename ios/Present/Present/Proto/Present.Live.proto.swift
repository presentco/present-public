/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "live.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public extension Present{}

public extension Present {
    public struct LiveRoot {
        public static let `default` = LiveRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Present.HeadersRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class LiveCommentsRequest : GeneratedMessage {

        public static func == (lhs: Present.LiveCommentsRequest, rhs: Present.LiveCommentsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHeader == rhs.hasHeader) && (!lhs.hasHeader || lhs.header == rhs.header)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var header:Present.RequestHeader!
        public fileprivate(set) var hasHeader:Bool = false
        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        /// The user id associated with this client.
        /// Note: This should be redundant with the client uuid in the header, but the live server
        /// currently has no way to resolve client ids to user ids. This supports filtering blocked
        /// messages for this user.
        public fileprivate(set) var userId:String = ""
        public fileprivate(set) var hasUserId:Bool = false

        /// Supported versions: 0 (default) and 1 (sends LiveCommentResponse).
        public fileprivate(set) var version:UInt32 = UInt32(0)
        public fileprivate(set) var hasVersion:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasHeader {
                return false
            }
            if !hasGroupId {
                return false
            }
            if !hasUserId {
                return false
            }
            if !header.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHeader {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:header)
            }
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 2, value:groupId)
            }
            if hasUserId {
                try codedOutputStream.writeString(fieldNumber: 3, value:userId)
            }
            if hasVersion {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:version)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHeader {
                if let varSizeheader = header?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeheader
                }
            }
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 2)
            }
            if hasUserId {
                serialize_size += userId.computeStringSize(fieldNumber: 3)
            }
            if hasVersion {
                serialize_size += version.computeUInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.LiveCommentsRequest.Builder {
            return Present.LiveCommentsRequest.classBuilder() as! Present.LiveCommentsRequest.Builder
        }
        public func getBuilder() -> Present.LiveCommentsRequest.Builder {
            return classBuilder() as! Present.LiveCommentsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.LiveCommentsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.LiveCommentsRequest.Builder()
        }
        public func toBuilder() throws -> Present.LiveCommentsRequest.Builder {
            return try Present.LiveCommentsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.LiveCommentsRequest) throws -> Present.LiveCommentsRequest.Builder {
            return try Present.LiveCommentsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHeader {
                jsonMap["header"] = try header.encode()
            }
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if hasUserId {
                jsonMap["userId"] = userId
            }
            if hasVersion {
                jsonMap["version"] = UInt(version)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.LiveCommentsRequest {
            return try Present.LiveCommentsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.LiveCommentsRequest {
            return try Present.LiveCommentsRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHeader {
                output += "\(indent) header {\n"
                if let outDescHeader = header {
                    output += try outDescHeader.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHeader {
                    if let hashValueheader = header?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueheader
                    }
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.LiveCommentsRequest"
        }
        override public func className() -> String {
            return "Present.LiveCommentsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.LiveCommentsRequest = Present.LiveCommentsRequest()
            public func getMessage() -> Present.LiveCommentsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var header:Present.RequestHeader! {
                get {
                    if headerBuilder_ != nil {
                        builderResult.header = headerBuilder_.getMessage()
                    }
                    return builderResult.header
                }
                set (value) {
                    builderResult.hasHeader = true
                    builderResult.header = value
                }
            }
            public var hasHeader:Bool {
                get {
                    return builderResult.hasHeader
                }
            }
            fileprivate var headerBuilder_:Present.RequestHeader.Builder! {
                didSet {
                    builderResult.hasHeader = true
                }
            }
            public func getHeaderBuilder() -> Present.RequestHeader.Builder {
                if headerBuilder_ == nil {
                    headerBuilder_ = Present.RequestHeader.Builder()
                    builderResult.header = headerBuilder_.getMessage()
                    if header != nil {
                        try! headerBuilder_.mergeFrom(other: header)
                    }
                }
                return headerBuilder_
            }
            @discardableResult
            public func setHeader(_ value:Present.RequestHeader!) -> Present.LiveCommentsRequest.Builder {
                self.header = value
                return self
            }
            @discardableResult
            public func mergeHeader(value:Present.RequestHeader) throws -> Present.LiveCommentsRequest.Builder {
                if builderResult.hasHeader {
                    builderResult.header = try Present.RequestHeader.builderWithPrototype(prototype:builderResult.header).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.header = value
                }
                builderResult.hasHeader = true
                return self
            }
            @discardableResult
            public func clearHeader() -> Present.LiveCommentsRequest.Builder {
                headerBuilder_ = nil
                builderResult.hasHeader = false
                builderResult.header = nil
                return self
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.LiveCommentsRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.LiveCommentsRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            /// The user id associated with this client.
            /// Note: This should be redundant with the client uuid in the header, but the live server
            /// currently has no way to resolve client ids to user ids. This supports filtering blocked
            /// messages for this user.
            public var userId:String {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:String) -> Present.LiveCommentsRequest.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Present.LiveCommentsRequest.Builder{
                builderResult.hasUserId = false
                builderResult.userId = ""
                return self
            }
            /// Supported versions: 0 (default) and 1 (sends LiveCommentResponse).
            public var version:UInt32 {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:UInt32) -> Present.LiveCommentsRequest.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Present.LiveCommentsRequest.Builder{
                builderResult.hasVersion = false
                builderResult.version = UInt32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.LiveCommentsRequest.Builder {
                builderResult = Present.LiveCommentsRequest()
                return self
            }
            override public func clone() throws -> Present.LiveCommentsRequest.Builder {
                return try Present.LiveCommentsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.LiveCommentsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.LiveCommentsRequest {
                let returnMe:Present.LiveCommentsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.LiveCommentsRequest) throws -> Present.LiveCommentsRequest.Builder {
                if other == Present.LiveCommentsRequest() {
                    return self
                }
                if (other.hasHeader) {
                    try mergeHeader(value: other.header)
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasVersion {
                    version = other.version
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.LiveCommentsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LiveCommentsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.RequestHeader.Builder = Present.RequestHeader.Builder()
                        if hasHeader {
                            try subBuilder.mergeFrom(other: header)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        header = subBuilder.buildPartial()

                    case 18:
                        groupId = try codedInputStream.readString()

                    case 26:
                        userId = try codedInputStream.readString()

                    case 32:
                        version = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.LiveCommentsRequest.Builder {
                let resultDecodedBuilder = Present.LiveCommentsRequest.Builder()
                if let jsonValueHeader = jsonMap["header"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.header = try Present.RequestHeader.Builder.decodeToBuilder(jsonMap:jsonValueHeader).build()

                }
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = jsonValueUserId
                }
                if let jsonValueVersion = jsonMap["version"] as? UInt {
                    resultDecodedBuilder.version = UInt32(jsonValueVersion)
                } else if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = UInt32(jsonValueVersion)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.LiveCommentsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.LiveCommentsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LiveCommentsResponse : GeneratedMessage {

        public static func == (lhs: Present.LiveCommentsResponse, rhs: Present.LiveCommentsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case ready = 1
                public func toString() -> String {
                    switch self {
                    case .ready: return "READY"
                    }
                }
                public static func fromString(str:String) throws -> Present.LiveCommentsResponse.Status {
                    switch str {
                    case "READY":    return .ready
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .ready: return ".ready"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:Status, rhs:Status) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var status:Present.LiveCommentsResponse.Status = Present.LiveCommentsResponse.Status.ready
        public fileprivate(set) var hasStatus:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStatus {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:status.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasStatus) {
                serialize_size += status.rawValue.computeEnumSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.LiveCommentsResponse.Builder {
            return Present.LiveCommentsResponse.classBuilder() as! Present.LiveCommentsResponse.Builder
        }
        public func getBuilder() -> Present.LiveCommentsResponse.Builder {
            return classBuilder() as! Present.LiveCommentsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.LiveCommentsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.LiveCommentsResponse.Builder()
        }
        public func toBuilder() throws -> Present.LiveCommentsResponse.Builder {
            return try Present.LiveCommentsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.LiveCommentsResponse) throws -> Present.LiveCommentsResponse.Builder {
            return try Present.LiveCommentsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStatus {
                jsonMap["status"] = status.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.LiveCommentsResponse {
            return try Present.LiveCommentsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.LiveCommentsResponse {
            return try Present.LiveCommentsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasStatus) {
                output += "\(indent) status: \(status.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStatus {
                     hashCode = (hashCode &* 31) &+ status.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.LiveCommentsResponse"
        }
        override public func className() -> String {
            return "Present.LiveCommentsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.LiveCommentsResponse = Present.LiveCommentsResponse()
            public func getMessage() -> Present.LiveCommentsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Should always be READY.
                public var status:Present.LiveCommentsResponse.Status {
                    get {
                        return builderResult.status
                    }
                    set (value) {
                        builderResult.hasStatus = true
                        builderResult.status = value
                    }
                }
                public var hasStatus:Bool{
                    get {
                        return builderResult.hasStatus
                    }
                }
            @discardableResult
                public func setStatus(_ value:Present.LiveCommentsResponse.Status) -> Present.LiveCommentsResponse.Builder {
                  self.status = value
                  return self
                }
            @discardableResult
                public func clearStatus() -> Present.LiveCommentsResponse.Builder {
                   builderResult.hasStatus = false
                   builderResult.status = .ready
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.LiveCommentsResponse.Builder {
                builderResult = Present.LiveCommentsResponse()
                return self
            }
            override public func clone() throws -> Present.LiveCommentsResponse.Builder {
                return try Present.LiveCommentsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.LiveCommentsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.LiveCommentsResponse {
                let returnMe:Present.LiveCommentsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.LiveCommentsResponse) throws -> Present.LiveCommentsResponse.Builder {
                if other == Present.LiveCommentsResponse() {
                    return self
                }
                if other.hasStatus {
                    status = other.status
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.LiveCommentsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LiveCommentsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntstatus = try codedInputStream.readEnum()
                        if let enumsstatus = Present.LiveCommentsResponse.Status(rawValue:valueIntstatus){
                            status = enumsstatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntstatus))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.LiveCommentsResponse.Builder {
                let resultDecodedBuilder = Present.LiveCommentsResponse.Builder()
                if let jsonValueStatus = jsonMap["status"] as? String {
                    resultDecodedBuilder.status = try Present.LiveCommentsResponse.Status.fromString(str: jsonValueStatus)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.LiveCommentsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.LiveCommentsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Present.LiveCommentsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.LiveCommentsRequest> {
        var mergedArray = Array<Present.LiveCommentsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.LiveCommentsRequest? {
        return try Present.LiveCommentsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.LiveCommentsRequest {
        return try Present.LiveCommentsRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.LiveRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.LiveCommentsRequest {
        return try Present.LiveCommentsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.LiveCommentsRequest {
        return try Present.LiveCommentsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LiveCommentsRequest {
        return try Present.LiveCommentsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.LiveCommentsRequest {
        return try Present.LiveCommentsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LiveCommentsRequest {
        return try Present.LiveCommentsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "header": return self.header
        case "groupId": return self.groupId
        case "userId": return self.userId
        case "version": return self.version
        default: return nil
        }
    }
}
extension Present.LiveCommentsRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "header": return self.header
            case "groupId": return self.groupId
            case "userId": return self.userId
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "header":
                guard let newSubscriptValue = newSubscriptValue as? Present.RequestHeader else {
                    return
                }
                self.header = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.LiveCommentsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.LiveCommentsResponse> {
        var mergedArray = Array<Present.LiveCommentsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.LiveCommentsResponse? {
        return try Present.LiveCommentsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.LiveCommentsResponse {
        return try Present.LiveCommentsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.LiveRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.LiveCommentsResponse {
        return try Present.LiveCommentsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.LiveCommentsResponse {
        return try Present.LiveCommentsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LiveCommentsResponse {
        return try Present.LiveCommentsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.LiveCommentsResponse {
        return try Present.LiveCommentsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LiveCommentsResponse {
        return try Present.LiveCommentsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "status": return self.status
        default: return nil
        }
    }
}
extension Present.LiveCommentsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "status": return self.status
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "status":
                guard let newSubscriptValue = newSubscriptValue as? Present.LiveCommentsResponse.Status else {
                    return
                }
                self.status = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
