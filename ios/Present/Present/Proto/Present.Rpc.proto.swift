/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "rpc.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public extension Present{}

public extension Present {
    public struct RpcRoot {
        public static let `default` = RpcRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// Request to invoke an RPC.
    final public class Request : GeneratedMessage {

        public static func == (lhs: Present.Request, rhs: Present.Request) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHeader == rhs.hasHeader) && (!lhs.hasHeader || lhs.header == rhs.header)
            fieldCheck = fieldCheck && (lhs.hasArgument == rhs.hasArgument) && (!lhs.hasArgument || lhs.argument == rhs.argument)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Application-specific headers
        public fileprivate(set) var header:Data = Data()
        public fileprivate(set) var hasHeader:Bool = false

        /// Argument to decode and pass to the RPC method
        public fileprivate(set) var argument:Data = Data()
        public fileprivate(set) var hasArgument:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasArgument {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHeader {
                try codedOutputStream.writeData(fieldNumber: 3, value:header)
            }
            if hasArgument {
                try codedOutputStream.writeData(fieldNumber: 4, value:argument)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHeader {
                serialize_size += header.computeDataSize(fieldNumber: 3)
            }
            if hasArgument {
                serialize_size += argument.computeDataSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.Request.Builder {
            return Present.Request.classBuilder() as! Present.Request.Builder
        }
        public func getBuilder() -> Present.Request.Builder {
            return classBuilder() as! Present.Request.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Request.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Request.Builder()
        }
        public func toBuilder() throws -> Present.Request.Builder {
            return try Present.Request.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.Request) throws -> Present.Request.Builder {
            return try Present.Request.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHeader {
                jsonMap["header"] = header.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasArgument {
                jsonMap["argument"] = argument.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.Request {
            return try Present.Request.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.Request {
            return try Present.Request.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHeader {
                output += "\(indent) header: \(header) \n"
            }
            if hasArgument {
                output += "\(indent) argument: \(argument) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHeader {
                    hashCode = (hashCode &* 31) &+ header.hashValue
                }
                if hasArgument {
                    hashCode = (hashCode &* 31) &+ argument.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.Request"
        }
        override public func className() -> String {
            return "Present.Request"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.Request = Present.Request()
            public func getMessage() -> Present.Request {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Application-specific headers
            public var header:Data {
                get {
                    return builderResult.header
                }
                set (value) {
                    builderResult.hasHeader = true
                    builderResult.header = value
                }
            }
            public var hasHeader:Bool {
                get {
                    return builderResult.hasHeader
                }
            }
            @discardableResult
            public func setHeader(_ value:Data) -> Present.Request.Builder {
                self.header = value
                return self
            }
            @discardableResult
            public func clearHeader() -> Present.Request.Builder{
                builderResult.hasHeader = false
                builderResult.header = Data()
                return self
            }
            /// Argument to decode and pass to the RPC method
            public var argument:Data {
                get {
                    return builderResult.argument
                }
                set (value) {
                    builderResult.hasArgument = true
                    builderResult.argument = value
                }
            }
            public var hasArgument:Bool {
                get {
                    return builderResult.hasArgument
                }
            }
            @discardableResult
            public func setArgument(_ value:Data) -> Present.Request.Builder {
                self.argument = value
                return self
            }
            @discardableResult
            public func clearArgument() -> Present.Request.Builder{
                builderResult.hasArgument = false
                builderResult.argument = Data()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.Request.Builder {
                builderResult = Present.Request()
                return self
            }
            override public func clone() throws -> Present.Request.Builder {
                return try Present.Request.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.Request {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.Request {
                let returnMe:Present.Request = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.Request) throws -> Present.Request.Builder {
                if other == Present.Request() {
                    return self
                }
                if other.hasHeader {
                    header = other.header
                }
                if other.hasArgument {
                    argument = other.argument
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.Request.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Request.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 26:
                        header = try codedInputStream.readData()

                    case 34:
                        argument = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.Request.Builder {
                let resultDecodedBuilder = Present.Request.Builder()
                if let jsonValueHeader = jsonMap["header"] as? String {
                    resultDecodedBuilder.header = Data(base64Encoded:jsonValueHeader, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueArgument = jsonMap["argument"] as? String {
                    resultDecodedBuilder.argument = Data(base64Encoded:jsonValueArgument, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.Request.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.Request.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Result of an RPC invocation.
    final public class Response : GeneratedMessage {

        public static func == (lhs: Present.Response, rhs: Present.Response) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
            fieldCheck = fieldCheck && (lhs.hasResultBytes == rhs.hasResultBytes) && (!lhs.hasResultBytes || lhs.resultBytes == rhs.resultBytes)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Result {
            case OneOfResultNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfResultNotSet: return false
                default: return true
                }
            }
            case Error(Present.Error)

            public static func getError(_ value:Result) -> Present.Error? {
                switch value {
                case .Error(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case ResultBytes(Data)

            public static func getResultBytes(_ value:Result) -> Data? {
                switch value {
                case .ResultBytes(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageResult:Response.Result =  Response.Result.OneOfResultNotSet
        public func getOneOfResult() ->  Response.Result {
            let copyObjectResult = storageResult
            return copyObjectResult
        }
        public fileprivate(set) var error:Present.Error!{
            get {
                return Response.Result.getError(storageResult)
            }
            set (newvalue) {
                storageResult = Response.Result.Error(newvalue)
            }
        }
        public fileprivate(set) var hasError:Bool {
            get {
                guard let _ = Response.Result.getError(storageResult) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// Encoded result from RPC method
        /// Note: The current client proto generator doesn't like the name 'result' here.
        public fileprivate(set) var resultBytes:Data!{
            get {
                return Response.Result.getResultBytes(storageResult)
            }
            set (newvalue) {
                storageResult = Response.Result.ResultBytes(newvalue)
            }
        }
        public fileprivate(set) var hasResultBytes:Bool {
            get {
                guard let _ = Response.Result.getResultBytes(storageResult) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if hasError {
                if !error.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasError {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:error)
            }
            if hasResultBytes {
                try codedOutputStream.writeData(fieldNumber: 2, value:resultBytes)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasError {
                if let varSizeerror = error?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeerror
                }
            }
            if hasResultBytes {
                serialize_size += resultBytes.computeDataSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.Response.Builder {
            return Present.Response.classBuilder() as! Present.Response.Builder
        }
        public func getBuilder() -> Present.Response.Builder {
            return classBuilder() as! Present.Response.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Response.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Response.Builder()
        }
        public func toBuilder() throws -> Present.Response.Builder {
            return try Present.Response.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.Response) throws -> Present.Response.Builder {
            return try Present.Response.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasError {
                jsonMap["error"] = try error.encode()
            }
            if hasResultBytes {
                jsonMap["resultBytes"] = resultBytes.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.Response {
            return try Present.Response.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.Response {
            return try Present.Response.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasError {
                output += "\(indent) error {\n"
                if let outDescError = error {
                    output += try outDescError.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasResultBytes {
                output += "\(indent) resultBytes: \(resultBytes) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasError {
                    if let hashValueerror = error?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueerror
                    }
                }
                if hasResultBytes {
                    hashCode = (hashCode &* 31) &+ resultBytes.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.Response"
        }
        override public func className() -> String {
            return "Present.Response"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.Response = Present.Response()
            public func getMessage() -> Present.Response {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Present when an error occurs.
            public var error:Present.Error! {
                get {
                    if errorBuilder_ != nil {
                        builderResult.error = errorBuilder_.getMessage()
                    }
                    return builderResult.error
                }
                set (value) {
                    builderResult.hasError = true
                    builderResult.error = value
                }
            }
            public var hasError:Bool {
                get {
                    return builderResult.hasError
                }
            }
            fileprivate var errorBuilder_:Present.Error.Builder! {
                didSet {
                    builderResult.hasError = true
                }
            }
            public func getErrorBuilder() -> Present.Error.Builder {
                if errorBuilder_ == nil {
                    errorBuilder_ = Present.Error.Builder()
                    builderResult.error = errorBuilder_.getMessage()
                    if error != nil {
                        try! errorBuilder_.mergeFrom(other: error)
                    }
                }
                return errorBuilder_
            }
            @discardableResult
            public func setError(_ value:Present.Error!) -> Present.Response.Builder {
                self.error = value
                return self
            }
            @discardableResult
            public func mergeError(value:Present.Error) throws -> Present.Response.Builder {
                if builderResult.hasError {
                    builderResult.error = try Present.Error.builderWithPrototype(prototype:builderResult.error).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.error = value
                }
                builderResult.hasError = true
                return self
            }
            @discardableResult
            public func clearError() -> Present.Response.Builder {
                errorBuilder_ = nil
                builderResult.hasError = false
                builderResult.error = nil
                return self
            }
            /// Encoded result from RPC method
            /// Note: The current client proto generator doesn't like the name 'result' here.
            public var resultBytes:Data {
                get {
                    return builderResult.resultBytes
                }
                set (value) {
                    builderResult.hasResultBytes = true
                    builderResult.resultBytes = value
                }
            }
            public var hasResultBytes:Bool {
                get {
                    return builderResult.hasResultBytes
                }
            }
            @discardableResult
            public func setResultBytes(_ value:Data) -> Present.Response.Builder {
                self.resultBytes = value
                return self
            }
            @discardableResult
            public func clearResultBytes() -> Present.Response.Builder{
                builderResult.hasResultBytes = false
                builderResult.resultBytes = Data()
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.Response.Builder {
                builderResult = Present.Response()
                return self
            }
            override public func clone() throws -> Present.Response.Builder {
                return try Present.Response.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.Response {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.Response {
                let returnMe:Present.Response = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.Response) throws -> Present.Response.Builder {
                if other == Present.Response() {
                    return self
                }
                if (other.hasError) {
                    try mergeError(value: other.error)
                }
                if other.hasResultBytes {
                    resultBytes = other.resultBytes
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.Response.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Response.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.Error.Builder = Present.Error.Builder()
                        if hasError {
                            try subBuilder.mergeFrom(other: error)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        error = subBuilder.buildPartial()

                    case 18:
                        resultBytes = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.Response.Builder {
                let resultDecodedBuilder = Present.Response.Builder()
                if let jsonValueError = jsonMap["error"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.error = try Present.Error.Builder.decodeToBuilder(jsonMap:jsonValueError).build()

                }
                if let jsonValueResultBytes = jsonMap["resultBytes"] as? String {
                    resultDecodedBuilder.resultBytes = Data(base64Encoded:jsonValueResultBytes, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.Response.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.Response.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// RPC Error
    final public class Error : GeneratedMessage {

        public static func == (lhs: Present.Error, rhs: Present.Error) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasMessage == rhs.hasMessage) && (!lhs.hasMessage || lhs.message == rhs.message)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum ProtoType:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// There was a problem with the request itself.
                case client = 1

                /// An error occurred while processing the request.
                case server = 2
                public func toString() -> String {
                    switch self {
                    case .client: return "CLIENT"
                    case .server: return "SERVER"
                    }
                }
                public static func fromString(str:String) throws -> Present.Error.ProtoType {
                    switch str {
                    case "CLIENT":    return .client
                    case "SERVER":    return .server
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .client: return ".client"
                    case .server: return ".server"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:ProtoType, rhs:ProtoType) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var type:Present.Error.ProtoType = Present.Error.ProtoType.client
        public fileprivate(set) var hasType:Bool = false
        /// Descriptive message or a key to a descriptive message (when localized)
        public fileprivate(set) var message:String = ""
        public fileprivate(set) var hasMessage:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasType {
                return false
            }
            if !hasMessage {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasType {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:type.rawValue)
            }
            if hasMessage {
                try codedOutputStream.writeString(fieldNumber: 2, value:message)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasType) {
                serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasMessage {
                serialize_size += message.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.Error.Builder {
            return Present.Error.classBuilder() as! Present.Error.Builder
        }
        public func getBuilder() -> Present.Error.Builder {
            return classBuilder() as! Present.Error.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Error.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Error.Builder()
        }
        public func toBuilder() throws -> Present.Error.Builder {
            return try Present.Error.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.Error) throws -> Present.Error.Builder {
            return try Present.Error.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasType {
                jsonMap["type"] = type.toString()
            }
            if hasMessage {
                jsonMap["message"] = message
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.Error {
            return try Present.Error.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.Error {
            return try Present.Error.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasType) {
                output += "\(indent) type: \(type.description)\n"
            }
            if hasMessage {
                output += "\(indent) message: \(message) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasType {
                     hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasMessage {
                    hashCode = (hashCode &* 31) &+ message.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.Error"
        }
        override public func className() -> String {
            return "Present.Error"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.Error = Present.Error()
            public func getMessage() -> Present.Error {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var type:Present.Error.ProtoType {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool{
                    get {
                        return builderResult.hasType
                    }
                }
            @discardableResult
                public func setType(_ value:Present.Error.ProtoType) -> Present.Error.Builder {
                  self.type = value
                  return self
                }
            @discardableResult
                public func clearType() -> Present.Error.Builder {
                   builderResult.hasType = false
                   builderResult.type = .client
                   return self
                }
            /// Descriptive message or a key to a descriptive message (when localized)
            public var message:String {
                get {
                    return builderResult.message
                }
                set (value) {
                    builderResult.hasMessage = true
                    builderResult.message = value
                }
            }
            public var hasMessage:Bool {
                get {
                    return builderResult.hasMessage
                }
            }
            @discardableResult
            public func setMessage(_ value:String) -> Present.Error.Builder {
                self.message = value
                return self
            }
            @discardableResult
            public func clearMessage() -> Present.Error.Builder{
                builderResult.hasMessage = false
                builderResult.message = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.Error.Builder {
                builderResult = Present.Error()
                return self
            }
            override public func clone() throws -> Present.Error.Builder {
                return try Present.Error.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.Error {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.Error {
                let returnMe:Present.Error = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.Error) throws -> Present.Error.Builder {
                if other == Present.Error() {
                    return self
                }
                if other.hasType {
                    type = other.type
                }
                if other.hasMessage {
                    message = other.message
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.Error.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Error.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueInttype = try codedInputStream.readEnum()
                        if let enumstype = Present.Error.ProtoType(rawValue:valueInttype){
                            type = enumstype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttype))
                        }

                    case 18:
                        message = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.Error.Builder {
                let resultDecodedBuilder = Present.Error.Builder()
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = try Present.Error.ProtoType.fromString(str: jsonValueType)
                }
                if let jsonValueMessage = jsonMap["message"] as? String {
                    resultDecodedBuilder.message = jsonValueMessage
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.Error.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.Error.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Present.Request: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.Request> {
        var mergedArray = Array<Present.Request>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.Request? {
        return try Present.Request.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.Request {
        return try Present.Request.Builder().mergeFrom(data: data, extensionRegistry:Present.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.Request {
        return try Present.Request.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.Request {
        return try Present.Request.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Request {
        return try Present.Request.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.Request {
        return try Present.Request.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Request {
        return try Present.Request.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "header": return self.header
        case "argument": return self.argument
        default: return nil
        }
    }
}
extension Present.Request.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "header": return self.header
            case "argument": return self.argument
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "header":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.header = newSubscriptValue
            case "argument":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.argument = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.Response: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.Response> {
        var mergedArray = Array<Present.Response>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.Response? {
        return try Present.Response.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.Response {
        return try Present.Response.Builder().mergeFrom(data: data, extensionRegistry:Present.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.Response {
        return try Present.Response.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.Response {
        return try Present.Response.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Response {
        return try Present.Response.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.Response {
        return try Present.Response.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Response {
        return try Present.Response.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "error": return self.error
        case "resultBytes": return self.resultBytes
        default: return nil
        }
    }
}
extension Present.Response.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "error": return self.error
            case "resultBytes": return self.resultBytes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "error":
                guard let newSubscriptValue = newSubscriptValue as? Present.Error else {
                    return
                }
                self.error = newSubscriptValue
            case "resultBytes":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.resultBytes = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.Error: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.Error> {
        var mergedArray = Array<Present.Error>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.Error? {
        return try Present.Error.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.Error {
        return try Present.Error.Builder().mergeFrom(data: data, extensionRegistry:Present.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.Error {
        return try Present.Error.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.Error {
        return try Present.Error.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Error {
        return try Present.Error.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.Error {
        return try Present.Error.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Error {
        return try Present.Error.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        case "message": return self.message
        default: return nil
        }
    }
}
extension Present.Error.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            case "message": return self.message
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Present.Error.ProtoType else {
                    return
                }
                self.type = newSubscriptValue
            case "message":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.message = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
