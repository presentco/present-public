/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "url.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public extension Present{}

public extension Present {
    public struct UrlRoot {
        public static let `default` = UrlRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Present.GroupRoot.default.registerAllExtensions(registry: extensionRegistry)
            Present.UserRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class ResolveUrlRequest : GeneratedMessage {

        public static func == (lhs: Present.ResolveUrlRequest, rhs: Present.ResolveUrlRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The full URL. sExample: "https://present.co/a/qplwGwl8"
        public fileprivate(set) var url:String = ""
        public fileprivate(set) var hasUrl:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUrl {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUrl {
                try codedOutputStream.writeString(fieldNumber: 1, value:url)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUrl {
                serialize_size += url.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.ResolveUrlRequest.Builder {
            return Present.ResolveUrlRequest.classBuilder() as! Present.ResolveUrlRequest.Builder
        }
        public func getBuilder() -> Present.ResolveUrlRequest.Builder {
            return classBuilder() as! Present.ResolveUrlRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ResolveUrlRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ResolveUrlRequest.Builder()
        }
        public func toBuilder() throws -> Present.ResolveUrlRequest.Builder {
            return try Present.ResolveUrlRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.ResolveUrlRequest) throws -> Present.ResolveUrlRequest.Builder {
            return try Present.ResolveUrlRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUrl {
                jsonMap["url"] = url
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.ResolveUrlRequest {
            return try Present.ResolveUrlRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.ResolveUrlRequest {
            return try Present.ResolveUrlRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUrl {
                output += "\(indent) url: \(url) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUrl {
                    hashCode = (hashCode &* 31) &+ url.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.ResolveUrlRequest"
        }
        override public func className() -> String {
            return "Present.ResolveUrlRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.ResolveUrlRequest = Present.ResolveUrlRequest()
            public func getMessage() -> Present.ResolveUrlRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The full URL. sExample: "https://present.co/a/qplwGwl8"
            public var url:String {
                get {
                    return builderResult.url
                }
                set (value) {
                    builderResult.hasUrl = true
                    builderResult.url = value
                }
            }
            public var hasUrl:Bool {
                get {
                    return builderResult.hasUrl
                }
            }
            @discardableResult
            public func setUrl(_ value:String) -> Present.ResolveUrlRequest.Builder {
                self.url = value
                return self
            }
            @discardableResult
            public func clearUrl() -> Present.ResolveUrlRequest.Builder{
                builderResult.hasUrl = false
                builderResult.url = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.ResolveUrlRequest.Builder {
                builderResult = Present.ResolveUrlRequest()
                return self
            }
            override public func clone() throws -> Present.ResolveUrlRequest.Builder {
                return try Present.ResolveUrlRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.ResolveUrlRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.ResolveUrlRequest {
                let returnMe:Present.ResolveUrlRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.ResolveUrlRequest) throws -> Present.ResolveUrlRequest.Builder {
                if other == Present.ResolveUrlRequest() {
                    return self
                }
                if other.hasUrl {
                    url = other.url
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.ResolveUrlRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ResolveUrlRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        url = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.ResolveUrlRequest.Builder {
                let resultDecodedBuilder = Present.ResolveUrlRequest.Builder()
                if let jsonValueUrl = jsonMap["url"] as? String {
                    resultDecodedBuilder.url = jsonValueUrl
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.ResolveUrlRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.ResolveUrlRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ResolveUrlResponse : GeneratedMessage {

        public static func == (lhs: Present.ResolveUrlResponse, rhs: Present.ResolveUrlResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasReferrer == rhs.hasReferrer) && (!lhs.hasReferrer || lhs.referrer == rhs.referrer)
            fieldCheck = fieldCheck && (lhs.hasApp == rhs.hasApp) && (!lhs.hasApp || lhs.app == rhs.app)
            fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
            fieldCheck = fieldCheck && (lhs.hasGroup == rhs.hasGroup) && (!lhs.hasGroup || lhs.group == rhs.group)
            fieldCheck = fieldCheck && (lhs.hasComment == rhs.hasComment) && (!lhs.hasComment || lhs.comment == rhs.comment)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasCategory == rhs.hasCategory) && (!lhs.hasCategory || lhs.category == rhs.category)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        /// The entity to which the url refers.
        public enum Result {
            case OneOfResultNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfResultNotSet: return false
                default: return true
                }
            }
            case App(Present.AppResponse)

            public static func getApp(_ value:Result) -> Present.AppResponse? {
                switch value {
                case .App(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case User(Present.UserResponse)

            public static func getUser(_ value:Result) -> Present.UserResponse? {
                switch value {
                case .User(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Group(Present.GroupResponse)

            public static func getGroup(_ value:Result) -> Present.GroupResponse? {
                switch value {
                case .Group(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Comment(Present.CommentResponse)

            public static func getComment(_ value:Result) -> Present.CommentResponse? {
                switch value {
                case .Comment(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Category(Present.CategoryResponse)

            public static func getCategory(_ value:Result) -> Present.CategoryResponse? {
                switch value {
                case .Category(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageResult:ResolveUrlResponse.Result =  ResolveUrlResponse.Result.OneOfResultNotSet
        public func getOneOfResult() ->  ResolveUrlResponse.Result {
            let copyObjectResult = storageResult
            return copyObjectResult
        }


            //Enum type declaration start 

            /// Entity type
            public enum ProtoType:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// Returned for `/a/[id]`. `app` will be set.
                case app = 1

                /// Returned for `/u/[id]`. `user` will be set.
                case user = 2

                /// Returned for `/g/[id]`. `group` will be set.
                case group = 3

                /// Returned for `/c/[id]`. `comment` will be set.
                case comment = 4

                /// Returned for `/t/[name]`. `category` will be set.
                case category = 5
                public func toString() -> String {
                    switch self {
                    case .app: return "APP"
                    case .user: return "USER"
                    case .group: return "GROUP"
                    case .comment: return "COMMENT"
                    case .category: return "CATEGORY"
                    }
                }
                public static func fromString(str:String) throws -> Present.ResolveUrlResponse.ProtoType {
                    switch str {
                    case "APP":    return .app
                    case "USER":    return .user
                    case "GROUP":    return .group
                    case "COMMENT":    return .comment
                    case "CATEGORY":    return .category
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .app: return ".app"
                    case .user: return ".user"
                    case .group: return ".group"
                    case .comment: return ".comment"
                    case .category: return ".category"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:ProtoType, rhs:ProtoType) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var referrer:Present.UserResponse!
        public fileprivate(set) var hasReferrer:Bool = false
        public fileprivate(set) var type:Present.ResolveUrlResponse.ProtoType = Present.ResolveUrlResponse.ProtoType.app
        public fileprivate(set) var hasType:Bool = false
        public fileprivate(set) var app:Present.AppResponse!{
            get {
                return ResolveUrlResponse.Result.getApp(storageResult)
            }
            set (newvalue) {
                storageResult = ResolveUrlResponse.Result.App(newvalue)
            }
        }
        public fileprivate(set) var hasApp:Bool {
            get {
                guard let _ = ResolveUrlResponse.Result.getApp(storageResult) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var user:Present.UserResponse!{
            get {
                return ResolveUrlResponse.Result.getUser(storageResult)
            }
            set (newvalue) {
                storageResult = ResolveUrlResponse.Result.User(newvalue)
            }
        }
        public fileprivate(set) var hasUser:Bool {
            get {
                guard let _ = ResolveUrlResponse.Result.getUser(storageResult) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var group:Present.GroupResponse!{
            get {
                return ResolveUrlResponse.Result.getGroup(storageResult)
            }
            set (newvalue) {
                storageResult = ResolveUrlResponse.Result.Group(newvalue)
            }
        }
        public fileprivate(set) var hasGroup:Bool {
            get {
                guard let _ = ResolveUrlResponse.Result.getGroup(storageResult) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var comment:Present.CommentResponse!{
            get {
                return ResolveUrlResponse.Result.getComment(storageResult)
            }
            set (newvalue) {
                storageResult = ResolveUrlResponse.Result.Comment(newvalue)
            }
        }
        public fileprivate(set) var hasComment:Bool {
            get {
                guard let _ = ResolveUrlResponse.Result.getComment(storageResult) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var category:Present.CategoryResponse!{
            get {
                return ResolveUrlResponse.Result.getCategory(storageResult)
            }
            set (newvalue) {
                storageResult = ResolveUrlResponse.Result.Category(newvalue)
            }
        }
        public fileprivate(set) var hasCategory:Bool {
            get {
                guard let _ = ResolveUrlResponse.Result.getCategory(storageResult) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasType {
                return false
            }
            if hasReferrer {
                if !referrer.isInitialized() {
                    return false
                }
            }
            if hasUser {
                if !user.isInitialized() {
                    return false
                }
            }
            if hasGroup {
                if !group.isInitialized() {
                    return false
                }
            }
            if hasComment {
                if !comment.isInitialized() {
                    return false
                }
            }
            if hasCategory {
                if !category.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasReferrer {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:referrer)
            }
            if hasApp {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:app)
            }
            if hasUser {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:user)
            }
            if hasGroup {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:group)
            }
            if hasComment {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:comment)
            }
            if hasType {
                try codedOutputStream.writeEnum(fieldNumber: 6, value:type.rawValue)
            }
            if hasCategory {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:category)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasReferrer {
                if let varSizereferrer = referrer?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizereferrer
                }
            }
            if hasApp {
                if let varSizeapp = app?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeapp
                }
            }
            if hasUser {
                if let varSizeuser = user?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeuser
                }
            }
            if hasGroup {
                if let varSizegroup = group?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizegroup
                }
            }
            if hasComment {
                if let varSizecomment = comment?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizecomment
                }
            }
            if (hasType) {
                serialize_size += type.rawValue.computeEnumSize(fieldNumber: 6)
            }
            if hasCategory {
                if let varSizecategory = category?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizecategory
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.ResolveUrlResponse.Builder {
            return Present.ResolveUrlResponse.classBuilder() as! Present.ResolveUrlResponse.Builder
        }
        public func getBuilder() -> Present.ResolveUrlResponse.Builder {
            return classBuilder() as! Present.ResolveUrlResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ResolveUrlResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ResolveUrlResponse.Builder()
        }
        public func toBuilder() throws -> Present.ResolveUrlResponse.Builder {
            return try Present.ResolveUrlResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.ResolveUrlResponse) throws -> Present.ResolveUrlResponse.Builder {
            return try Present.ResolveUrlResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasReferrer {
                jsonMap["referrer"] = try referrer.encode()
            }
            if hasType {
                jsonMap["type"] = type.toString()
            }
            if hasApp {
                jsonMap["app"] = try app.encode()
            }
            if hasUser {
                jsonMap["user"] = try user.encode()
            }
            if hasGroup {
                jsonMap["group"] = try group.encode()
            }
            if hasComment {
                jsonMap["comment"] = try comment.encode()
            }
            if hasCategory {
                jsonMap["category"] = try category.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.ResolveUrlResponse {
            return try Present.ResolveUrlResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.ResolveUrlResponse {
            return try Present.ResolveUrlResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasReferrer {
                output += "\(indent) referrer {\n"
                if let outDescReferrer = referrer {
                    output += try outDescReferrer.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasApp {
                output += "\(indent) app {\n"
                if let outDescApp = app {
                    output += try outDescApp.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasUser {
                output += "\(indent) user {\n"
                if let outDescUser = user {
                    output += try outDescUser.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasGroup {
                output += "\(indent) group {\n"
                if let outDescGroup = group {
                    output += try outDescGroup.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasComment {
                output += "\(indent) comment {\n"
                if let outDescComment = comment {
                    output += try outDescComment.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if (hasType) {
                output += "\(indent) type: \(type.description)\n"
            }
            if hasCategory {
                output += "\(indent) category {\n"
                if let outDescCategory = category {
                    output += try outDescCategory.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasReferrer {
                    if let hashValuereferrer = referrer?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuereferrer
                    }
                }
                if hasApp {
                    if let hashValueapp = app?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueapp
                    }
                }
                if hasUser {
                    if let hashValueuser = user?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuser
                    }
                }
                if hasGroup {
                    if let hashValuegroup = group?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegroup
                    }
                }
                if hasComment {
                    if let hashValuecomment = comment?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomment
                    }
                }
                if hasType {
                     hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasCategory {
                    if let hashValuecategory = category?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecategory
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.ResolveUrlResponse"
        }
        override public func className() -> String {
            return "Present.ResolveUrlResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.ResolveUrlResponse = Present.ResolveUrlResponse()
            public func getMessage() -> Present.ResolveUrlResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The user who generated the link.
            public var referrer:Present.UserResponse! {
                get {
                    if referrerBuilder_ != nil {
                        builderResult.referrer = referrerBuilder_.getMessage()
                    }
                    return builderResult.referrer
                }
                set (value) {
                    builderResult.hasReferrer = true
                    builderResult.referrer = value
                }
            }
            public var hasReferrer:Bool {
                get {
                    return builderResult.hasReferrer
                }
            }
            fileprivate var referrerBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasReferrer = true
                }
            }
            public func getReferrerBuilder() -> Present.UserResponse.Builder {
                if referrerBuilder_ == nil {
                    referrerBuilder_ = Present.UserResponse.Builder()
                    builderResult.referrer = referrerBuilder_.getMessage()
                    if referrer != nil {
                        try! referrerBuilder_.mergeFrom(other: referrer)
                    }
                }
                return referrerBuilder_
            }
            @discardableResult
            public func setReferrer(_ value:Present.UserResponse!) -> Present.ResolveUrlResponse.Builder {
                self.referrer = value
                return self
            }
            @discardableResult
            public func mergeReferrer(value:Present.UserResponse) throws -> Present.ResolveUrlResponse.Builder {
                if builderResult.hasReferrer {
                    builderResult.referrer = try Present.UserResponse.builderWithPrototype(prototype:builderResult.referrer).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.referrer = value
                }
                builderResult.hasReferrer = true
                return self
            }
            @discardableResult
            public func clearReferrer() -> Present.ResolveUrlResponse.Builder {
                referrerBuilder_ = nil
                builderResult.hasReferrer = false
                builderResult.referrer = nil
                return self
            }
            /// Type of entity returned.
                public var type:Present.ResolveUrlResponse.ProtoType {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool{
                    get {
                        return builderResult.hasType
                    }
                }
            @discardableResult
                public func setType(_ value:Present.ResolveUrlResponse.ProtoType) -> Present.ResolveUrlResponse.Builder {
                  self.type = value
                  return self
                }
            @discardableResult
                public func clearType() -> Present.ResolveUrlResponse.Builder {
                   builderResult.hasType = false
                   builderResult.type = .app
                   return self
                }
            public var app:Present.AppResponse! {
                get {
                    if appBuilder_ != nil {
                        builderResult.app = appBuilder_.getMessage()
                    }
                    return builderResult.app
                }
                set (value) {
                    builderResult.hasApp = true
                    builderResult.app = value
                }
            }
            public var hasApp:Bool {
                get {
                    return builderResult.hasApp
                }
            }
            fileprivate var appBuilder_:Present.AppResponse.Builder! {
                didSet {
                    builderResult.hasApp = true
                }
            }
            public func getAppBuilder() -> Present.AppResponse.Builder {
                if appBuilder_ == nil {
                    appBuilder_ = Present.AppResponse.Builder()
                    builderResult.app = appBuilder_.getMessage()
                    if app != nil {
                        try! appBuilder_.mergeFrom(other: app)
                    }
                }
                return appBuilder_
            }
            @discardableResult
            public func setApp(_ value:Present.AppResponse!) -> Present.ResolveUrlResponse.Builder {
                self.app = value
                return self
            }
            @discardableResult
            public func mergeApp(value:Present.AppResponse) throws -> Present.ResolveUrlResponse.Builder {
                if builderResult.hasApp {
                    builderResult.app = try Present.AppResponse.builderWithPrototype(prototype:builderResult.app).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.app = value
                }
                builderResult.hasApp = true
                return self
            }
            @discardableResult
            public func clearApp() -> Present.ResolveUrlResponse.Builder {
                appBuilder_ = nil
                builderResult.hasApp = false
                builderResult.app = nil
                return self
            }
            public var user:Present.UserResponse! {
                get {
                    if userBuilder_ != nil {
                        builderResult.user = userBuilder_.getMessage()
                    }
                    return builderResult.user
                }
                set (value) {
                    builderResult.hasUser = true
                    builderResult.user = value
                }
            }
            public var hasUser:Bool {
                get {
                    return builderResult.hasUser
                }
            }
            fileprivate var userBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasUser = true
                }
            }
            public func getUserBuilder() -> Present.UserResponse.Builder {
                if userBuilder_ == nil {
                    userBuilder_ = Present.UserResponse.Builder()
                    builderResult.user = userBuilder_.getMessage()
                    if user != nil {
                        try! userBuilder_.mergeFrom(other: user)
                    }
                }
                return userBuilder_
            }
            @discardableResult
            public func setUser(_ value:Present.UserResponse!) -> Present.ResolveUrlResponse.Builder {
                self.user = value
                return self
            }
            @discardableResult
            public func mergeUser(value:Present.UserResponse) throws -> Present.ResolveUrlResponse.Builder {
                if builderResult.hasUser {
                    builderResult.user = try Present.UserResponse.builderWithPrototype(prototype:builderResult.user).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.user = value
                }
                builderResult.hasUser = true
                return self
            }
            @discardableResult
            public func clearUser() -> Present.ResolveUrlResponse.Builder {
                userBuilder_ = nil
                builderResult.hasUser = false
                builderResult.user = nil
                return self
            }
            public var group:Present.GroupResponse! {
                get {
                    if groupBuilder_ != nil {
                        builderResult.group = groupBuilder_.getMessage()
                    }
                    return builderResult.group
                }
                set (value) {
                    builderResult.hasGroup = true
                    builderResult.group = value
                }
            }
            public var hasGroup:Bool {
                get {
                    return builderResult.hasGroup
                }
            }
            fileprivate var groupBuilder_:Present.GroupResponse.Builder! {
                didSet {
                    builderResult.hasGroup = true
                }
            }
            public func getGroupBuilder() -> Present.GroupResponse.Builder {
                if groupBuilder_ == nil {
                    groupBuilder_ = Present.GroupResponse.Builder()
                    builderResult.group = groupBuilder_.getMessage()
                    if group != nil {
                        try! groupBuilder_.mergeFrom(other: group)
                    }
                }
                return groupBuilder_
            }
            @discardableResult
            public func setGroup(_ value:Present.GroupResponse!) -> Present.ResolveUrlResponse.Builder {
                self.group = value
                return self
            }
            @discardableResult
            public func mergeGroup(value:Present.GroupResponse) throws -> Present.ResolveUrlResponse.Builder {
                if builderResult.hasGroup {
                    builderResult.group = try Present.GroupResponse.builderWithPrototype(prototype:builderResult.group).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.group = value
                }
                builderResult.hasGroup = true
                return self
            }
            @discardableResult
            public func clearGroup() -> Present.ResolveUrlResponse.Builder {
                groupBuilder_ = nil
                builderResult.hasGroup = false
                builderResult.group = nil
                return self
            }
            public var comment:Present.CommentResponse! {
                get {
                    if commentBuilder_ != nil {
                        builderResult.comment = commentBuilder_.getMessage()
                    }
                    return builderResult.comment
                }
                set (value) {
                    builderResult.hasComment = true
                    builderResult.comment = value
                }
            }
            public var hasComment:Bool {
                get {
                    return builderResult.hasComment
                }
            }
            fileprivate var commentBuilder_:Present.CommentResponse.Builder! {
                didSet {
                    builderResult.hasComment = true
                }
            }
            public func getCommentBuilder() -> Present.CommentResponse.Builder {
                if commentBuilder_ == nil {
                    commentBuilder_ = Present.CommentResponse.Builder()
                    builderResult.comment = commentBuilder_.getMessage()
                    if comment != nil {
                        try! commentBuilder_.mergeFrom(other: comment)
                    }
                }
                return commentBuilder_
            }
            @discardableResult
            public func setComment(_ value:Present.CommentResponse!) -> Present.ResolveUrlResponse.Builder {
                self.comment = value
                return self
            }
            @discardableResult
            public func mergeComment(value:Present.CommentResponse) throws -> Present.ResolveUrlResponse.Builder {
                if builderResult.hasComment {
                    builderResult.comment = try Present.CommentResponse.builderWithPrototype(prototype:builderResult.comment).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.comment = value
                }
                builderResult.hasComment = true
                return self
            }
            @discardableResult
            public func clearComment() -> Present.ResolveUrlResponse.Builder {
                commentBuilder_ = nil
                builderResult.hasComment = false
                builderResult.comment = nil
                return self
            }
            public var category:Present.CategoryResponse! {
                get {
                    if categoryBuilder_ != nil {
                        builderResult.category = categoryBuilder_.getMessage()
                    }
                    return builderResult.category
                }
                set (value) {
                    builderResult.hasCategory = true
                    builderResult.category = value
                }
            }
            public var hasCategory:Bool {
                get {
                    return builderResult.hasCategory
                }
            }
            fileprivate var categoryBuilder_:Present.CategoryResponse.Builder! {
                didSet {
                    builderResult.hasCategory = true
                }
            }
            public func getCategoryBuilder() -> Present.CategoryResponse.Builder {
                if categoryBuilder_ == nil {
                    categoryBuilder_ = Present.CategoryResponse.Builder()
                    builderResult.category = categoryBuilder_.getMessage()
                    if category != nil {
                        try! categoryBuilder_.mergeFrom(other: category)
                    }
                }
                return categoryBuilder_
            }
            @discardableResult
            public func setCategory(_ value:Present.CategoryResponse!) -> Present.ResolveUrlResponse.Builder {
                self.category = value
                return self
            }
            @discardableResult
            public func mergeCategory(value:Present.CategoryResponse) throws -> Present.ResolveUrlResponse.Builder {
                if builderResult.hasCategory {
                    builderResult.category = try Present.CategoryResponse.builderWithPrototype(prototype:builderResult.category).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.category = value
                }
                builderResult.hasCategory = true
                return self
            }
            @discardableResult
            public func clearCategory() -> Present.ResolveUrlResponse.Builder {
                categoryBuilder_ = nil
                builderResult.hasCategory = false
                builderResult.category = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.ResolveUrlResponse.Builder {
                builderResult = Present.ResolveUrlResponse()
                return self
            }
            override public func clone() throws -> Present.ResolveUrlResponse.Builder {
                return try Present.ResolveUrlResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.ResolveUrlResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.ResolveUrlResponse {
                let returnMe:Present.ResolveUrlResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.ResolveUrlResponse) throws -> Present.ResolveUrlResponse.Builder {
                if other == Present.ResolveUrlResponse() {
                    return self
                }
                if (other.hasReferrer) {
                    try mergeReferrer(value: other.referrer)
                }
                if other.hasType {
                    type = other.type
                }
                if (other.hasApp) {
                    try mergeApp(value: other.app)
                }
                if (other.hasUser) {
                    try mergeUser(value: other.user)
                }
                if (other.hasGroup) {
                    try mergeGroup(value: other.group)
                }
                if (other.hasComment) {
                    try mergeComment(value: other.comment)
                }
                if (other.hasCategory) {
                    try mergeCategory(value: other.category)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.ResolveUrlResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ResolveUrlResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasReferrer {
                            try subBuilder.mergeFrom(other: referrer)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        referrer = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Present.AppResponse.Builder = Present.AppResponse.Builder()
                        if hasApp {
                            try subBuilder.mergeFrom(other: app)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        app = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasUser {
                            try subBuilder.mergeFrom(other: user)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        user = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Present.GroupResponse.Builder = Present.GroupResponse.Builder()
                        if hasGroup {
                            try subBuilder.mergeFrom(other: group)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        group = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:Present.CommentResponse.Builder = Present.CommentResponse.Builder()
                        if hasComment {
                            try subBuilder.mergeFrom(other: comment)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        comment = subBuilder.buildPartial()

                    case 48:
                        let valueInttype = try codedInputStream.readEnum()
                        if let enumstype = Present.ResolveUrlResponse.ProtoType(rawValue:valueInttype){
                            type = enumstype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 6, value:Int64(valueInttype))
                        }

                    case 58:
                        let subBuilder:Present.CategoryResponse.Builder = Present.CategoryResponse.Builder()
                        if hasCategory {
                            try subBuilder.mergeFrom(other: category)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        category = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.ResolveUrlResponse.Builder {
                let resultDecodedBuilder = Present.ResolveUrlResponse.Builder()
                if let jsonValueReferrer = jsonMap["referrer"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.referrer = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueReferrer).build()

                }
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = try Present.ResolveUrlResponse.ProtoType.fromString(str: jsonValueType)
                }
                if let jsonValueApp = jsonMap["app"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.app = try Present.AppResponse.Builder.decodeToBuilder(jsonMap:jsonValueApp).build()

                }
                if let jsonValueUser = jsonMap["user"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.user = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueUser).build()

                }
                if let jsonValueGroup = jsonMap["group"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.group = try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:jsonValueGroup).build()

                }
                if let jsonValueComment = jsonMap["comment"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.comment = try Present.CommentResponse.Builder.decodeToBuilder(jsonMap:jsonValueComment).build()

                }
                if let jsonValueCategory = jsonMap["category"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.category = try Present.CategoryResponse.Builder.decodeToBuilder(jsonMap:jsonValueCategory).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.ResolveUrlResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.ResolveUrlResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Represents a link to the app.
    final public class AppResponse : GeneratedMessage {

        public static func == (lhs: Present.AppResponse, rhs: Present.AppResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AppResponse.Builder {
            return Present.AppResponse.classBuilder() as! Present.AppResponse.Builder
        }
        public func getBuilder() -> Present.AppResponse.Builder {
            return classBuilder() as! Present.AppResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AppResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AppResponse.Builder()
        }
        public func toBuilder() throws -> Present.AppResponse.Builder {
            return try Present.AppResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AppResponse) throws -> Present.AppResponse.Builder {
            return try Present.AppResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AppResponse {
            return try Present.AppResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AppResponse {
            return try Present.AppResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AppResponse"
        }
        override public func className() -> String {
            return "Present.AppResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AppResponse = Present.AppResponse()
            public func getMessage() -> Present.AppResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AppResponse.Builder {
                builderResult = Present.AppResponse()
                return self
            }
            override public func clone() throws -> Present.AppResponse.Builder {
                return try Present.AppResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AppResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AppResponse {
                let returnMe:Present.AppResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AppResponse) throws -> Present.AppResponse.Builder {
                if other == Present.AppResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AppResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AppResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AppResponse.Builder {
                let resultDecodedBuilder = Present.AppResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AppResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AppResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A link to a category.
    final public class CategoryResponse : GeneratedMessage {

        public static func == (lhs: Present.CategoryResponse, rhs: Present.CategoryResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The category name. May be different from the name in the URL if this category was renamed.
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasName {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 1, value:name)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.CategoryResponse.Builder {
            return Present.CategoryResponse.classBuilder() as! Present.CategoryResponse.Builder
        }
        public func getBuilder() -> Present.CategoryResponse.Builder {
            return classBuilder() as! Present.CategoryResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CategoryResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CategoryResponse.Builder()
        }
        public func toBuilder() throws -> Present.CategoryResponse.Builder {
            return try Present.CategoryResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.CategoryResponse) throws -> Present.CategoryResponse.Builder {
            return try Present.CategoryResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = name
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.CategoryResponse {
            return try Present.CategoryResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.CategoryResponse {
            return try Present.CategoryResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.CategoryResponse"
        }
        override public func className() -> String {
            return "Present.CategoryResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.CategoryResponse = Present.CategoryResponse()
            public func getMessage() -> Present.CategoryResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The category name. May be different from the name in the URL if this category was renamed.
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Present.CategoryResponse.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Present.CategoryResponse.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.CategoryResponse.Builder {
                builderResult = Present.CategoryResponse()
                return self
            }
            override public func clone() throws -> Present.CategoryResponse.Builder {
                return try Present.CategoryResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.CategoryResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.CategoryResponse {
                let returnMe:Present.CategoryResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.CategoryResponse) throws -> Present.CategoryResponse.Builder {
                if other == Present.CategoryResponse() {
                    return self
                }
                if other.hasName {
                    name = other.name
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.CategoryResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CategoryResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        name = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.CategoryResponse.Builder {
                let resultDecodedBuilder = Present.CategoryResponse.Builder()
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.CategoryResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.CategoryResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Present.ResolveUrlRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.ResolveUrlRequest> {
        var mergedArray = Array<Present.ResolveUrlRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.ResolveUrlRequest? {
        return try Present.ResolveUrlRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.ResolveUrlRequest {
        return try Present.ResolveUrlRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UrlRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.ResolveUrlRequest {
        return try Present.ResolveUrlRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.ResolveUrlRequest {
        return try Present.ResolveUrlRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ResolveUrlRequest {
        return try Present.ResolveUrlRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.ResolveUrlRequest {
        return try Present.ResolveUrlRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ResolveUrlRequest {
        return try Present.ResolveUrlRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "url": return self.url
        default: return nil
        }
    }
}
extension Present.ResolveUrlRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "url": return self.url
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "url":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.url = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.ResolveUrlResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.ResolveUrlResponse> {
        var mergedArray = Array<Present.ResolveUrlResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.ResolveUrlResponse? {
        return try Present.ResolveUrlResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.ResolveUrlResponse {
        return try Present.ResolveUrlResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UrlRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.ResolveUrlResponse {
        return try Present.ResolveUrlResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.ResolveUrlResponse {
        return try Present.ResolveUrlResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ResolveUrlResponse {
        return try Present.ResolveUrlResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.ResolveUrlResponse {
        return try Present.ResolveUrlResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ResolveUrlResponse {
        return try Present.ResolveUrlResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "referrer": return self.referrer
        case "type": return self.type
        case "app": return self.app
        case "user": return self.user
        case "group": return self.group
        case "comment": return self.comment
        case "category": return self.category
        default: return nil
        }
    }
}
extension Present.ResolveUrlResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "referrer": return self.referrer
            case "type": return self.type
            case "app": return self.app
            case "user": return self.user
            case "group": return self.group
            case "comment": return self.comment
            case "category": return self.category
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "referrer":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.referrer = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Present.ResolveUrlResponse.ProtoType else {
                    return
                }
                self.type = newSubscriptValue
            case "app":
                guard let newSubscriptValue = newSubscriptValue as? Present.AppResponse else {
                    return
                }
                self.app = newSubscriptValue
            case "user":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.user = newSubscriptValue
            case "group":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupResponse else {
                    return
                }
                self.group = newSubscriptValue
            case "comment":
                guard let newSubscriptValue = newSubscriptValue as? Present.CommentResponse else {
                    return
                }
                self.comment = newSubscriptValue
            case "category":
                guard let newSubscriptValue = newSubscriptValue as? Present.CategoryResponse else {
                    return
                }
                self.category = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AppResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AppResponse> {
        var mergedArray = Array<Present.AppResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AppResponse? {
        return try Present.AppResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AppResponse {
        return try Present.AppResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UrlRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AppResponse {
        return try Present.AppResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AppResponse {
        return try Present.AppResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AppResponse {
        return try Present.AppResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AppResponse {
        return try Present.AppResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AppResponse {
        return try Present.AppResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Present.AppResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Present.CategoryResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.CategoryResponse> {
        var mergedArray = Array<Present.CategoryResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.CategoryResponse? {
        return try Present.CategoryResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.CategoryResponse {
        return try Present.CategoryResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UrlRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.CategoryResponse {
        return try Present.CategoryResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.CategoryResponse {
        return try Present.CategoryResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CategoryResponse {
        return try Present.CategoryResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.CategoryResponse {
        return try Present.CategoryResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CategoryResponse {
        return try Present.CategoryResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        default: return nil
        }
    }
}
extension Present.CategoryResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
