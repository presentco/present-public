/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "user.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public extension Present{}

public extension Present {
    public struct UserRoot {
        public static let `default` = UserRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Present.CoreRoot.default.registerAllExtensions(registry: extensionRegistry)
            Present.ContentRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    public enum Feature:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case coinsForJoins = 1
        case circleCreation = 2
        public func toString() -> String {
            switch self {
            case .coinsForJoins: return "COINS_FOR_JOINS"
            case .circleCreation: return "CIRCLE_CREATION"
            }
        }
        public static func fromString(str:String) throws -> Present.Feature {
            switch str {
            case "COINS_FOR_JOINS":    return .coinsForJoins
            case "CIRCLE_CREATION":    return .circleCreation
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .coinsForJoins: return ".coinsForJoins"
            case .circleCreation: return ".circleCreation"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:Feature, rhs:Feature) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum Gender:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        /// TODO: The iOS Client build process requires enum names to be unique.
        /// TODO: We temporarily change the name for the iOS build.  The wire format is unaffected.
        case unknownGender = 0
        case woman = 1
        case man = 2
        case other = 3
        public func toString() -> String {
            switch self {
            case .unknownGender: return "UNKNOWN_GENDER"
            case .woman: return "WOMAN"
            case .man: return "MAN"
            case .other: return "OTHER"
            }
        }
        public static func fromString(str:String) throws -> Present.Gender {
            switch str {
            case "UNKNOWN_GENDER":    return .unknownGender
            case "WOMAN":    return .woman
            case "MAN":    return .man
            case "OTHER":    return .other
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .unknownGender: return ".unknownGender"
            case .woman: return ".woman"
            case .man: return ".man"
            case .other: return ".other"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:Gender, rhs:Gender) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum FriendshipState:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        /// Friendship was requested.
        case requested = 1

        /// A friendship request was accepted.
        case accepted = 2
        public func toString() -> String {
            switch self {
            case .requested: return "REQUESTED"
            case .accepted: return "ACCEPTED"
            }
        }
        public static func fromString(str:String) throws -> Present.FriendshipState {
            switch str {
            case "REQUESTED":    return .requested
            case "ACCEPTED":    return .accepted
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .requested: return ".requested"
            case .accepted: return ".accepted"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:FriendshipState, rhs:FriendshipState) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    /// Indicates whether or not the user is allowed to access the app.
    final public class Authorization : GeneratedMessage {

        public static func == (lhs: Present.Authorization, rhs: Present.Authorization) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNextStep == rhs.hasNextStep) && (!lhs.hasNextStep || lhs.nextStep == rhs.nextStep)
            fieldCheck = fieldCheck && (lhs.hasBlockScreen == rhs.hasBlockScreen) && (!lhs.hasBlockScreen || lhs.blockScreen == rhs.blockScreen)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum NextStep:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// Proceed to the app!
                case proceed = 1

                /// Link Facebook.
                case authenticate = 2

                /// Continue signup.
                case signUp = 3

                /// Show the block screen. The client should poll synchronize() to see if it should proceed.
                case block = 4
                public func toString() -> String {
                    switch self {
                    case .proceed: return "PROCEED"
                    case .authenticate: return "AUTHENTICATE"
                    case .signUp: return "SIGN_UP"
                    case .block: return "BLOCK"
                    }
                }
                public static func fromString(str:String) throws -> Present.Authorization.NextStep {
                    switch str {
                    case "PROCEED":    return .proceed
                    case "AUTHENTICATE":    return .authenticate
                    case "SIGN_UP":    return .signUp
                    case "BLOCK":    return .block
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .proceed: return ".proceed"
                    case .authenticate: return ".authenticate"
                    case .signUp: return ".signUp"
                    case .block: return ".block"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:NextStep, rhs:NextStep) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var nextStep:Present.Authorization.NextStep = Present.Authorization.NextStep.proceed
        public fileprivate(set) var hasNextStep:Bool = false
        public fileprivate(set) var blockScreen:Present.BlockScreen!
        public fileprivate(set) var hasBlockScreen:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasNextStep {
                return false
            }
            if hasBlockScreen {
                if !blockScreen.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNextStep {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:nextStep.rawValue)
            }
            if hasBlockScreen {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:blockScreen)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasNextStep) {
                serialize_size += nextStep.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasBlockScreen {
                if let varSizeblockScreen = blockScreen?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeblockScreen
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.Authorization.Builder {
            return Present.Authorization.classBuilder() as! Present.Authorization.Builder
        }
        public func getBuilder() -> Present.Authorization.Builder {
            return classBuilder() as! Present.Authorization.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Authorization.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Authorization.Builder()
        }
        public func toBuilder() throws -> Present.Authorization.Builder {
            return try Present.Authorization.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.Authorization) throws -> Present.Authorization.Builder {
            return try Present.Authorization.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNextStep {
                jsonMap["nextStep"] = nextStep.toString()
            }
            if hasBlockScreen {
                jsonMap["blockScreen"] = try blockScreen.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.Authorization {
            return try Present.Authorization.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.Authorization {
            return try Present.Authorization.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasNextStep) {
                output += "\(indent) nextStep: \(nextStep.description)\n"
            }
            if hasBlockScreen {
                output += "\(indent) blockScreen {\n"
                if let outDescBlockScreen = blockScreen {
                    output += try outDescBlockScreen.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNextStep {
                     hashCode = (hashCode &* 31) &+ nextStep.hashValue
                }
                if hasBlockScreen {
                    if let hashValueblockScreen = blockScreen?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueblockScreen
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.Authorization"
        }
        override public func className() -> String {
            return "Present.Authorization"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.Authorization = Present.Authorization()
            public func getMessage() -> Present.Authorization {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Instructs the client on what to do next.
                public var nextStep:Present.Authorization.NextStep {
                    get {
                        return builderResult.nextStep
                    }
                    set (value) {
                        builderResult.hasNextStep = true
                        builderResult.nextStep = value
                    }
                }
                public var hasNextStep:Bool{
                    get {
                        return builderResult.hasNextStep
                    }
                }
            @discardableResult
                public func setNextStep(_ value:Present.Authorization.NextStep) -> Present.Authorization.Builder {
                  self.nextStep = value
                  return self
                }
            @discardableResult
                public func clearNextStep() -> Present.Authorization.Builder {
                   builderResult.hasNextStep = false
                   builderResult.nextStep = .proceed
                   return self
                }
            /// If nextStep == BLOCK, display this content.
            public var blockScreen:Present.BlockScreen! {
                get {
                    if blockScreenBuilder_ != nil {
                        builderResult.blockScreen = blockScreenBuilder_.getMessage()
                    }
                    return builderResult.blockScreen
                }
                set (value) {
                    builderResult.hasBlockScreen = true
                    builderResult.blockScreen = value
                }
            }
            public var hasBlockScreen:Bool {
                get {
                    return builderResult.hasBlockScreen
                }
            }
            fileprivate var blockScreenBuilder_:Present.BlockScreen.Builder! {
                didSet {
                    builderResult.hasBlockScreen = true
                }
            }
            public func getBlockScreenBuilder() -> Present.BlockScreen.Builder {
                if blockScreenBuilder_ == nil {
                    blockScreenBuilder_ = Present.BlockScreen.Builder()
                    builderResult.blockScreen = blockScreenBuilder_.getMessage()
                    if blockScreen != nil {
                        try! blockScreenBuilder_.mergeFrom(other: blockScreen)
                    }
                }
                return blockScreenBuilder_
            }
            @discardableResult
            public func setBlockScreen(_ value:Present.BlockScreen!) -> Present.Authorization.Builder {
                self.blockScreen = value
                return self
            }
            @discardableResult
            public func mergeBlockScreen(value:Present.BlockScreen) throws -> Present.Authorization.Builder {
                if builderResult.hasBlockScreen {
                    builderResult.blockScreen = try Present.BlockScreen.builderWithPrototype(prototype:builderResult.blockScreen).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.blockScreen = value
                }
                builderResult.hasBlockScreen = true
                return self
            }
            @discardableResult
            public func clearBlockScreen() -> Present.Authorization.Builder {
                blockScreenBuilder_ = nil
                builderResult.hasBlockScreen = false
                builderResult.blockScreen = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.Authorization.Builder {
                builderResult = Present.Authorization()
                return self
            }
            override public func clone() throws -> Present.Authorization.Builder {
                return try Present.Authorization.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.Authorization {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.Authorization {
                let returnMe:Present.Authorization = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.Authorization) throws -> Present.Authorization.Builder {
                if other == Present.Authorization() {
                    return self
                }
                if other.hasNextStep {
                    nextStep = other.nextStep
                }
                if (other.hasBlockScreen) {
                    try mergeBlockScreen(value: other.blockScreen)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.Authorization.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Authorization.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntnextStep = try codedInputStream.readEnum()
                        if let enumsnextStep = Present.Authorization.NextStep(rawValue:valueIntnextStep){
                            nextStep = enumsnextStep
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntnextStep))
                        }

                    case 18:
                        let subBuilder:Present.BlockScreen.Builder = Present.BlockScreen.Builder()
                        if hasBlockScreen {
                            try subBuilder.mergeFrom(other: blockScreen)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        blockScreen = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.Authorization.Builder {
                let resultDecodedBuilder = Present.Authorization.Builder()
                if let jsonValueNextStep = jsonMap["nextStep"] as? String {
                    resultDecodedBuilder.nextStep = try Present.Authorization.NextStep.fromString(str: jsonValueNextStep)
                }
                if let jsonValueBlockScreen = jsonMap["blockScreen"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.blockScreen = try Present.BlockScreen.Builder.decodeToBuilder(jsonMap:jsonValueBlockScreen).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.Authorization.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.Authorization.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class BlockScreen : GeneratedMessage {

        public static func == (lhs: Present.BlockScreen, rhs: Present.BlockScreen) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasText == rhs.hasText) && (!lhs.hasText || lhs.text == rhs.text)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var text:String = ""
        public fileprivate(set) var hasText:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasText {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasText {
                try codedOutputStream.writeString(fieldNumber: 1, value:text)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasText {
                serialize_size += text.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.BlockScreen.Builder {
            return Present.BlockScreen.classBuilder() as! Present.BlockScreen.Builder
        }
        public func getBuilder() -> Present.BlockScreen.Builder {
            return classBuilder() as! Present.BlockScreen.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.BlockScreen.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.BlockScreen.Builder()
        }
        public func toBuilder() throws -> Present.BlockScreen.Builder {
            return try Present.BlockScreen.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.BlockScreen) throws -> Present.BlockScreen.Builder {
            return try Present.BlockScreen.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasText {
                jsonMap["text"] = text
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.BlockScreen {
            return try Present.BlockScreen.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.BlockScreen {
            return try Present.BlockScreen.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasText {
                output += "\(indent) text: \(text) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasText {
                    hashCode = (hashCode &* 31) &+ text.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.BlockScreen"
        }
        override public func className() -> String {
            return "Present.BlockScreen"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.BlockScreen = Present.BlockScreen()
            public func getMessage() -> Present.BlockScreen {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var text:String {
                get {
                    return builderResult.text
                }
                set (value) {
                    builderResult.hasText = true
                    builderResult.text = value
                }
            }
            public var hasText:Bool {
                get {
                    return builderResult.hasText
                }
            }
            @discardableResult
            public func setText(_ value:String) -> Present.BlockScreen.Builder {
                self.text = value
                return self
            }
            @discardableResult
            public func clearText() -> Present.BlockScreen.Builder{
                builderResult.hasText = false
                builderResult.text = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.BlockScreen.Builder {
                builderResult = Present.BlockScreen()
                return self
            }
            override public func clone() throws -> Present.BlockScreen.Builder {
                return try Present.BlockScreen.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.BlockScreen {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.BlockScreen {
                let returnMe:Present.BlockScreen = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.BlockScreen) throws -> Present.BlockScreen.Builder {
                if other == Present.BlockScreen() {
                    return self
                }
                if other.hasText {
                    text = other.text
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.BlockScreen.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.BlockScreen.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        text = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.BlockScreen.Builder {
                let resultDecodedBuilder = Present.BlockScreen.Builder()
                if let jsonValueText = jsonMap["text"] as? String {
                    resultDecodedBuilder.text = jsonValueText
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.BlockScreen.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.BlockScreen.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LinkFacebookRequest : GeneratedMessage {

        public static func == (lhs: Present.LinkFacebookRequest, rhs: Present.LinkFacebookRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAccessToken == rhs.hasAccessToken) && (!lhs.hasAccessToken || lhs.accessToken == rhs.accessToken)
            fieldCheck = fieldCheck && (lhs.hasFacebookId == rhs.hasFacebookId) && (!lhs.hasFacebookId || lhs.facebookId == rhs.facebookId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The user access token generated by the client SDK via a user interaction.
        public fileprivate(set) var accessToken:String = ""
        public fileprivate(set) var hasAccessToken:Bool = false

        /// Used in testing. Ignored otherwise.
        public fileprivate(set) var facebookId:String = ""
        public fileprivate(set) var hasFacebookId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasAccessToken {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAccessToken {
                try codedOutputStream.writeString(fieldNumber: 1, value:accessToken)
            }
            if hasFacebookId {
                try codedOutputStream.writeString(fieldNumber: 2, value:facebookId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAccessToken {
                serialize_size += accessToken.computeStringSize(fieldNumber: 1)
            }
            if hasFacebookId {
                serialize_size += facebookId.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.LinkFacebookRequest.Builder {
            return Present.LinkFacebookRequest.classBuilder() as! Present.LinkFacebookRequest.Builder
        }
        public func getBuilder() -> Present.LinkFacebookRequest.Builder {
            return classBuilder() as! Present.LinkFacebookRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.LinkFacebookRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.LinkFacebookRequest.Builder()
        }
        public func toBuilder() throws -> Present.LinkFacebookRequest.Builder {
            return try Present.LinkFacebookRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.LinkFacebookRequest) throws -> Present.LinkFacebookRequest.Builder {
            return try Present.LinkFacebookRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAccessToken {
                jsonMap["accessToken"] = accessToken
            }
            if hasFacebookId {
                jsonMap["facebookId"] = facebookId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.LinkFacebookRequest {
            return try Present.LinkFacebookRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.LinkFacebookRequest {
            return try Present.LinkFacebookRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAccessToken {
                output += "\(indent) accessToken: \(accessToken) \n"
            }
            if hasFacebookId {
                output += "\(indent) facebookId: \(facebookId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAccessToken {
                    hashCode = (hashCode &* 31) &+ accessToken.hashValue
                }
                if hasFacebookId {
                    hashCode = (hashCode &* 31) &+ facebookId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.LinkFacebookRequest"
        }
        override public func className() -> String {
            return "Present.LinkFacebookRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.LinkFacebookRequest = Present.LinkFacebookRequest()
            public func getMessage() -> Present.LinkFacebookRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The user access token generated by the client SDK via a user interaction.
            public var accessToken:String {
                get {
                    return builderResult.accessToken
                }
                set (value) {
                    builderResult.hasAccessToken = true
                    builderResult.accessToken = value
                }
            }
            public var hasAccessToken:Bool {
                get {
                    return builderResult.hasAccessToken
                }
            }
            @discardableResult
            public func setAccessToken(_ value:String) -> Present.LinkFacebookRequest.Builder {
                self.accessToken = value
                return self
            }
            @discardableResult
            public func clearAccessToken() -> Present.LinkFacebookRequest.Builder{
                builderResult.hasAccessToken = false
                builderResult.accessToken = ""
                return self
            }
            /// Used in testing. Ignored otherwise.
            public var facebookId:String {
                get {
                    return builderResult.facebookId
                }
                set (value) {
                    builderResult.hasFacebookId = true
                    builderResult.facebookId = value
                }
            }
            public var hasFacebookId:Bool {
                get {
                    return builderResult.hasFacebookId
                }
            }
            @discardableResult
            public func setFacebookId(_ value:String) -> Present.LinkFacebookRequest.Builder {
                self.facebookId = value
                return self
            }
            @discardableResult
            public func clearFacebookId() -> Present.LinkFacebookRequest.Builder{
                builderResult.hasFacebookId = false
                builderResult.facebookId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.LinkFacebookRequest.Builder {
                builderResult = Present.LinkFacebookRequest()
                return self
            }
            override public func clone() throws -> Present.LinkFacebookRequest.Builder {
                return try Present.LinkFacebookRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.LinkFacebookRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.LinkFacebookRequest {
                let returnMe:Present.LinkFacebookRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.LinkFacebookRequest) throws -> Present.LinkFacebookRequest.Builder {
                if other == Present.LinkFacebookRequest() {
                    return self
                }
                if other.hasAccessToken {
                    accessToken = other.accessToken
                }
                if other.hasFacebookId {
                    facebookId = other.facebookId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.LinkFacebookRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LinkFacebookRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        accessToken = try codedInputStream.readString()

                    case 18:
                        facebookId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.LinkFacebookRequest.Builder {
                let resultDecodedBuilder = Present.LinkFacebookRequest.Builder()
                if let jsonValueAccessToken = jsonMap["accessToken"] as? String {
                    resultDecodedBuilder.accessToken = jsonValueAccessToken
                }
                if let jsonValueFacebookId = jsonMap["facebookId"] as? String {
                    resultDecodedBuilder.facebookId = jsonValueFacebookId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.LinkFacebookRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.LinkFacebookRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class AuthorizationResponse : GeneratedMessage {

        public static func == (lhs: Present.AuthorizationResponse, rhs: Present.AuthorizationResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAuthorization == rhs.hasAuthorization) && (!lhs.hasAuthorization || lhs.authorization == rhs.authorization)
            fieldCheck = fieldCheck && (lhs.hasUserProfile == rhs.hasUserProfile) && (!lhs.hasUserProfile || lhs.userProfile == rhs.userProfile)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var authorization:Present.Authorization!
        public fileprivate(set) var hasAuthorization:Bool = false
        public fileprivate(set) var userProfile:Present.UserProfile!
        public fileprivate(set) var hasUserProfile:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasAuthorization {
                return false
            }
            if !authorization.isInitialized() {
                return false
            }
            if hasUserProfile {
                if !userProfile.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAuthorization {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:authorization)
            }
            if hasUserProfile {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:userProfile)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAuthorization {
                if let varSizeauthorization = authorization?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeauthorization
                }
            }
            if hasUserProfile {
                if let varSizeuserProfile = userProfile?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeuserProfile
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AuthorizationResponse.Builder {
            return Present.AuthorizationResponse.classBuilder() as! Present.AuthorizationResponse.Builder
        }
        public func getBuilder() -> Present.AuthorizationResponse.Builder {
            return classBuilder() as! Present.AuthorizationResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AuthorizationResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AuthorizationResponse.Builder()
        }
        public func toBuilder() throws -> Present.AuthorizationResponse.Builder {
            return try Present.AuthorizationResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AuthorizationResponse) throws -> Present.AuthorizationResponse.Builder {
            return try Present.AuthorizationResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAuthorization {
                jsonMap["authorization"] = try authorization.encode()
            }
            if hasUserProfile {
                jsonMap["userProfile"] = try userProfile.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AuthorizationResponse {
            return try Present.AuthorizationResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AuthorizationResponse {
            return try Present.AuthorizationResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAuthorization {
                output += "\(indent) authorization {\n"
                if let outDescAuthorization = authorization {
                    output += try outDescAuthorization.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasUserProfile {
                output += "\(indent) userProfile {\n"
                if let outDescUserProfile = userProfile {
                    output += try outDescUserProfile.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAuthorization {
                    if let hashValueauthorization = authorization?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueauthorization
                    }
                }
                if hasUserProfile {
                    if let hashValueuserProfile = userProfile?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuserProfile
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AuthorizationResponse"
        }
        override public func className() -> String {
            return "Present.AuthorizationResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AuthorizationResponse = Present.AuthorizationResponse()
            public func getMessage() -> Present.AuthorizationResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var authorization:Present.Authorization! {
                get {
                    if authorizationBuilder_ != nil {
                        builderResult.authorization = authorizationBuilder_.getMessage()
                    }
                    return builderResult.authorization
                }
                set (value) {
                    builderResult.hasAuthorization = true
                    builderResult.authorization = value
                }
            }
            public var hasAuthorization:Bool {
                get {
                    return builderResult.hasAuthorization
                }
            }
            fileprivate var authorizationBuilder_:Present.Authorization.Builder! {
                didSet {
                    builderResult.hasAuthorization = true
                }
            }
            public func getAuthorizationBuilder() -> Present.Authorization.Builder {
                if authorizationBuilder_ == nil {
                    authorizationBuilder_ = Present.Authorization.Builder()
                    builderResult.authorization = authorizationBuilder_.getMessage()
                    if authorization != nil {
                        try! authorizationBuilder_.mergeFrom(other: authorization)
                    }
                }
                return authorizationBuilder_
            }
            @discardableResult
            public func setAuthorization(_ value:Present.Authorization!) -> Present.AuthorizationResponse.Builder {
                self.authorization = value
                return self
            }
            @discardableResult
            public func mergeAuthorization(value:Present.Authorization) throws -> Present.AuthorizationResponse.Builder {
                if builderResult.hasAuthorization {
                    builderResult.authorization = try Present.Authorization.builderWithPrototype(prototype:builderResult.authorization).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.authorization = value
                }
                builderResult.hasAuthorization = true
                return self
            }
            @discardableResult
            public func clearAuthorization() -> Present.AuthorizationResponse.Builder {
                authorizationBuilder_ = nil
                builderResult.hasAuthorization = false
                builderResult.authorization = nil
                return self
            }
            /// The user's current profile. Null if authorization.nextStep == AUTHENTICATE.
            public var userProfile:Present.UserProfile! {
                get {
                    if userProfileBuilder_ != nil {
                        builderResult.userProfile = userProfileBuilder_.getMessage()
                    }
                    return builderResult.userProfile
                }
                set (value) {
                    builderResult.hasUserProfile = true
                    builderResult.userProfile = value
                }
            }
            public var hasUserProfile:Bool {
                get {
                    return builderResult.hasUserProfile
                }
            }
            fileprivate var userProfileBuilder_:Present.UserProfile.Builder! {
                didSet {
                    builderResult.hasUserProfile = true
                }
            }
            public func getUserProfileBuilder() -> Present.UserProfile.Builder {
                if userProfileBuilder_ == nil {
                    userProfileBuilder_ = Present.UserProfile.Builder()
                    builderResult.userProfile = userProfileBuilder_.getMessage()
                    if userProfile != nil {
                        try! userProfileBuilder_.mergeFrom(other: userProfile)
                    }
                }
                return userProfileBuilder_
            }
            @discardableResult
            public func setUserProfile(_ value:Present.UserProfile!) -> Present.AuthorizationResponse.Builder {
                self.userProfile = value
                return self
            }
            @discardableResult
            public func mergeUserProfile(value:Present.UserProfile) throws -> Present.AuthorizationResponse.Builder {
                if builderResult.hasUserProfile {
                    builderResult.userProfile = try Present.UserProfile.builderWithPrototype(prototype:builderResult.userProfile).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.userProfile = value
                }
                builderResult.hasUserProfile = true
                return self
            }
            @discardableResult
            public func clearUserProfile() -> Present.AuthorizationResponse.Builder {
                userProfileBuilder_ = nil
                builderResult.hasUserProfile = false
                builderResult.userProfile = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AuthorizationResponse.Builder {
                builderResult = Present.AuthorizationResponse()
                return self
            }
            override public func clone() throws -> Present.AuthorizationResponse.Builder {
                return try Present.AuthorizationResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AuthorizationResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AuthorizationResponse {
                let returnMe:Present.AuthorizationResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AuthorizationResponse) throws -> Present.AuthorizationResponse.Builder {
                if other == Present.AuthorizationResponse() {
                    return self
                }
                if (other.hasAuthorization) {
                    try mergeAuthorization(value: other.authorization)
                }
                if (other.hasUserProfile) {
                    try mergeUserProfile(value: other.userProfile)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AuthorizationResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AuthorizationResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.Authorization.Builder = Present.Authorization.Builder()
                        if hasAuthorization {
                            try subBuilder.mergeFrom(other: authorization)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        authorization = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Present.UserProfile.Builder = Present.UserProfile.Builder()
                        if hasUserProfile {
                            try subBuilder.mergeFrom(other: userProfile)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        userProfile = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AuthorizationResponse.Builder {
                let resultDecodedBuilder = Present.AuthorizationResponse.Builder()
                if let jsonValueAuthorization = jsonMap["authorization"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.authorization = try Present.Authorization.Builder.decodeToBuilder(jsonMap:jsonValueAuthorization).build()

                }
                if let jsonValueUserProfile = jsonMap["userProfile"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.userProfile = try Present.UserProfile.Builder.decodeToBuilder(jsonMap:jsonValueUserProfile).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AuthorizationResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AuthorizationResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SynchronizeResponse : GeneratedMessage {

        public static func == (lhs: Present.SynchronizeResponse, rhs: Present.SynchronizeResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAuthorization == rhs.hasAuthorization) && (!lhs.hasAuthorization || lhs.authorization == rhs.authorization)
            fieldCheck = fieldCheck && (lhs.hasUserProfile == rhs.hasUserProfile) && (!lhs.hasUserProfile || lhs.userProfile == rhs.userProfile)
            fieldCheck = fieldCheck && (lhs.features == rhs.features)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var authorization:Present.Authorization!
        public fileprivate(set) var hasAuthorization:Bool = false
        public fileprivate(set) var userProfile:Present.UserProfile!
        public fileprivate(set) var hasUserProfile:Bool = false
        private var featuresMemoizedSerializedSize:Int32 = 0
        public fileprivate(set) var features:Array<Present.Feature> = Array<Present.Feature>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasAuthorization {
                return false
            }
            if !authorization.isInitialized() {
                return false
            }
            if hasUserProfile {
                if !userProfile.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAuthorization {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:authorization)
            }
            if hasUserProfile {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:userProfile)
            }
            for oneValueOffeatures in features {
                  try codedOutputStream.writeEnum(fieldNumber: 3, value:oneValueOffeatures.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAuthorization {
                if let varSizeauthorization = authorization?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeauthorization
                }
            }
            if hasUserProfile {
                if let varSizeuserProfile = userProfile?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeuserProfile
                }
            }
            var dataSizefeatures:Int32 = 0
            for oneValueOffeatures in features {
                dataSizefeatures += oneValueOffeatures.rawValue.computeEnumSizeNoTag()
            }
            serialize_size += dataSizefeatures
            serialize_size += (1 * Int32(features.count))
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.SynchronizeResponse.Builder {
            return Present.SynchronizeResponse.classBuilder() as! Present.SynchronizeResponse.Builder
        }
        public func getBuilder() -> Present.SynchronizeResponse.Builder {
            return classBuilder() as! Present.SynchronizeResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SynchronizeResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SynchronizeResponse.Builder()
        }
        public func toBuilder() throws -> Present.SynchronizeResponse.Builder {
            return try Present.SynchronizeResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.SynchronizeResponse) throws -> Present.SynchronizeResponse.Builder {
            return try Present.SynchronizeResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAuthorization {
                jsonMap["authorization"] = try authorization.encode()
            }
            if hasUserProfile {
                jsonMap["userProfile"] = try userProfile.encode()
            }
            if !features.isEmpty {
                var jsonArrayFeatures:Array<String> = []
                for oneValueFeatures in features {
                    jsonArrayFeatures.append(oneValueFeatures.toString())
                }
                jsonMap["features"] = jsonArrayFeatures
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.SynchronizeResponse {
            return try Present.SynchronizeResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.SynchronizeResponse {
            return try Present.SynchronizeResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAuthorization {
                output += "\(indent) authorization {\n"
                if let outDescAuthorization = authorization {
                    output += try outDescAuthorization.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasUserProfile {
                output += "\(indent) userProfile {\n"
                if let outDescUserProfile = userProfile {
                    output += try outDescUserProfile.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var featuresElementIndex:Int = 0
            for oneValueOffeatures in features {
                output += "\(indent) features[\(featuresElementIndex)]: \(oneValueOffeatures.description)\n"
                featuresElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAuthorization {
                    if let hashValueauthorization = authorization?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueauthorization
                    }
                }
                if hasUserProfile {
                    if let hashValueuserProfile = userProfile?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuserProfile
                    }
                }
                for oneValueOffeatures in features {
                    hashCode = (hashCode &* 31) &+ oneValueOffeatures.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.SynchronizeResponse"
        }
        override public func className() -> String {
            return "Present.SynchronizeResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.SynchronizeResponse = Present.SynchronizeResponse()
            public func getMessage() -> Present.SynchronizeResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var authorization:Present.Authorization! {
                get {
                    if authorizationBuilder_ != nil {
                        builderResult.authorization = authorizationBuilder_.getMessage()
                    }
                    return builderResult.authorization
                }
                set (value) {
                    builderResult.hasAuthorization = true
                    builderResult.authorization = value
                }
            }
            public var hasAuthorization:Bool {
                get {
                    return builderResult.hasAuthorization
                }
            }
            fileprivate var authorizationBuilder_:Present.Authorization.Builder! {
                didSet {
                    builderResult.hasAuthorization = true
                }
            }
            public func getAuthorizationBuilder() -> Present.Authorization.Builder {
                if authorizationBuilder_ == nil {
                    authorizationBuilder_ = Present.Authorization.Builder()
                    builderResult.authorization = authorizationBuilder_.getMessage()
                    if authorization != nil {
                        try! authorizationBuilder_.mergeFrom(other: authorization)
                    }
                }
                return authorizationBuilder_
            }
            @discardableResult
            public func setAuthorization(_ value:Present.Authorization!) -> Present.SynchronizeResponse.Builder {
                self.authorization = value
                return self
            }
            @discardableResult
            public func mergeAuthorization(value:Present.Authorization) throws -> Present.SynchronizeResponse.Builder {
                if builderResult.hasAuthorization {
                    builderResult.authorization = try Present.Authorization.builderWithPrototype(prototype:builderResult.authorization).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.authorization = value
                }
                builderResult.hasAuthorization = true
                return self
            }
            @discardableResult
            public func clearAuthorization() -> Present.SynchronizeResponse.Builder {
                authorizationBuilder_ = nil
                builderResult.hasAuthorization = false
                builderResult.authorization = nil
                return self
            }
            /// The user's current profile. Null if authorization.nextStep == AUTHENTICATE.
            public var userProfile:Present.UserProfile! {
                get {
                    if userProfileBuilder_ != nil {
                        builderResult.userProfile = userProfileBuilder_.getMessage()
                    }
                    return builderResult.userProfile
                }
                set (value) {
                    builderResult.hasUserProfile = true
                    builderResult.userProfile = value
                }
            }
            public var hasUserProfile:Bool {
                get {
                    return builderResult.hasUserProfile
                }
            }
            fileprivate var userProfileBuilder_:Present.UserProfile.Builder! {
                didSet {
                    builderResult.hasUserProfile = true
                }
            }
            public func getUserProfileBuilder() -> Present.UserProfile.Builder {
                if userProfileBuilder_ == nil {
                    userProfileBuilder_ = Present.UserProfile.Builder()
                    builderResult.userProfile = userProfileBuilder_.getMessage()
                    if userProfile != nil {
                        try! userProfileBuilder_.mergeFrom(other: userProfile)
                    }
                }
                return userProfileBuilder_
            }
            @discardableResult
            public func setUserProfile(_ value:Present.UserProfile!) -> Present.SynchronizeResponse.Builder {
                self.userProfile = value
                return self
            }
            @discardableResult
            public func mergeUserProfile(value:Present.UserProfile) throws -> Present.SynchronizeResponse.Builder {
                if builderResult.hasUserProfile {
                    builderResult.userProfile = try Present.UserProfile.builderWithPrototype(prototype:builderResult.userProfile).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.userProfile = value
                }
                builderResult.hasUserProfile = true
                return self
            }
            @discardableResult
            public func clearUserProfile() -> Present.SynchronizeResponse.Builder {
                userProfileBuilder_ = nil
                builderResult.hasUserProfile = false
                builderResult.userProfile = nil
                return self
            }
            /// Feature flags.
            public var features:Array<Present.Feature> {
                get {
                    return builderResult.features
                }
                set (value) {
                    builderResult.features = value
                }
            }
            @discardableResult
            public func setFeatures(_ value:Array<Present.Feature>) -> Present.SynchronizeResponse.Builder {
                self.features = value
                return self
            }
            @discardableResult
            public func clearFeatures() -> Present.SynchronizeResponse.Builder {
                builderResult.features.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.SynchronizeResponse.Builder {
                builderResult = Present.SynchronizeResponse()
                return self
            }
            override public func clone() throws -> Present.SynchronizeResponse.Builder {
                return try Present.SynchronizeResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.SynchronizeResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.SynchronizeResponse {
                let returnMe:Present.SynchronizeResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.SynchronizeResponse) throws -> Present.SynchronizeResponse.Builder {
                if other == Present.SynchronizeResponse() {
                    return self
                }
                if (other.hasAuthorization) {
                    try mergeAuthorization(value: other.authorization)
                }
                if (other.hasUserProfile) {
                    try mergeUserProfile(value: other.userProfile)
                }
                if !other.features.isEmpty {
                     builderResult.features += other.features
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.SynchronizeResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SynchronizeResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.Authorization.Builder = Present.Authorization.Builder()
                        if hasAuthorization {
                            try subBuilder.mergeFrom(other: authorization)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        authorization = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Present.UserProfile.Builder = Present.UserProfile.Builder()
                        if hasUserProfile {
                            try subBuilder.mergeFrom(other: userProfile)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        userProfile = subBuilder.buildPartial()

                    case 24:
                        let valueIntfeatures = try codedInputStream.readEnum()
                        if let enumsfeatures = Present.Feature(rawValue:valueIntfeatures) {
                            builderResult.features.append(enumsfeatures)
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntfeatures))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.SynchronizeResponse.Builder {
                let resultDecodedBuilder = Present.SynchronizeResponse.Builder()
                if let jsonValueAuthorization = jsonMap["authorization"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.authorization = try Present.Authorization.Builder.decodeToBuilder(jsonMap:jsonValueAuthorization).build()

                }
                if let jsonValueUserProfile = jsonMap["userProfile"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.userProfile = try Present.UserProfile.Builder.decodeToBuilder(jsonMap:jsonValueUserProfile).build()

                }
                if let jsonValueFeatures = jsonMap["features"] as? Array<String> {
                    var jsonArrayFeatures:Array<Present.Feature> = []
                    for oneValueFeatures in jsonValueFeatures {
                        let enumFromStringFeatures = try Present.Feature.fromString(str: oneValueFeatures)
                        jsonArrayFeatures.append(enumFromStringFeatures)
                    }
                    resultDecodedBuilder.features = jsonArrayFeatures
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.SynchronizeResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.SynchronizeResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Public information about a user
    final public class UserResponse : GeneratedMessage {

        public static func == (lhs: Present.UserResponse, rhs: Present.UserResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasPhoto == rhs.hasPhoto) && (!lhs.hasPhoto || lhs.photo == rhs.photo)
            fieldCheck = fieldCheck && (lhs.hasBio == rhs.hasBio) && (!lhs.hasBio || lhs.bio == rhs.bio)
            fieldCheck = fieldCheck && (lhs.interests == rhs.interests)
            fieldCheck = fieldCheck && (lhs.friends == rhs.friends)
            fieldCheck = fieldCheck && (lhs.hasFirstName == rhs.hasFirstName) && (!lhs.hasFirstName || lhs.firstName == rhs.firstName)
            fieldCheck = fieldCheck && (lhs.hasSignupLocation == rhs.hasSignupLocation) && (!lhs.hasSignupLocation || lhs.signupLocation == rhs.signupLocation)
            fieldCheck = fieldCheck && (lhs.hasLink == rhs.hasLink) && (!lhs.hasLink || lhs.link == rhs.link)
            fieldCheck = fieldCheck && (lhs.hasMember == rhs.hasMember) && (!lhs.hasMember || lhs.member == rhs.member)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// User ID
        public fileprivate(set) var id:String = ""
        public fileprivate(set) var hasId:Bool = false

        /// User's public name (Example: "Bob L.")
        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        /// First name by itself
        public fileprivate(set) var firstName:String = ""
        public fileprivate(set) var hasFirstName:Bool = false

        /// URL for author's JPEG photo
        public fileprivate(set) var photo:String = ""
        public fileprivate(set) var hasPhoto:Bool = false

        /// The user's short self description.
        /// Optional: This field may be excluded from bulk user responses. Retrieve with getUser().
        public fileprivate(set) var bio:String = ""
        public fileprivate(set) var hasBio:Bool = false

        /// The user's chosen interests.
        /// TODO: Describe the relationship of interests to circle categories (subset?)
        /// Optional: This field may be excluded from bulk user responses. Retrieve with getUser().
        public fileprivate(set) var interests:Array<String> = Array<String>()
        public fileprivate(set) var friends:Array<Present.FriendResponse>  = Array<Present.FriendResponse>()
        /// The user's signup location. Returned for admins only.
        public fileprivate(set) var signupLocation:String = ""
        public fileprivate(set) var hasSignupLocation:Bool = false

        /// An HTTPS link to this user.
        public fileprivate(set) var link:String = ""
        public fileprivate(set) var hasLink:Bool = false

        /// True if the user is a Present member.
        public fileprivate(set) var member:Bool = false
        public fileprivate(set) var hasMember:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasId {
                return false
            }
            if !hasPhoto {
                return false
            }
            if !hasLink {
                return false
            }
            if !hasMember {
                return false
            }
            var isInitFriends:Bool = true
            for oneElementFriends in friends {
                if !oneElementFriends.isInitialized() {
                    isInitFriends = false
                    break 
                }
            }
            if !isInitFriends {
                return isInitFriends
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasId {
                try codedOutputStream.writeString(fieldNumber: 1, value:id)
            }
            if hasName {
                try codedOutputStream.writeString(fieldNumber: 2, value:name)
            }
            if hasPhoto {
                try codedOutputStream.writeString(fieldNumber: 3, value:photo)
            }
            if hasBio {
                try codedOutputStream.writeString(fieldNumber: 4, value:bio)
            }
            if !interests.isEmpty {
                for oneValueinterests in interests {
                    try codedOutputStream.writeString(fieldNumber: 5, value:oneValueinterests)
                }
            }
            for oneElementFriends in friends {
                  try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementFriends)
            }
            if hasFirstName {
                try codedOutputStream.writeString(fieldNumber: 7, value:firstName)
            }
            if hasSignupLocation {
                try codedOutputStream.writeString(fieldNumber: 8, value:signupLocation)
            }
            if hasLink {
                try codedOutputStream.writeString(fieldNumber: 9, value:link)
            }
            if hasMember {
                try codedOutputStream.writeBool(fieldNumber: 10, value:member)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasId {
                serialize_size += id.computeStringSize(fieldNumber: 1)
            }
            if hasName {
                serialize_size += name.computeStringSize(fieldNumber: 2)
            }
            if hasPhoto {
                serialize_size += photo.computeStringSize(fieldNumber: 3)
            }
            if hasBio {
                serialize_size += bio.computeStringSize(fieldNumber: 4)
            }
            var dataSizeInterests:Int32 = 0
            for oneValueinterests in interests {
                dataSizeInterests += oneValueinterests.computeStringSizeNoTag()
            }
            serialize_size += dataSizeInterests
            serialize_size += 1 * Int32(interests.count)
            for oneElementFriends in friends {
                serialize_size += oneElementFriends.computeMessageSize(fieldNumber: 6)
            }
            if hasFirstName {
                serialize_size += firstName.computeStringSize(fieldNumber: 7)
            }
            if hasSignupLocation {
                serialize_size += signupLocation.computeStringSize(fieldNumber: 8)
            }
            if hasLink {
                serialize_size += link.computeStringSize(fieldNumber: 9)
            }
            if hasMember {
                serialize_size += member.computeBoolSize(fieldNumber: 10)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UserResponse.Builder {
            return Present.UserResponse.classBuilder() as! Present.UserResponse.Builder
        }
        public func getBuilder() -> Present.UserResponse.Builder {
            return classBuilder() as! Present.UserResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserResponse.Builder()
        }
        public func toBuilder() throws -> Present.UserResponse.Builder {
            return try Present.UserResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UserResponse) throws -> Present.UserResponse.Builder {
            return try Present.UserResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasId {
                jsonMap["id"] = id
            }
            if hasName {
                jsonMap["name"] = name
            }
            if hasFirstName {
                jsonMap["firstName"] = firstName
            }
            if hasPhoto {
                jsonMap["photo"] = photo
            }
            if hasBio {
                jsonMap["bio"] = bio
            }
            if !interests.isEmpty {
                var jsonArrayInterests:Array<String> = []
                for oneValueInterests in interests {
                    jsonArrayInterests.append(oneValueInterests)
                }
                jsonMap["interests"] = jsonArrayInterests
            }
            if !friends.isEmpty {
                var jsonArrayFriends:Array<Dictionary<String,Any>> = []
                for oneValueFriends in friends {
                    let ecodedMessageFriends = try oneValueFriends.encode()
                    jsonArrayFriends.append(ecodedMessageFriends)
                }
                jsonMap["friends"] = jsonArrayFriends
            }
            if hasSignupLocation {
                jsonMap["signupLocation"] = signupLocation
            }
            if hasLink {
                jsonMap["link"] = link
            }
            if hasMember {
                jsonMap["member"] = member
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UserResponse {
            return try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UserResponse {
            return try Present.UserResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasId {
                output += "\(indent) id: \(id) \n"
            }
            if hasName {
                output += "\(indent) name: \(name) \n"
            }
            if hasPhoto {
                output += "\(indent) photo: \(photo) \n"
            }
            if hasBio {
                output += "\(indent) bio: \(bio) \n"
            }
            var interestsElementIndex:Int = 0
            for oneValueInterests in interests  {
                output += "\(indent) interests[\(interestsElementIndex)]: \(oneValueInterests)\n"
                interestsElementIndex += 1
            }
            var friendsElementIndex:Int = 0
            for oneElementFriends in friends {
                output += "\(indent) friends[\(friendsElementIndex)] {\n"
                output += try oneElementFriends.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                friendsElementIndex += 1
            }
            if hasFirstName {
                output += "\(indent) firstName: \(firstName) \n"
            }
            if hasSignupLocation {
                output += "\(indent) signupLocation: \(signupLocation) \n"
            }
            if hasLink {
                output += "\(indent) link: \(link) \n"
            }
            if hasMember {
                output += "\(indent) member: \(member) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasId {
                    hashCode = (hashCode &* 31) &+ id.hashValue
                }
                if hasName {
                    hashCode = (hashCode &* 31) &+ name.hashValue
                }
                if hasPhoto {
                    hashCode = (hashCode &* 31) &+ photo.hashValue
                }
                if hasBio {
                    hashCode = (hashCode &* 31) &+ bio.hashValue
                }
                for oneValueInterests in interests {
                    hashCode = (hashCode &* 31) &+ oneValueInterests.hashValue
                }
                for oneElementFriends in friends {
                    hashCode = (hashCode &* 31) &+ oneElementFriends.hashValue
                }
                if hasFirstName {
                    hashCode = (hashCode &* 31) &+ firstName.hashValue
                }
                if hasSignupLocation {
                    hashCode = (hashCode &* 31) &+ signupLocation.hashValue
                }
                if hasLink {
                    hashCode = (hashCode &* 31) &+ link.hashValue
                }
                if hasMember {
                    hashCode = (hashCode &* 31) &+ member.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UserResponse"
        }
        override public func className() -> String {
            return "Present.UserResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UserResponse = Present.UserResponse()
            public func getMessage() -> Present.UserResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// User ID
            public var id:String {
                get {
                    return builderResult.id
                }
                set (value) {
                    builderResult.hasId = true
                    builderResult.id = value
                }
            }
            public var hasId:Bool {
                get {
                    return builderResult.hasId
                }
            }
            @discardableResult
            public func setId(_ value:String) -> Present.UserResponse.Builder {
                self.id = value
                return self
            }
            @discardableResult
            public func clearId() -> Present.UserResponse.Builder{
                builderResult.hasId = false
                builderResult.id = ""
                return self
            }
            /// User's public name (Example: "Bob L.")
            public var name:String {
                get {
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            @discardableResult
            public func setName(_ value:String) -> Present.UserResponse.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func clearName() -> Present.UserResponse.Builder{
                builderResult.hasName = false
                builderResult.name = ""
                return self
            }
            /// First name by itself
            public var firstName:String {
                get {
                    return builderResult.firstName
                }
                set (value) {
                    builderResult.hasFirstName = true
                    builderResult.firstName = value
                }
            }
            public var hasFirstName:Bool {
                get {
                    return builderResult.hasFirstName
                }
            }
            @discardableResult
            public func setFirstName(_ value:String) -> Present.UserResponse.Builder {
                self.firstName = value
                return self
            }
            @discardableResult
            public func clearFirstName() -> Present.UserResponse.Builder{
                builderResult.hasFirstName = false
                builderResult.firstName = ""
                return self
            }
            /// URL for author's JPEG photo
            public var photo:String {
                get {
                    return builderResult.photo
                }
                set (value) {
                    builderResult.hasPhoto = true
                    builderResult.photo = value
                }
            }
            public var hasPhoto:Bool {
                get {
                    return builderResult.hasPhoto
                }
            }
            @discardableResult
            public func setPhoto(_ value:String) -> Present.UserResponse.Builder {
                self.photo = value
                return self
            }
            @discardableResult
            public func clearPhoto() -> Present.UserResponse.Builder{
                builderResult.hasPhoto = false
                builderResult.photo = ""
                return self
            }
            /// The user's short self description.
            /// Optional: This field may be excluded from bulk user responses. Retrieve with getUser().
            public var bio:String {
                get {
                    return builderResult.bio
                }
                set (value) {
                    builderResult.hasBio = true
                    builderResult.bio = value
                }
            }
            public var hasBio:Bool {
                get {
                    return builderResult.hasBio
                }
            }
            @discardableResult
            public func setBio(_ value:String) -> Present.UserResponse.Builder {
                self.bio = value
                return self
            }
            @discardableResult
            public func clearBio() -> Present.UserResponse.Builder{
                builderResult.hasBio = false
                builderResult.bio = ""
                return self
            }
            /// The user's chosen interests.
            /// TODO: Describe the relationship of interests to circle categories (subset?)
            /// Optional: This field may be excluded from bulk user responses. Retrieve with getUser().
            public var interests:Array<String> {
                get {
                    return builderResult.interests
                }
                set (array) {
                    builderResult.interests = array
                }
            }
            @discardableResult
            public func setInterests(_ value:Array<String>) -> Present.UserResponse.Builder {
                self.interests = value
                return self
            }
            @discardableResult
            public func clearInterests() -> Present.UserResponse.Builder {
                builderResult.interests.removeAll(keepingCapacity: false)
                return self
            }
            /// Deprecated. Always empty. Use getFriends() instead.
            public var friends:Array<Present.FriendResponse> {
                get {
                    return builderResult.friends
                }
                set (value) {
                    builderResult.friends = value
                }
            }
            @discardableResult
            public func setFriends(_ value:Array<Present.FriendResponse>) -> Present.UserResponse.Builder {
                self.friends = value
                return self
            }
            @discardableResult
            public func clearFriends() -> Present.UserResponse.Builder {
                builderResult.friends.removeAll(keepingCapacity: false)
                return self
            }
            /// The user's signup location. Returned for admins only.
            public var signupLocation:String {
                get {
                    return builderResult.signupLocation
                }
                set (value) {
                    builderResult.hasSignupLocation = true
                    builderResult.signupLocation = value
                }
            }
            public var hasSignupLocation:Bool {
                get {
                    return builderResult.hasSignupLocation
                }
            }
            @discardableResult
            public func setSignupLocation(_ value:String) -> Present.UserResponse.Builder {
                self.signupLocation = value
                return self
            }
            @discardableResult
            public func clearSignupLocation() -> Present.UserResponse.Builder{
                builderResult.hasSignupLocation = false
                builderResult.signupLocation = ""
                return self
            }
            /// An HTTPS link to this user.
            public var link:String {
                get {
                    return builderResult.link
                }
                set (value) {
                    builderResult.hasLink = true
                    builderResult.link = value
                }
            }
            public var hasLink:Bool {
                get {
                    return builderResult.hasLink
                }
            }
            @discardableResult
            public func setLink(_ value:String) -> Present.UserResponse.Builder {
                self.link = value
                return self
            }
            @discardableResult
            public func clearLink() -> Present.UserResponse.Builder{
                builderResult.hasLink = false
                builderResult.link = ""
                return self
            }
            /// True if the user is a Present member.
            public var member:Bool {
                get {
                    return builderResult.member
                }
                set (value) {
                    builderResult.hasMember = true
                    builderResult.member = value
                }
            }
            public var hasMember:Bool {
                get {
                    return builderResult.hasMember
                }
            }
            @discardableResult
            public func setMember(_ value:Bool) -> Present.UserResponse.Builder {
                self.member = value
                return self
            }
            @discardableResult
            public func clearMember() -> Present.UserResponse.Builder{
                builderResult.hasMember = false
                builderResult.member = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UserResponse.Builder {
                builderResult = Present.UserResponse()
                return self
            }
            override public func clone() throws -> Present.UserResponse.Builder {
                return try Present.UserResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UserResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UserResponse {
                let returnMe:Present.UserResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UserResponse) throws -> Present.UserResponse.Builder {
                if other == Present.UserResponse() {
                    return self
                }
                if other.hasId {
                    id = other.id
                }
                if other.hasName {
                    name = other.name
                }
                if other.hasFirstName {
                    firstName = other.firstName
                }
                if other.hasPhoto {
                    photo = other.photo
                }
                if other.hasBio {
                    bio = other.bio
                }
                if !other.interests.isEmpty {
                    builderResult.interests += other.interests
                }
                if !other.friends.isEmpty  {
                     builderResult.friends += other.friends
                }
                if other.hasSignupLocation {
                    signupLocation = other.signupLocation
                }
                if other.hasLink {
                    link = other.link
                }
                if other.hasMember {
                    member = other.member
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UserResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        id = try codedInputStream.readString()

                    case 18:
                        name = try codedInputStream.readString()

                    case 26:
                        photo = try codedInputStream.readString()

                    case 34:
                        bio = try codedInputStream.readString()

                    case 42:
                        interests += [try codedInputStream.readString()]

                    case 50:
                        let subBuilder = Present.FriendResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        friends.append(subBuilder.buildPartial())

                    case 58:
                        firstName = try codedInputStream.readString()

                    case 66:
                        signupLocation = try codedInputStream.readString()

                    case 74:
                        link = try codedInputStream.readString()

                    case 80:
                        member = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UserResponse.Builder {
                let resultDecodedBuilder = Present.UserResponse.Builder()
                if let jsonValueId = jsonMap["id"] as? String {
                    resultDecodedBuilder.id = jsonValueId
                }
                if let jsonValueName = jsonMap["name"] as? String {
                    resultDecodedBuilder.name = jsonValueName
                }
                if let jsonValueFirstName = jsonMap["firstName"] as? String {
                    resultDecodedBuilder.firstName = jsonValueFirstName
                }
                if let jsonValuePhoto = jsonMap["photo"] as? String {
                    resultDecodedBuilder.photo = jsonValuePhoto
                }
                if let jsonValueBio = jsonMap["bio"] as? String {
                    resultDecodedBuilder.bio = jsonValueBio
                }
                if let jsonValueInterests = jsonMap["interests"] as? Array<String> {
                    var jsonArrayInterests:Array<String> = []
                    for oneValueInterests in jsonValueInterests {
                        jsonArrayInterests.append(oneValueInterests)
                    }
                    resultDecodedBuilder.interests = jsonArrayInterests
                }
                if let jsonValueFriends = jsonMap["friends"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayFriends:Array<Present.FriendResponse> = []
                    for oneValueFriends in jsonValueFriends {
                        let messageFromStringFriends = try Present.FriendResponse.Builder.decodeToBuilder(jsonMap:oneValueFriends).build()

                        jsonArrayFriends.append(messageFromStringFriends)
                    }
                    resultDecodedBuilder.friends = jsonArrayFriends
                }
                if let jsonValueSignupLocation = jsonMap["signupLocation"] as? String {
                    resultDecodedBuilder.signupLocation = jsonValueSignupLocation
                }
                if let jsonValueLink = jsonMap["link"] as? String {
                    resultDecodedBuilder.link = jsonValueLink
                }
                if let jsonValueMember = jsonMap["member"] as? Bool {
                    resultDecodedBuilder.member = jsonValueMember
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UserResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Deprecated.
    final public class FriendResponse : GeneratedMessage {

        public static func == (lhs: Present.FriendResponse, rhs: Present.FriendResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var user:Present.UserResponse!
        public fileprivate(set) var hasUser:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUser {
                return false
            }
            if !user.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUser {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:user)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUser {
                if let varSizeuser = user?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeuser
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.FriendResponse.Builder {
            return Present.FriendResponse.classBuilder() as! Present.FriendResponse.Builder
        }
        public func getBuilder() -> Present.FriendResponse.Builder {
            return classBuilder() as! Present.FriendResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FriendResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FriendResponse.Builder()
        }
        public func toBuilder() throws -> Present.FriendResponse.Builder {
            return try Present.FriendResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.FriendResponse) throws -> Present.FriendResponse.Builder {
            return try Present.FriendResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUser {
                jsonMap["user"] = try user.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.FriendResponse {
            return try Present.FriendResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.FriendResponse {
            return try Present.FriendResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUser {
                output += "\(indent) user {\n"
                if let outDescUser = user {
                    output += try outDescUser.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUser {
                    if let hashValueuser = user?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuser
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.FriendResponse"
        }
        override public func className() -> String {
            return "Present.FriendResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.FriendResponse = Present.FriendResponse()
            public func getMessage() -> Present.FriendResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var user:Present.UserResponse! {
                get {
                    if userBuilder_ != nil {
                        builderResult.user = userBuilder_.getMessage()
                    }
                    return builderResult.user
                }
                set (value) {
                    builderResult.hasUser = true
                    builderResult.user = value
                }
            }
            public var hasUser:Bool {
                get {
                    return builderResult.hasUser
                }
            }
            fileprivate var userBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasUser = true
                }
            }
            public func getUserBuilder() -> Present.UserResponse.Builder {
                if userBuilder_ == nil {
                    userBuilder_ = Present.UserResponse.Builder()
                    builderResult.user = userBuilder_.getMessage()
                    if user != nil {
                        try! userBuilder_.mergeFrom(other: user)
                    }
                }
                return userBuilder_
            }
            @discardableResult
            public func setUser(_ value:Present.UserResponse!) -> Present.FriendResponse.Builder {
                self.user = value
                return self
            }
            @discardableResult
            public func mergeUser(value:Present.UserResponse) throws -> Present.FriendResponse.Builder {
                if builderResult.hasUser {
                    builderResult.user = try Present.UserResponse.builderWithPrototype(prototype:builderResult.user).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.user = value
                }
                builderResult.hasUser = true
                return self
            }
            @discardableResult
            public func clearUser() -> Present.FriendResponse.Builder {
                userBuilder_ = nil
                builderResult.hasUser = false
                builderResult.user = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.FriendResponse.Builder {
                builderResult = Present.FriendResponse()
                return self
            }
            override public func clone() throws -> Present.FriendResponse.Builder {
                return try Present.FriendResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.FriendResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.FriendResponse {
                let returnMe:Present.FriendResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.FriendResponse) throws -> Present.FriendResponse.Builder {
                if other == Present.FriendResponse() {
                    return self
                }
                if (other.hasUser) {
                    try mergeUser(value: other.user)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.FriendResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FriendResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasUser {
                            try subBuilder.mergeFrom(other: user)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        user = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.FriendResponse.Builder {
                let resultDecodedBuilder = Present.FriendResponse.Builder()
                if let jsonValueUser = jsonMap["user"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.user = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueUser).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.FriendResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.FriendResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UsersResponse : GeneratedMessage {

        public static func == (lhs: Present.UsersResponse, rhs: Present.UsersResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.users == rhs.users)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var users:Array<Present.UserResponse>  = Array<Present.UserResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitUsers:Bool = true
            for oneElementUsers in users {
                if !oneElementUsers.isInitialized() {
                    isInitUsers = false
                    break 
                }
            }
            if !isInitUsers {
                return isInitUsers
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementUsers in users {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementUsers)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementUsers in users {
                serialize_size += oneElementUsers.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UsersResponse.Builder {
            return Present.UsersResponse.classBuilder() as! Present.UsersResponse.Builder
        }
        public func getBuilder() -> Present.UsersResponse.Builder {
            return classBuilder() as! Present.UsersResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UsersResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UsersResponse.Builder()
        }
        public func toBuilder() throws -> Present.UsersResponse.Builder {
            return try Present.UsersResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UsersResponse) throws -> Present.UsersResponse.Builder {
            return try Present.UsersResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !users.isEmpty {
                var jsonArrayUsers:Array<Dictionary<String,Any>> = []
                for oneValueUsers in users {
                    let ecodedMessageUsers = try oneValueUsers.encode()
                    jsonArrayUsers.append(ecodedMessageUsers)
                }
                jsonMap["users"] = jsonArrayUsers
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UsersResponse {
            return try Present.UsersResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UsersResponse {
            return try Present.UsersResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var usersElementIndex:Int = 0
            for oneElementUsers in users {
                output += "\(indent) users[\(usersElementIndex)] {\n"
                output += try oneElementUsers.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                usersElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementUsers in users {
                    hashCode = (hashCode &* 31) &+ oneElementUsers.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UsersResponse"
        }
        override public func className() -> String {
            return "Present.UsersResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UsersResponse = Present.UsersResponse()
            public func getMessage() -> Present.UsersResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var users:Array<Present.UserResponse> {
                get {
                    return builderResult.users
                }
                set (value) {
                    builderResult.users = value
                }
            }
            @discardableResult
            public func setUsers(_ value:Array<Present.UserResponse>) -> Present.UsersResponse.Builder {
                self.users = value
                return self
            }
            @discardableResult
            public func clearUsers() -> Present.UsersResponse.Builder {
                builderResult.users.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UsersResponse.Builder {
                builderResult = Present.UsersResponse()
                return self
            }
            override public func clone() throws -> Present.UsersResponse.Builder {
                return try Present.UsersResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UsersResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UsersResponse {
                let returnMe:Present.UsersResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UsersResponse) throws -> Present.UsersResponse.Builder {
                if other == Present.UsersResponse() {
                    return self
                }
                if !other.users.isEmpty  {
                     builderResult.users += other.users
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UsersResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UsersResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.UserResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        users.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UsersResponse.Builder {
                let resultDecodedBuilder = Present.UsersResponse.Builder()
                if let jsonValueUsers = jsonMap["users"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayUsers:Array<Present.UserResponse> = []
                    for oneValueUsers in jsonValueUsers {
                        let messageFromStringUsers = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:oneValueUsers).build()

                        jsonArrayUsers.append(messageFromStringUsers)
                    }
                    resultDecodedBuilder.users = jsonArrayUsers
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UsersResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UsersResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UserName : GeneratedMessage {

        public static func == (lhs: Present.UserName, rhs: Present.UserName) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFirst == rhs.hasFirst) && (!lhs.hasFirst || lhs.first == rhs.first)
            fieldCheck = fieldCheck && (lhs.hasLast == rhs.hasLast) && (!lhs.hasLast || lhs.last == rhs.last)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var first:String = ""
        public fileprivate(set) var hasFirst:Bool = false

        public fileprivate(set) var last:String = ""
        public fileprivate(set) var hasLast:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasFirst {
                return false
            }
            if !hasLast {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFirst {
                try codedOutputStream.writeString(fieldNumber: 1, value:first)
            }
            if hasLast {
                try codedOutputStream.writeString(fieldNumber: 2, value:last)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFirst {
                serialize_size += first.computeStringSize(fieldNumber: 1)
            }
            if hasLast {
                serialize_size += last.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UserName.Builder {
            return Present.UserName.classBuilder() as! Present.UserName.Builder
        }
        public func getBuilder() -> Present.UserName.Builder {
            return classBuilder() as! Present.UserName.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserName.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserName.Builder()
        }
        public func toBuilder() throws -> Present.UserName.Builder {
            return try Present.UserName.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UserName) throws -> Present.UserName.Builder {
            return try Present.UserName.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFirst {
                jsonMap["first"] = first
            }
            if hasLast {
                jsonMap["last"] = last
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UserName {
            return try Present.UserName.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UserName {
            return try Present.UserName.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFirst {
                output += "\(indent) first: \(first) \n"
            }
            if hasLast {
                output += "\(indent) last: \(last) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFirst {
                    hashCode = (hashCode &* 31) &+ first.hashValue
                }
                if hasLast {
                    hashCode = (hashCode &* 31) &+ last.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UserName"
        }
        override public func className() -> String {
            return "Present.UserName"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UserName = Present.UserName()
            public func getMessage() -> Present.UserName {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var first:String {
                get {
                    return builderResult.first
                }
                set (value) {
                    builderResult.hasFirst = true
                    builderResult.first = value
                }
            }
            public var hasFirst:Bool {
                get {
                    return builderResult.hasFirst
                }
            }
            @discardableResult
            public func setFirst(_ value:String) -> Present.UserName.Builder {
                self.first = value
                return self
            }
            @discardableResult
            public func clearFirst() -> Present.UserName.Builder{
                builderResult.hasFirst = false
                builderResult.first = ""
                return self
            }
            public var last:String {
                get {
                    return builderResult.last
                }
                set (value) {
                    builderResult.hasLast = true
                    builderResult.last = value
                }
            }
            public var hasLast:Bool {
                get {
                    return builderResult.hasLast
                }
            }
            @discardableResult
            public func setLast(_ value:String) -> Present.UserName.Builder {
                self.last = value
                return self
            }
            @discardableResult
            public func clearLast() -> Present.UserName.Builder{
                builderResult.hasLast = false
                builderResult.last = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UserName.Builder {
                builderResult = Present.UserName()
                return self
            }
            override public func clone() throws -> Present.UserName.Builder {
                return try Present.UserName.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UserName {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UserName {
                let returnMe:Present.UserName = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UserName) throws -> Present.UserName.Builder {
                if other == Present.UserName() {
                    return self
                }
                if other.hasFirst {
                    first = other.first
                }
                if other.hasLast {
                    last = other.last
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UserName.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserName.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        first = try codedInputStream.readString()

                    case 18:
                        last = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UserName.Builder {
                let resultDecodedBuilder = Present.UserName.Builder()
                if let jsonValueFirst = jsonMap["first"] as? String {
                    resultDecodedBuilder.first = jsonValueFirst
                }
                if let jsonValueLast = jsonMap["last"] as? String {
                    resultDecodedBuilder.last = jsonValueLast
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UserName.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UserName.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Specify which types of system activity generate notifications for the user.
    /// Settings naming convention: "When a(n)..."
    ///   actor-action
    ///   actor-action-"On"-target
    ///   qualifier-actor-qualifier-action-"On"-qualifier-target
    final public class UserNotificationSettings : GeneratedMessage {

        public static func == (lhs: Present.UserNotificationSettings, rhs: Present.UserNotificationSettings) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDeprecatedOwnedGroups == rhs.hasDeprecatedOwnedGroups) && (!lhs.hasDeprecatedOwnedGroups || lhs.deprecatedOwnedGroups == rhs.deprecatedOwnedGroups)
            fieldCheck = fieldCheck && (lhs.hasDeprecatedFavoritedGroups == rhs.hasDeprecatedFavoritedGroups) && (!lhs.hasDeprecatedFavoritedGroups || lhs.deprecatedFavoritedGroups == rhs.deprecatedFavoritedGroups)
            fieldCheck = fieldCheck && (lhs.hasDeprecatedContributedGroups == rhs.hasDeprecatedContributedGroups) && (!lhs.hasDeprecatedContributedGroups || lhs.deprecatedContributedGroups == rhs.deprecatedContributedGroups)
            fieldCheck = fieldCheck && (lhs.hasUserCommentsOnJoinedGroup == rhs.hasUserCommentsOnJoinedGroup) && (!lhs.hasUserCommentsOnJoinedGroup || lhs.userCommentsOnJoinedGroup == rhs.userCommentsOnJoinedGroup)
            fieldCheck = fieldCheck && (lhs.hasUserJoinsOwnedGroup == rhs.hasUserJoinsOwnedGroup) && (!lhs.hasUserJoinsOwnedGroup || lhs.userJoinsOwnedGroup == rhs.userJoinsOwnedGroup)
            fieldCheck = fieldCheck && (lhs.hasAffirmations == rhs.hasAffirmations) && (!lhs.hasAffirmations || lhs.affirmations == rhs.affirmations)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Unsupported:
        /// Last shipped with client version iOS v0.1.1.
        /// Notify for groups the user has created
        public fileprivate(set) var deprecatedOwnedGroups:Bool = false
        public fileprivate(set) var hasDeprecatedOwnedGroups:Bool = false

        /// Deprecated: This field is mapped to userCommentsOnJoinedGroup.
        /// Last shipped: client version iOS v0.1.1.
        /// Notify for groups the user has favorited
        public fileprivate(set) var deprecatedFavoritedGroups:Bool = false
        public fileprivate(set) var hasDeprecatedFavoritedGroups:Bool = false

        /// Unsupported:
        /// Last shipped with client version iOS v0.1.1.
        /// Notify for groups to which the user has posted content
        public fileprivate(set) var deprecatedContributedGroups:Bool = false
        public fileprivate(set) var hasDeprecatedContributedGroups:Bool = false

        /// Another user comments on a group I have joined.
        public fileprivate(set) var userCommentsOnJoinedGroup:Bool = false
        public fileprivate(set) var hasUserCommentsOnJoinedGroup:Bool = false

        /// Another user joins a group that I own.
        public fileprivate(set) var userJoinsOwnedGroup:Bool = false
        public fileprivate(set) var hasUserJoinsOwnedGroup:Bool = false

        /// Positive affirmations from Present
        public fileprivate(set) var affirmations:Bool = false
        public fileprivate(set) var hasAffirmations:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDeprecatedOwnedGroups {
                try codedOutputStream.writeBool(fieldNumber: 1, value:deprecatedOwnedGroups)
            }
            if hasDeprecatedFavoritedGroups {
                try codedOutputStream.writeBool(fieldNumber: 2, value:deprecatedFavoritedGroups)
            }
            if hasDeprecatedContributedGroups {
                try codedOutputStream.writeBool(fieldNumber: 3, value:deprecatedContributedGroups)
            }
            if hasUserCommentsOnJoinedGroup {
                try codedOutputStream.writeBool(fieldNumber: 4, value:userCommentsOnJoinedGroup)
            }
            if hasUserJoinsOwnedGroup {
                try codedOutputStream.writeBool(fieldNumber: 5, value:userJoinsOwnedGroup)
            }
            if hasAffirmations {
                try codedOutputStream.writeBool(fieldNumber: 6, value:affirmations)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDeprecatedOwnedGroups {
                serialize_size += deprecatedOwnedGroups.computeBoolSize(fieldNumber: 1)
            }
            if hasDeprecatedFavoritedGroups {
                serialize_size += deprecatedFavoritedGroups.computeBoolSize(fieldNumber: 2)
            }
            if hasDeprecatedContributedGroups {
                serialize_size += deprecatedContributedGroups.computeBoolSize(fieldNumber: 3)
            }
            if hasUserCommentsOnJoinedGroup {
                serialize_size += userCommentsOnJoinedGroup.computeBoolSize(fieldNumber: 4)
            }
            if hasUserJoinsOwnedGroup {
                serialize_size += userJoinsOwnedGroup.computeBoolSize(fieldNumber: 5)
            }
            if hasAffirmations {
                serialize_size += affirmations.computeBoolSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UserNotificationSettings.Builder {
            return Present.UserNotificationSettings.classBuilder() as! Present.UserNotificationSettings.Builder
        }
        public func getBuilder() -> Present.UserNotificationSettings.Builder {
            return classBuilder() as! Present.UserNotificationSettings.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserNotificationSettings.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserNotificationSettings.Builder()
        }
        public func toBuilder() throws -> Present.UserNotificationSettings.Builder {
            return try Present.UserNotificationSettings.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UserNotificationSettings) throws -> Present.UserNotificationSettings.Builder {
            return try Present.UserNotificationSettings.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDeprecatedOwnedGroups {
                jsonMap["deprecatedOwnedGroups"] = deprecatedOwnedGroups
            }
            if hasDeprecatedFavoritedGroups {
                jsonMap["deprecatedFavoritedGroups"] = deprecatedFavoritedGroups
            }
            if hasDeprecatedContributedGroups {
                jsonMap["deprecatedContributedGroups"] = deprecatedContributedGroups
            }
            if hasUserCommentsOnJoinedGroup {
                jsonMap["userCommentsOnJoinedGroup"] = userCommentsOnJoinedGroup
            }
            if hasUserJoinsOwnedGroup {
                jsonMap["userJoinsOwnedGroup"] = userJoinsOwnedGroup
            }
            if hasAffirmations {
                jsonMap["affirmations"] = affirmations
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UserNotificationSettings {
            return try Present.UserNotificationSettings.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UserNotificationSettings {
            return try Present.UserNotificationSettings.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDeprecatedOwnedGroups {
                output += "\(indent) deprecatedOwnedGroups: \(deprecatedOwnedGroups) \n"
            }
            if hasDeprecatedFavoritedGroups {
                output += "\(indent) deprecatedFavoritedGroups: \(deprecatedFavoritedGroups) \n"
            }
            if hasDeprecatedContributedGroups {
                output += "\(indent) deprecatedContributedGroups: \(deprecatedContributedGroups) \n"
            }
            if hasUserCommentsOnJoinedGroup {
                output += "\(indent) userCommentsOnJoinedGroup: \(userCommentsOnJoinedGroup) \n"
            }
            if hasUserJoinsOwnedGroup {
                output += "\(indent) userJoinsOwnedGroup: \(userJoinsOwnedGroup) \n"
            }
            if hasAffirmations {
                output += "\(indent) affirmations: \(affirmations) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDeprecatedOwnedGroups {
                    hashCode = (hashCode &* 31) &+ deprecatedOwnedGroups.hashValue
                }
                if hasDeprecatedFavoritedGroups {
                    hashCode = (hashCode &* 31) &+ deprecatedFavoritedGroups.hashValue
                }
                if hasDeprecatedContributedGroups {
                    hashCode = (hashCode &* 31) &+ deprecatedContributedGroups.hashValue
                }
                if hasUserCommentsOnJoinedGroup {
                    hashCode = (hashCode &* 31) &+ userCommentsOnJoinedGroup.hashValue
                }
                if hasUserJoinsOwnedGroup {
                    hashCode = (hashCode &* 31) &+ userJoinsOwnedGroup.hashValue
                }
                if hasAffirmations {
                    hashCode = (hashCode &* 31) &+ affirmations.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UserNotificationSettings"
        }
        override public func className() -> String {
            return "Present.UserNotificationSettings"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UserNotificationSettings = Present.UserNotificationSettings()
            public func getMessage() -> Present.UserNotificationSettings {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Unsupported:
            /// Last shipped with client version iOS v0.1.1.
            /// Notify for groups the user has created
            public var deprecatedOwnedGroups:Bool {
                get {
                    return builderResult.deprecatedOwnedGroups
                }
                set (value) {
                    builderResult.hasDeprecatedOwnedGroups = true
                    builderResult.deprecatedOwnedGroups = value
                }
            }
            public var hasDeprecatedOwnedGroups:Bool {
                get {
                    return builderResult.hasDeprecatedOwnedGroups
                }
            }
            @discardableResult
            public func setDeprecatedOwnedGroups(_ value:Bool) -> Present.UserNotificationSettings.Builder {
                self.deprecatedOwnedGroups = value
                return self
            }
            @discardableResult
            public func clearDeprecatedOwnedGroups() -> Present.UserNotificationSettings.Builder{
                builderResult.hasDeprecatedOwnedGroups = false
                builderResult.deprecatedOwnedGroups = false
                return self
            }
            /// Deprecated: This field is mapped to userCommentsOnJoinedGroup.
            /// Last shipped: client version iOS v0.1.1.
            /// Notify for groups the user has favorited
            public var deprecatedFavoritedGroups:Bool {
                get {
                    return builderResult.deprecatedFavoritedGroups
                }
                set (value) {
                    builderResult.hasDeprecatedFavoritedGroups = true
                    builderResult.deprecatedFavoritedGroups = value
                }
            }
            public var hasDeprecatedFavoritedGroups:Bool {
                get {
                    return builderResult.hasDeprecatedFavoritedGroups
                }
            }
            @discardableResult
            public func setDeprecatedFavoritedGroups(_ value:Bool) -> Present.UserNotificationSettings.Builder {
                self.deprecatedFavoritedGroups = value
                return self
            }
            @discardableResult
            public func clearDeprecatedFavoritedGroups() -> Present.UserNotificationSettings.Builder{
                builderResult.hasDeprecatedFavoritedGroups = false
                builderResult.deprecatedFavoritedGroups = false
                return self
            }
            /// Unsupported:
            /// Last shipped with client version iOS v0.1.1.
            /// Notify for groups to which the user has posted content
            public var deprecatedContributedGroups:Bool {
                get {
                    return builderResult.deprecatedContributedGroups
                }
                set (value) {
                    builderResult.hasDeprecatedContributedGroups = true
                    builderResult.deprecatedContributedGroups = value
                }
            }
            public var hasDeprecatedContributedGroups:Bool {
                get {
                    return builderResult.hasDeprecatedContributedGroups
                }
            }
            @discardableResult
            public func setDeprecatedContributedGroups(_ value:Bool) -> Present.UserNotificationSettings.Builder {
                self.deprecatedContributedGroups = value
                return self
            }
            @discardableResult
            public func clearDeprecatedContributedGroups() -> Present.UserNotificationSettings.Builder{
                builderResult.hasDeprecatedContributedGroups = false
                builderResult.deprecatedContributedGroups = false
                return self
            }
            /// Another user comments on a group I have joined.
            public var userCommentsOnJoinedGroup:Bool {
                get {
                    return builderResult.userCommentsOnJoinedGroup
                }
                set (value) {
                    builderResult.hasUserCommentsOnJoinedGroup = true
                    builderResult.userCommentsOnJoinedGroup = value
                }
            }
            public var hasUserCommentsOnJoinedGroup:Bool {
                get {
                    return builderResult.hasUserCommentsOnJoinedGroup
                }
            }
            @discardableResult
            public func setUserCommentsOnJoinedGroup(_ value:Bool) -> Present.UserNotificationSettings.Builder {
                self.userCommentsOnJoinedGroup = value
                return self
            }
            @discardableResult
            public func clearUserCommentsOnJoinedGroup() -> Present.UserNotificationSettings.Builder{
                builderResult.hasUserCommentsOnJoinedGroup = false
                builderResult.userCommentsOnJoinedGroup = false
                return self
            }
            /// Another user joins a group that I own.
            public var userJoinsOwnedGroup:Bool {
                get {
                    return builderResult.userJoinsOwnedGroup
                }
                set (value) {
                    builderResult.hasUserJoinsOwnedGroup = true
                    builderResult.userJoinsOwnedGroup = value
                }
            }
            public var hasUserJoinsOwnedGroup:Bool {
                get {
                    return builderResult.hasUserJoinsOwnedGroup
                }
            }
            @discardableResult
            public func setUserJoinsOwnedGroup(_ value:Bool) -> Present.UserNotificationSettings.Builder {
                self.userJoinsOwnedGroup = value
                return self
            }
            @discardableResult
            public func clearUserJoinsOwnedGroup() -> Present.UserNotificationSettings.Builder{
                builderResult.hasUserJoinsOwnedGroup = false
                builderResult.userJoinsOwnedGroup = false
                return self
            }
            /// Positive affirmations from Present
            public var affirmations:Bool {
                get {
                    return builderResult.affirmations
                }
                set (value) {
                    builderResult.hasAffirmations = true
                    builderResult.affirmations = value
                }
            }
            public var hasAffirmations:Bool {
                get {
                    return builderResult.hasAffirmations
                }
            }
            @discardableResult
            public func setAffirmations(_ value:Bool) -> Present.UserNotificationSettings.Builder {
                self.affirmations = value
                return self
            }
            @discardableResult
            public func clearAffirmations() -> Present.UserNotificationSettings.Builder{
                builderResult.hasAffirmations = false
                builderResult.affirmations = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UserNotificationSettings.Builder {
                builderResult = Present.UserNotificationSettings()
                return self
            }
            override public func clone() throws -> Present.UserNotificationSettings.Builder {
                return try Present.UserNotificationSettings.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UserNotificationSettings {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UserNotificationSettings {
                let returnMe:Present.UserNotificationSettings = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UserNotificationSettings) throws -> Present.UserNotificationSettings.Builder {
                if other == Present.UserNotificationSettings() {
                    return self
                }
                if other.hasDeprecatedOwnedGroups {
                    deprecatedOwnedGroups = other.deprecatedOwnedGroups
                }
                if other.hasDeprecatedFavoritedGroups {
                    deprecatedFavoritedGroups = other.deprecatedFavoritedGroups
                }
                if other.hasDeprecatedContributedGroups {
                    deprecatedContributedGroups = other.deprecatedContributedGroups
                }
                if other.hasUserCommentsOnJoinedGroup {
                    userCommentsOnJoinedGroup = other.userCommentsOnJoinedGroup
                }
                if other.hasUserJoinsOwnedGroup {
                    userJoinsOwnedGroup = other.userJoinsOwnedGroup
                }
                if other.hasAffirmations {
                    affirmations = other.affirmations
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UserNotificationSettings.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserNotificationSettings.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        deprecatedOwnedGroups = try codedInputStream.readBool()

                    case 16:
                        deprecatedFavoritedGroups = try codedInputStream.readBool()

                    case 24:
                        deprecatedContributedGroups = try codedInputStream.readBool()

                    case 32:
                        userCommentsOnJoinedGroup = try codedInputStream.readBool()

                    case 40:
                        userJoinsOwnedGroup = try codedInputStream.readBool()

                    case 48:
                        affirmations = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UserNotificationSettings.Builder {
                let resultDecodedBuilder = Present.UserNotificationSettings.Builder()
                if let jsonValueDeprecatedOwnedGroups = jsonMap["deprecatedOwnedGroups"] as? Bool {
                    resultDecodedBuilder.deprecatedOwnedGroups = jsonValueDeprecatedOwnedGroups
                }
                if let jsonValueDeprecatedFavoritedGroups = jsonMap["deprecatedFavoritedGroups"] as? Bool {
                    resultDecodedBuilder.deprecatedFavoritedGroups = jsonValueDeprecatedFavoritedGroups
                }
                if let jsonValueDeprecatedContributedGroups = jsonMap["deprecatedContributedGroups"] as? Bool {
                    resultDecodedBuilder.deprecatedContributedGroups = jsonValueDeprecatedContributedGroups
                }
                if let jsonValueUserCommentsOnJoinedGroup = jsonMap["userCommentsOnJoinedGroup"] as? Bool {
                    resultDecodedBuilder.userCommentsOnJoinedGroup = jsonValueUserCommentsOnJoinedGroup
                }
                if let jsonValueUserJoinsOwnedGroup = jsonMap["userJoinsOwnedGroup"] as? Bool {
                    resultDecodedBuilder.userJoinsOwnedGroup = jsonValueUserJoinsOwnedGroup
                }
                if let jsonValueAffirmations = jsonMap["affirmations"] as? Bool {
                    resultDecodedBuilder.affirmations = jsonValueAffirmations
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UserNotificationSettings.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UserNotificationSettings.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// The UserProfile is the user's private view of their profile data.
    /// It includes all of the public fields as well as private settings.
    /// Note: We could compose a UserResponse inside for the common parts of both, but let's see how
    ///   this evolves first.
    final public class UserProfile : GeneratedMessage {

        public static func == (lhs: Present.UserProfile, rhs: Present.UserProfile) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasPhoto == rhs.hasPhoto) && (!lhs.hasPhoto || lhs.photo == rhs.photo)
            fieldCheck = fieldCheck && (lhs.hasNotificationSettings == rhs.hasNotificationSettings) && (!lhs.hasNotificationSettings || lhs.notificationSettings == rhs.notificationSettings)
            fieldCheck = fieldCheck && (lhs.hasBio == rhs.hasBio) && (!lhs.hasBio || lhs.bio == rhs.bio)
            fieldCheck = fieldCheck && (lhs.interests == rhs.interests)
            fieldCheck = fieldCheck && (lhs.friends == rhs.friends)
            fieldCheck = fieldCheck && (lhs.hasIsAdmin == rhs.hasIsAdmin) && (!lhs.hasIsAdmin || lhs.isAdmin == rhs.isAdmin)
            fieldCheck = fieldCheck && (lhs.hasAppShareLink == rhs.hasAppShareLink) && (!lhs.hasAppShareLink || lhs.appShareLink == rhs.appShareLink)
            fieldCheck = fieldCheck && (lhs.hasHome == rhs.hasHome) && (!lhs.hasHome || lhs.home == rhs.home)
            fieldCheck = fieldCheck && (lhs.hasLink == rhs.hasLink) && (!lhs.hasLink || lhs.link == rhs.link)
            fieldCheck = fieldCheck && (lhs.hasGender == rhs.hasGender) && (!lhs.hasGender || lhs.gender == rhs.gender)
            fieldCheck = fieldCheck && (lhs.hasFacebookLinked == rhs.hasFacebookLinked) && (!lhs.hasFacebookLinked || lhs.facebookLinked == rhs.facebookLinked)
            fieldCheck = fieldCheck && (lhs.hasPhoneVerified == rhs.hasPhoneVerified) && (!lhs.hasPhoneVerified || lhs.phoneVerified == rhs.phoneVerified)
            fieldCheck = fieldCheck && (lhs.hasIncomingFriendRequests == rhs.hasIncomingFriendRequests) && (!lhs.hasIncomingFriendRequests || lhs.incomingFriendRequests == rhs.incomingFriendRequests)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// User ID
        public fileprivate(set) var id:String = ""
        public fileprivate(set) var hasId:Bool = false

        public fileprivate(set) var name:Present.UserName!
        public fileprivate(set) var hasName:Bool = false
        /// URL for user's JPEG photo. Can be null if the client has not uploaded a photo.
        public fileprivate(set) var photo:String = ""
        public fileprivate(set) var hasPhoto:Bool = false

        /// The user's short self description.
        public fileprivate(set) var bio:String = ""
        public fileprivate(set) var hasBio:Bool = false

        /// The user's chosen interests.
        /// TODO: Describe the relationship of interests to circle categories (subset?)
        public fileprivate(set) var interests:Array<String> = Array<String>()
        public fileprivate(set) var friends:Array<Present.FriendResponse>  = Array<Present.FriendResponse>()
        public fileprivate(set) var notificationSettings:Present.UserNotificationSettings!
        public fileprivate(set) var hasNotificationSettings:Bool = false
        /// If true this user is a Present administrator.  Administrators may edit content owned by others.
        public fileprivate(set) var isAdmin:Bool = false
        public fileprivate(set) var hasIsAdmin:Bool = false

        /// Link used to share the app with other users. Embeds referrer information.
        public fileprivate(set) var appShareLink:String = ""
        public fileprivate(set) var hasAppShareLink:Bool = false

        public fileprivate(set) var home:Present.City!
        public fileprivate(set) var hasHome:Bool = false
        /// An HTTPS link to this user.
        public fileprivate(set) var link:String = ""
        public fileprivate(set) var hasLink:Bool = false

        public fileprivate(set) var gender:Present.Gender = Present.Gender.unknownGender
        public fileprivate(set) var hasGender:Bool = false
        /// True if the user has a Facebook account linked.
        public fileprivate(set) var facebookLinked:Bool = false
        public fileprivate(set) var hasFacebookLinked:Bool = false

        /// True if the user has verified a phone number.
        public fileprivate(set) var phoneVerified:Bool = false
        public fileprivate(set) var hasPhoneVerified:Bool = false

        /// Number of open friend requests.
        public fileprivate(set) var incomingFriendRequests:UInt32 = UInt32(0)
        public fileprivate(set) var hasIncomingFriendRequests:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasId {
                return false
            }
            if !hasAppShareLink {
                return false
            }
            if !hasLink {
                return false
            }
            if hasName {
                if !name.isInitialized() {
                    return false
                }
            }
            var isInitFriends:Bool = true
            for oneElementFriends in friends {
                if !oneElementFriends.isInitialized() {
                    isInitFriends = false
                    break 
                }
            }
            if !isInitFriends {
                return isInitFriends
            }
            if hasHome {
                if !home.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasId {
                try codedOutputStream.writeString(fieldNumber: 1, value:id)
            }
            if hasName {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:name)
            }
            if hasPhoto {
                try codedOutputStream.writeString(fieldNumber: 3, value:photo)
            }
            if hasNotificationSettings {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:notificationSettings)
            }
            if hasBio {
                try codedOutputStream.writeString(fieldNumber: 5, value:bio)
            }
            if !interests.isEmpty {
                for oneValueinterests in interests {
                    try codedOutputStream.writeString(fieldNumber: 6, value:oneValueinterests)
                }
            }
            for oneElementFriends in friends {
                  try codedOutputStream.writeMessage(fieldNumber: 7, value:oneElementFriends)
            }
            if hasIsAdmin {
                try codedOutputStream.writeBool(fieldNumber: 8, value:isAdmin)
            }
            if hasAppShareLink {
                try codedOutputStream.writeString(fieldNumber: 9, value:appShareLink)
            }
            if hasHome {
                try codedOutputStream.writeMessage(fieldNumber: 10, value:home)
            }
            if hasLink {
                try codedOutputStream.writeString(fieldNumber: 11, value:link)
            }
            if hasGender {
                try codedOutputStream.writeEnum(fieldNumber: 12, value:gender.rawValue)
            }
            if hasFacebookLinked {
                try codedOutputStream.writeBool(fieldNumber: 13, value:facebookLinked)
            }
            if hasPhoneVerified {
                try codedOutputStream.writeBool(fieldNumber: 14, value:phoneVerified)
            }
            if hasIncomingFriendRequests {
                try codedOutputStream.writeUInt32(fieldNumber: 15, value:incomingFriendRequests)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasId {
                serialize_size += id.computeStringSize(fieldNumber: 1)
            }
            if hasName {
                if let varSizename = name?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizename
                }
            }
            if hasPhoto {
                serialize_size += photo.computeStringSize(fieldNumber: 3)
            }
            if hasNotificationSettings {
                if let varSizenotificationSettings = notificationSettings?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizenotificationSettings
                }
            }
            if hasBio {
                serialize_size += bio.computeStringSize(fieldNumber: 5)
            }
            var dataSizeInterests:Int32 = 0
            for oneValueinterests in interests {
                dataSizeInterests += oneValueinterests.computeStringSizeNoTag()
            }
            serialize_size += dataSizeInterests
            serialize_size += 1 * Int32(interests.count)
            for oneElementFriends in friends {
                serialize_size += oneElementFriends.computeMessageSize(fieldNumber: 7)
            }
            if hasIsAdmin {
                serialize_size += isAdmin.computeBoolSize(fieldNumber: 8)
            }
            if hasAppShareLink {
                serialize_size += appShareLink.computeStringSize(fieldNumber: 9)
            }
            if hasHome {
                if let varSizehome = home?.computeMessageSize(fieldNumber: 10) {
                    serialize_size += varSizehome
                }
            }
            if hasLink {
                serialize_size += link.computeStringSize(fieldNumber: 11)
            }
            if (hasGender) {
                serialize_size += gender.rawValue.computeEnumSize(fieldNumber: 12)
            }
            if hasFacebookLinked {
                serialize_size += facebookLinked.computeBoolSize(fieldNumber: 13)
            }
            if hasPhoneVerified {
                serialize_size += phoneVerified.computeBoolSize(fieldNumber: 14)
            }
            if hasIncomingFriendRequests {
                serialize_size += incomingFriendRequests.computeUInt32Size(fieldNumber: 15)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UserProfile.Builder {
            return Present.UserProfile.classBuilder() as! Present.UserProfile.Builder
        }
        public func getBuilder() -> Present.UserProfile.Builder {
            return classBuilder() as! Present.UserProfile.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserProfile.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserProfile.Builder()
        }
        public func toBuilder() throws -> Present.UserProfile.Builder {
            return try Present.UserProfile.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UserProfile) throws -> Present.UserProfile.Builder {
            return try Present.UserProfile.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasId {
                jsonMap["id"] = id
            }
            if hasName {
                jsonMap["name"] = try name.encode()
            }
            if hasPhoto {
                jsonMap["photo"] = photo
            }
            if hasBio {
                jsonMap["bio"] = bio
            }
            if !interests.isEmpty {
                var jsonArrayInterests:Array<String> = []
                for oneValueInterests in interests {
                    jsonArrayInterests.append(oneValueInterests)
                }
                jsonMap["interests"] = jsonArrayInterests
            }
            if !friends.isEmpty {
                var jsonArrayFriends:Array<Dictionary<String,Any>> = []
                for oneValueFriends in friends {
                    let ecodedMessageFriends = try oneValueFriends.encode()
                    jsonArrayFriends.append(ecodedMessageFriends)
                }
                jsonMap["friends"] = jsonArrayFriends
            }
            if hasNotificationSettings {
                jsonMap["notificationSettings"] = try notificationSettings.encode()
            }
            if hasIsAdmin {
                jsonMap["isAdmin"] = isAdmin
            }
            if hasAppShareLink {
                jsonMap["appShareLink"] = appShareLink
            }
            if hasHome {
                jsonMap["home"] = try home.encode()
            }
            if hasLink {
                jsonMap["link"] = link
            }
            if hasGender {
                jsonMap["gender"] = gender.toString()
            }
            if hasFacebookLinked {
                jsonMap["facebookLinked"] = facebookLinked
            }
            if hasPhoneVerified {
                jsonMap["phoneVerified"] = phoneVerified
            }
            if hasIncomingFriendRequests {
                jsonMap["incomingFriendRequests"] = UInt(incomingFriendRequests)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UserProfile {
            return try Present.UserProfile.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UserProfile {
            return try Present.UserProfile.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasId {
                output += "\(indent) id: \(id) \n"
            }
            if hasName {
                output += "\(indent) name {\n"
                if let outDescName = name {
                    output += try outDescName.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPhoto {
                output += "\(indent) photo: \(photo) \n"
            }
            if hasNotificationSettings {
                output += "\(indent) notificationSettings {\n"
                if let outDescNotificationSettings = notificationSettings {
                    output += try outDescNotificationSettings.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBio {
                output += "\(indent) bio: \(bio) \n"
            }
            var interestsElementIndex:Int = 0
            for oneValueInterests in interests  {
                output += "\(indent) interests[\(interestsElementIndex)]: \(oneValueInterests)\n"
                interestsElementIndex += 1
            }
            var friendsElementIndex:Int = 0
            for oneElementFriends in friends {
                output += "\(indent) friends[\(friendsElementIndex)] {\n"
                output += try oneElementFriends.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                friendsElementIndex += 1
            }
            if hasIsAdmin {
                output += "\(indent) isAdmin: \(isAdmin) \n"
            }
            if hasAppShareLink {
                output += "\(indent) appShareLink: \(appShareLink) \n"
            }
            if hasHome {
                output += "\(indent) home {\n"
                if let outDescHome = home {
                    output += try outDescHome.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasLink {
                output += "\(indent) link: \(link) \n"
            }
            if (hasGender) {
                output += "\(indent) gender: \(gender.description)\n"
            }
            if hasFacebookLinked {
                output += "\(indent) facebookLinked: \(facebookLinked) \n"
            }
            if hasPhoneVerified {
                output += "\(indent) phoneVerified: \(phoneVerified) \n"
            }
            if hasIncomingFriendRequests {
                output += "\(indent) incomingFriendRequests: \(incomingFriendRequests) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasId {
                    hashCode = (hashCode &* 31) &+ id.hashValue
                }
                if hasName {
                    if let hashValuename = name?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuename
                    }
                }
                if hasPhoto {
                    hashCode = (hashCode &* 31) &+ photo.hashValue
                }
                if hasNotificationSettings {
                    if let hashValuenotificationSettings = notificationSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuenotificationSettings
                    }
                }
                if hasBio {
                    hashCode = (hashCode &* 31) &+ bio.hashValue
                }
                for oneValueInterests in interests {
                    hashCode = (hashCode &* 31) &+ oneValueInterests.hashValue
                }
                for oneElementFriends in friends {
                    hashCode = (hashCode &* 31) &+ oneElementFriends.hashValue
                }
                if hasIsAdmin {
                    hashCode = (hashCode &* 31) &+ isAdmin.hashValue
                }
                if hasAppShareLink {
                    hashCode = (hashCode &* 31) &+ appShareLink.hashValue
                }
                if hasHome {
                    if let hashValuehome = home?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuehome
                    }
                }
                if hasLink {
                    hashCode = (hashCode &* 31) &+ link.hashValue
                }
                if hasGender {
                     hashCode = (hashCode &* 31) &+ gender.hashValue
                }
                if hasFacebookLinked {
                    hashCode = (hashCode &* 31) &+ facebookLinked.hashValue
                }
                if hasPhoneVerified {
                    hashCode = (hashCode &* 31) &+ phoneVerified.hashValue
                }
                if hasIncomingFriendRequests {
                    hashCode = (hashCode &* 31) &+ incomingFriendRequests.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UserProfile"
        }
        override public func className() -> String {
            return "Present.UserProfile"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UserProfile = Present.UserProfile()
            public func getMessage() -> Present.UserProfile {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// User ID
            public var id:String {
                get {
                    return builderResult.id
                }
                set (value) {
                    builderResult.hasId = true
                    builderResult.id = value
                }
            }
            public var hasId:Bool {
                get {
                    return builderResult.hasId
                }
            }
            @discardableResult
            public func setId(_ value:String) -> Present.UserProfile.Builder {
                self.id = value
                return self
            }
            @discardableResult
            public func clearId() -> Present.UserProfile.Builder{
                builderResult.hasId = false
                builderResult.id = ""
                return self
            }
            /// Can be null if the client has logged in but has not set the user name.
            public var name:Present.UserName! {
                get {
                    if nameBuilder_ != nil {
                        builderResult.name = nameBuilder_.getMessage()
                    }
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            fileprivate var nameBuilder_:Present.UserName.Builder! {
                didSet {
                    builderResult.hasName = true
                }
            }
            public func getNameBuilder() -> Present.UserName.Builder {
                if nameBuilder_ == nil {
                    nameBuilder_ = Present.UserName.Builder()
                    builderResult.name = nameBuilder_.getMessage()
                    if name != nil {
                        try! nameBuilder_.mergeFrom(other: name)
                    }
                }
                return nameBuilder_
            }
            @discardableResult
            public func setName(_ value:Present.UserName!) -> Present.UserProfile.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func mergeName(value:Present.UserName) throws -> Present.UserProfile.Builder {
                if builderResult.hasName {
                    builderResult.name = try Present.UserName.builderWithPrototype(prototype:builderResult.name).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.name = value
                }
                builderResult.hasName = true
                return self
            }
            @discardableResult
            public func clearName() -> Present.UserProfile.Builder {
                nameBuilder_ = nil
                builderResult.hasName = false
                builderResult.name = nil
                return self
            }
            /// URL for user's JPEG photo. Can be null if the client has not uploaded a photo.
            public var photo:String {
                get {
                    return builderResult.photo
                }
                set (value) {
                    builderResult.hasPhoto = true
                    builderResult.photo = value
                }
            }
            public var hasPhoto:Bool {
                get {
                    return builderResult.hasPhoto
                }
            }
            @discardableResult
            public func setPhoto(_ value:String) -> Present.UserProfile.Builder {
                self.photo = value
                return self
            }
            @discardableResult
            public func clearPhoto() -> Present.UserProfile.Builder{
                builderResult.hasPhoto = false
                builderResult.photo = ""
                return self
            }
            /// The user's short self description.
            public var bio:String {
                get {
                    return builderResult.bio
                }
                set (value) {
                    builderResult.hasBio = true
                    builderResult.bio = value
                }
            }
            public var hasBio:Bool {
                get {
                    return builderResult.hasBio
                }
            }
            @discardableResult
            public func setBio(_ value:String) -> Present.UserProfile.Builder {
                self.bio = value
                return self
            }
            @discardableResult
            public func clearBio() -> Present.UserProfile.Builder{
                builderResult.hasBio = false
                builderResult.bio = ""
                return self
            }
            /// The user's chosen interests.
            /// TODO: Describe the relationship of interests to circle categories (subset?)
            public var interests:Array<String> {
                get {
                    return builderResult.interests
                }
                set (array) {
                    builderResult.interests = array
                }
            }
            @discardableResult
            public func setInterests(_ value:Array<String>) -> Present.UserProfile.Builder {
                self.interests = value
                return self
            }
            @discardableResult
            public func clearInterests() -> Present.UserProfile.Builder {
                builderResult.interests.removeAll(keepingCapacity: false)
                return self
            }
            /// Deprecated. Always empty. Use getFriends() instead.
            public var friends:Array<Present.FriendResponse> {
                get {
                    return builderResult.friends
                }
                set (value) {
                    builderResult.friends = value
                }
            }
            @discardableResult
            public func setFriends(_ value:Array<Present.FriendResponse>) -> Present.UserProfile.Builder {
                self.friends = value
                return self
            }
            @discardableResult
            public func clearFriends() -> Present.UserProfile.Builder {
                builderResult.friends.removeAll(keepingCapacity: false)
                return self
            }
            /// The user's notification preferences.
            public var notificationSettings:Present.UserNotificationSettings! {
                get {
                    if notificationSettingsBuilder_ != nil {
                        builderResult.notificationSettings = notificationSettingsBuilder_.getMessage()
                    }
                    return builderResult.notificationSettings
                }
                set (value) {
                    builderResult.hasNotificationSettings = true
                    builderResult.notificationSettings = value
                }
            }
            public var hasNotificationSettings:Bool {
                get {
                    return builderResult.hasNotificationSettings
                }
            }
            fileprivate var notificationSettingsBuilder_:Present.UserNotificationSettings.Builder! {
                didSet {
                    builderResult.hasNotificationSettings = true
                }
            }
            public func getNotificationSettingsBuilder() -> Present.UserNotificationSettings.Builder {
                if notificationSettingsBuilder_ == nil {
                    notificationSettingsBuilder_ = Present.UserNotificationSettings.Builder()
                    builderResult.notificationSettings = notificationSettingsBuilder_.getMessage()
                    if notificationSettings != nil {
                        try! notificationSettingsBuilder_.mergeFrom(other: notificationSettings)
                    }
                }
                return notificationSettingsBuilder_
            }
            @discardableResult
            public func setNotificationSettings(_ value:Present.UserNotificationSettings!) -> Present.UserProfile.Builder {
                self.notificationSettings = value
                return self
            }
            @discardableResult
            public func mergeNotificationSettings(value:Present.UserNotificationSettings) throws -> Present.UserProfile.Builder {
                if builderResult.hasNotificationSettings {
                    builderResult.notificationSettings = try Present.UserNotificationSettings.builderWithPrototype(prototype:builderResult.notificationSettings).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.notificationSettings = value
                }
                builderResult.hasNotificationSettings = true
                return self
            }
            @discardableResult
            public func clearNotificationSettings() -> Present.UserProfile.Builder {
                notificationSettingsBuilder_ = nil
                builderResult.hasNotificationSettings = false
                builderResult.notificationSettings = nil
                return self
            }
            /// If true this user is a Present administrator.  Administrators may edit content owned by others.
            public var isAdmin:Bool {
                get {
                    return builderResult.isAdmin
                }
                set (value) {
                    builderResult.hasIsAdmin = true
                    builderResult.isAdmin = value
                }
            }
            public var hasIsAdmin:Bool {
                get {
                    return builderResult.hasIsAdmin
                }
            }
            @discardableResult
            public func setIsAdmin(_ value:Bool) -> Present.UserProfile.Builder {
                self.isAdmin = value
                return self
            }
            @discardableResult
            public func clearIsAdmin() -> Present.UserProfile.Builder{
                builderResult.hasIsAdmin = false
                builderResult.isAdmin = false
                return self
            }
            /// Link used to share the app with other users. Embeds referrer information.
            public var appShareLink:String {
                get {
                    return builderResult.appShareLink
                }
                set (value) {
                    builderResult.hasAppShareLink = true
                    builderResult.appShareLink = value
                }
            }
            public var hasAppShareLink:Bool {
                get {
                    return builderResult.hasAppShareLink
                }
            }
            @discardableResult
            public func setAppShareLink(_ value:String) -> Present.UserProfile.Builder {
                self.appShareLink = value
                return self
            }
            @discardableResult
            public func clearAppShareLink() -> Present.UserProfile.Builder{
                builderResult.hasAppShareLink = false
                builderResult.appShareLink = ""
                return self
            }
            /// The user's home city.
            public var home:Present.City! {
                get {
                    if homeBuilder_ != nil {
                        builderResult.home = homeBuilder_.getMessage()
                    }
                    return builderResult.home
                }
                set (value) {
                    builderResult.hasHome = true
                    builderResult.home = value
                }
            }
            public var hasHome:Bool {
                get {
                    return builderResult.hasHome
                }
            }
            fileprivate var homeBuilder_:Present.City.Builder! {
                didSet {
                    builderResult.hasHome = true
                }
            }
            public func getHomeBuilder() -> Present.City.Builder {
                if homeBuilder_ == nil {
                    homeBuilder_ = Present.City.Builder()
                    builderResult.home = homeBuilder_.getMessage()
                    if home != nil {
                        try! homeBuilder_.mergeFrom(other: home)
                    }
                }
                return homeBuilder_
            }
            @discardableResult
            public func setHome(_ value:Present.City!) -> Present.UserProfile.Builder {
                self.home = value
                return self
            }
            @discardableResult
            public func mergeHome(value:Present.City) throws -> Present.UserProfile.Builder {
                if builderResult.hasHome {
                    builderResult.home = try Present.City.builderWithPrototype(prototype:builderResult.home).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.home = value
                }
                builderResult.hasHome = true
                return self
            }
            @discardableResult
            public func clearHome() -> Present.UserProfile.Builder {
                homeBuilder_ = nil
                builderResult.hasHome = false
                builderResult.home = nil
                return self
            }
            /// An HTTPS link to this user.
            public var link:String {
                get {
                    return builderResult.link
                }
                set (value) {
                    builderResult.hasLink = true
                    builderResult.link = value
                }
            }
            public var hasLink:Bool {
                get {
                    return builderResult.hasLink
                }
            }
            @discardableResult
            public func setLink(_ value:String) -> Present.UserProfile.Builder {
                self.link = value
                return self
            }
            @discardableResult
            public func clearLink() -> Present.UserProfile.Builder{
                builderResult.hasLink = false
                builderResult.link = ""
                return self
            }
            /// User's gender identification.
                public var gender:Present.Gender {
                    get {
                        return builderResult.gender
                    }
                    set (value) {
                        builderResult.hasGender = true
                        builderResult.gender = value
                    }
                }
                public var hasGender:Bool{
                    get {
                        return builderResult.hasGender
                    }
                }
            @discardableResult
                public func setGender(_ value:Present.Gender) -> Present.UserProfile.Builder {
                  self.gender = value
                  return self
                }
            @discardableResult
                public func clearGender() -> Present.UserProfile.Builder {
                   builderResult.hasGender = false
                   builderResult.gender = .unknownGender
                   return self
                }
            /// True if the user has a Facebook account linked.
            public var facebookLinked:Bool {
                get {
                    return builderResult.facebookLinked
                }
                set (value) {
                    builderResult.hasFacebookLinked = true
                    builderResult.facebookLinked = value
                }
            }
            public var hasFacebookLinked:Bool {
                get {
                    return builderResult.hasFacebookLinked
                }
            }
            @discardableResult
            public func setFacebookLinked(_ value:Bool) -> Present.UserProfile.Builder {
                self.facebookLinked = value
                return self
            }
            @discardableResult
            public func clearFacebookLinked() -> Present.UserProfile.Builder{
                builderResult.hasFacebookLinked = false
                builderResult.facebookLinked = false
                return self
            }
            /// True if the user has verified a phone number.
            public var phoneVerified:Bool {
                get {
                    return builderResult.phoneVerified
                }
                set (value) {
                    builderResult.hasPhoneVerified = true
                    builderResult.phoneVerified = value
                }
            }
            public var hasPhoneVerified:Bool {
                get {
                    return builderResult.hasPhoneVerified
                }
            }
            @discardableResult
            public func setPhoneVerified(_ value:Bool) -> Present.UserProfile.Builder {
                self.phoneVerified = value
                return self
            }
            @discardableResult
            public func clearPhoneVerified() -> Present.UserProfile.Builder{
                builderResult.hasPhoneVerified = false
                builderResult.phoneVerified = false
                return self
            }
            /// Number of open friend requests.
            public var incomingFriendRequests:UInt32 {
                get {
                    return builderResult.incomingFriendRequests
                }
                set (value) {
                    builderResult.hasIncomingFriendRequests = true
                    builderResult.incomingFriendRequests = value
                }
            }
            public var hasIncomingFriendRequests:Bool {
                get {
                    return builderResult.hasIncomingFriendRequests
                }
            }
            @discardableResult
            public func setIncomingFriendRequests(_ value:UInt32) -> Present.UserProfile.Builder {
                self.incomingFriendRequests = value
                return self
            }
            @discardableResult
            public func clearIncomingFriendRequests() -> Present.UserProfile.Builder{
                builderResult.hasIncomingFriendRequests = false
                builderResult.incomingFriendRequests = UInt32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UserProfile.Builder {
                builderResult = Present.UserProfile()
                return self
            }
            override public func clone() throws -> Present.UserProfile.Builder {
                return try Present.UserProfile.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UserProfile {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UserProfile {
                let returnMe:Present.UserProfile = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UserProfile) throws -> Present.UserProfile.Builder {
                if other == Present.UserProfile() {
                    return self
                }
                if other.hasId {
                    id = other.id
                }
                if (other.hasName) {
                    try mergeName(value: other.name)
                }
                if other.hasPhoto {
                    photo = other.photo
                }
                if other.hasBio {
                    bio = other.bio
                }
                if !other.interests.isEmpty {
                    builderResult.interests += other.interests
                }
                if !other.friends.isEmpty  {
                     builderResult.friends += other.friends
                }
                if (other.hasNotificationSettings) {
                    try mergeNotificationSettings(value: other.notificationSettings)
                }
                if other.hasIsAdmin {
                    isAdmin = other.isAdmin
                }
                if other.hasAppShareLink {
                    appShareLink = other.appShareLink
                }
                if (other.hasHome) {
                    try mergeHome(value: other.home)
                }
                if other.hasLink {
                    link = other.link
                }
                if other.hasGender {
                    gender = other.gender
                }
                if other.hasFacebookLinked {
                    facebookLinked = other.facebookLinked
                }
                if other.hasPhoneVerified {
                    phoneVerified = other.phoneVerified
                }
                if other.hasIncomingFriendRequests {
                    incomingFriendRequests = other.incomingFriendRequests
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UserProfile.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserProfile.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        id = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Present.UserName.Builder = Present.UserName.Builder()
                        if hasName {
                            try subBuilder.mergeFrom(other: name)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        name = subBuilder.buildPartial()

                    case 26:
                        photo = try codedInputStream.readString()

                    case 34:
                        let subBuilder:Present.UserNotificationSettings.Builder = Present.UserNotificationSettings.Builder()
                        if hasNotificationSettings {
                            try subBuilder.mergeFrom(other: notificationSettings)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        notificationSettings = subBuilder.buildPartial()

                    case 42:
                        bio = try codedInputStream.readString()

                    case 50:
                        interests += [try codedInputStream.readString()]

                    case 58:
                        let subBuilder = Present.FriendResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        friends.append(subBuilder.buildPartial())

                    case 64:
                        isAdmin = try codedInputStream.readBool()

                    case 74:
                        appShareLink = try codedInputStream.readString()

                    case 82:
                        let subBuilder:Present.City.Builder = Present.City.Builder()
                        if hasHome {
                            try subBuilder.mergeFrom(other: home)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        home = subBuilder.buildPartial()

                    case 90:
                        link = try codedInputStream.readString()

                    case 96:
                        let valueIntgender = try codedInputStream.readEnum()
                        if let enumsgender = Present.Gender(rawValue:valueIntgender){
                            gender = enumsgender
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 12, value:Int64(valueIntgender))
                        }

                    case 104:
                        facebookLinked = try codedInputStream.readBool()

                    case 112:
                        phoneVerified = try codedInputStream.readBool()

                    case 120:
                        incomingFriendRequests = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UserProfile.Builder {
                let resultDecodedBuilder = Present.UserProfile.Builder()
                if let jsonValueId = jsonMap["id"] as? String {
                    resultDecodedBuilder.id = jsonValueId
                }
                if let jsonValueName = jsonMap["name"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.name = try Present.UserName.Builder.decodeToBuilder(jsonMap:jsonValueName).build()

                }
                if let jsonValuePhoto = jsonMap["photo"] as? String {
                    resultDecodedBuilder.photo = jsonValuePhoto
                }
                if let jsonValueBio = jsonMap["bio"] as? String {
                    resultDecodedBuilder.bio = jsonValueBio
                }
                if let jsonValueInterests = jsonMap["interests"] as? Array<String> {
                    var jsonArrayInterests:Array<String> = []
                    for oneValueInterests in jsonValueInterests {
                        jsonArrayInterests.append(oneValueInterests)
                    }
                    resultDecodedBuilder.interests = jsonArrayInterests
                }
                if let jsonValueFriends = jsonMap["friends"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayFriends:Array<Present.FriendResponse> = []
                    for oneValueFriends in jsonValueFriends {
                        let messageFromStringFriends = try Present.FriendResponse.Builder.decodeToBuilder(jsonMap:oneValueFriends).build()

                        jsonArrayFriends.append(messageFromStringFriends)
                    }
                    resultDecodedBuilder.friends = jsonArrayFriends
                }
                if let jsonValueNotificationSettings = jsonMap["notificationSettings"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.notificationSettings = try Present.UserNotificationSettings.Builder.decodeToBuilder(jsonMap:jsonValueNotificationSettings).build()

                }
                if let jsonValueIsAdmin = jsonMap["isAdmin"] as? Bool {
                    resultDecodedBuilder.isAdmin = jsonValueIsAdmin
                }
                if let jsonValueAppShareLink = jsonMap["appShareLink"] as? String {
                    resultDecodedBuilder.appShareLink = jsonValueAppShareLink
                }
                if let jsonValueHome = jsonMap["home"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.home = try Present.City.Builder.decodeToBuilder(jsonMap:jsonValueHome).build()

                }
                if let jsonValueLink = jsonMap["link"] as? String {
                    resultDecodedBuilder.link = jsonValueLink
                }
                if let jsonValueGender = jsonMap["gender"] as? String {
                    resultDecodedBuilder.gender = try Present.Gender.fromString(str: jsonValueGender)
                }
                if let jsonValueFacebookLinked = jsonMap["facebookLinked"] as? Bool {
                    resultDecodedBuilder.facebookLinked = jsonValueFacebookLinked
                }
                if let jsonValuePhoneVerified = jsonMap["phoneVerified"] as? Bool {
                    resultDecodedBuilder.phoneVerified = jsonValuePhoneVerified
                }
                if let jsonValueIncomingFriendRequests = jsonMap["incomingFriendRequests"] as? UInt {
                    resultDecodedBuilder.incomingFriendRequests = UInt32(jsonValueIncomingFriendRequests)
                } else if let jsonValueIncomingFriendRequests = jsonMap["incomingFriendRequests"] as? String {
                    resultDecodedBuilder.incomingFriendRequests = UInt32(jsonValueIncomingFriendRequests)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UserProfile.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UserProfile.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// User updatable elements of the user profile.
    final public class UserProfileRequest : GeneratedMessage {

        public static func == (lhs: Present.UserProfileRequest, rhs: Present.UserProfileRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
            fieldCheck = fieldCheck && (lhs.hasPhoto == rhs.hasPhoto) && (!lhs.hasPhoto || lhs.photo == rhs.photo)
            fieldCheck = fieldCheck && (lhs.hasNotificationSettings == rhs.hasNotificationSettings) && (!lhs.hasNotificationSettings || lhs.notificationSettings == rhs.notificationSettings)
            fieldCheck = fieldCheck && (lhs.hasBio == rhs.hasBio) && (!lhs.hasBio || lhs.bio == rhs.bio)
            fieldCheck = fieldCheck && (lhs.interests == rhs.interests)
            fieldCheck = fieldCheck && (lhs.hasZip == rhs.hasZip) && (!lhs.hasZip || lhs.zip == rhs.zip)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var name:Present.UserName!
        public fileprivate(set) var hasName:Bool = false
        public fileprivate(set) var photo:Present.ContentReferenceRequest!
        public fileprivate(set) var hasPhoto:Bool = false
        /// A short self description
        public fileprivate(set) var bio:String = ""
        public fileprivate(set) var hasBio:Bool = false

        /// A set of interests chosen by the user.
        public fileprivate(set) var interests:Array<String> = Array<String>()
        /// User's 5-digit zip code
        public fileprivate(set) var zip:String = ""
        public fileprivate(set) var hasZip:Bool = false

        public fileprivate(set) var notificationSettings:Present.UserNotificationSettings!
        public fileprivate(set) var hasNotificationSettings:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if hasName {
                if !name.isInitialized() {
                    return false
                }
            }
            if hasPhoto {
                if !photo.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasName {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:name)
            }
            if hasPhoto {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:photo)
            }
            if hasNotificationSettings {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:notificationSettings)
            }
            if hasBio {
                try codedOutputStream.writeString(fieldNumber: 5, value:bio)
            }
            if !interests.isEmpty {
                for oneValueinterests in interests {
                    try codedOutputStream.writeString(fieldNumber: 6, value:oneValueinterests)
                }
            }
            if hasZip {
                try codedOutputStream.writeString(fieldNumber: 7, value:zip)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasName {
                if let varSizename = name?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizename
                }
            }
            if hasPhoto {
                if let varSizephoto = photo?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizephoto
                }
            }
            if hasNotificationSettings {
                if let varSizenotificationSettings = notificationSettings?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizenotificationSettings
                }
            }
            if hasBio {
                serialize_size += bio.computeStringSize(fieldNumber: 5)
            }
            var dataSizeInterests:Int32 = 0
            for oneValueinterests in interests {
                dataSizeInterests += oneValueinterests.computeStringSizeNoTag()
            }
            serialize_size += dataSizeInterests
            serialize_size += 1 * Int32(interests.count)
            if hasZip {
                serialize_size += zip.computeStringSize(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UserProfileRequest.Builder {
            return Present.UserProfileRequest.classBuilder() as! Present.UserProfileRequest.Builder
        }
        public func getBuilder() -> Present.UserProfileRequest.Builder {
            return classBuilder() as! Present.UserProfileRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserProfileRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserProfileRequest.Builder()
        }
        public func toBuilder() throws -> Present.UserProfileRequest.Builder {
            return try Present.UserProfileRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UserProfileRequest) throws -> Present.UserProfileRequest.Builder {
            return try Present.UserProfileRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasName {
                jsonMap["name"] = try name.encode()
            }
            if hasPhoto {
                jsonMap["photo"] = try photo.encode()
            }
            if hasBio {
                jsonMap["bio"] = bio
            }
            if !interests.isEmpty {
                var jsonArrayInterests:Array<String> = []
                for oneValueInterests in interests {
                    jsonArrayInterests.append(oneValueInterests)
                }
                jsonMap["interests"] = jsonArrayInterests
            }
            if hasZip {
                jsonMap["zip"] = zip
            }
            if hasNotificationSettings {
                jsonMap["notificationSettings"] = try notificationSettings.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UserProfileRequest {
            return try Present.UserProfileRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UserProfileRequest {
            return try Present.UserProfileRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasName {
                output += "\(indent) name {\n"
                if let outDescName = name {
                    output += try outDescName.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPhoto {
                output += "\(indent) photo {\n"
                if let outDescPhoto = photo {
                    output += try outDescPhoto.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasNotificationSettings {
                output += "\(indent) notificationSettings {\n"
                if let outDescNotificationSettings = notificationSettings {
                    output += try outDescNotificationSettings.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBio {
                output += "\(indent) bio: \(bio) \n"
            }
            var interestsElementIndex:Int = 0
            for oneValueInterests in interests  {
                output += "\(indent) interests[\(interestsElementIndex)]: \(oneValueInterests)\n"
                interestsElementIndex += 1
            }
            if hasZip {
                output += "\(indent) zip: \(zip) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                    if let hashValuename = name?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuename
                    }
                }
                if hasPhoto {
                    if let hashValuephoto = photo?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuephoto
                    }
                }
                if hasNotificationSettings {
                    if let hashValuenotificationSettings = notificationSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuenotificationSettings
                    }
                }
                if hasBio {
                    hashCode = (hashCode &* 31) &+ bio.hashValue
                }
                for oneValueInterests in interests {
                    hashCode = (hashCode &* 31) &+ oneValueInterests.hashValue
                }
                if hasZip {
                    hashCode = (hashCode &* 31) &+ zip.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UserProfileRequest"
        }
        override public func className() -> String {
            return "Present.UserProfileRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UserProfileRequest = Present.UserProfileRequest()
            public func getMessage() -> Present.UserProfileRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The user supplied name
            public var name:Present.UserName! {
                get {
                    if nameBuilder_ != nil {
                        builderResult.name = nameBuilder_.getMessage()
                    }
                    return builderResult.name
                }
                set (value) {
                    builderResult.hasName = true
                    builderResult.name = value
                }
            }
            public var hasName:Bool {
                get {
                    return builderResult.hasName
                }
            }
            fileprivate var nameBuilder_:Present.UserName.Builder! {
                didSet {
                    builderResult.hasName = true
                }
            }
            public func getNameBuilder() -> Present.UserName.Builder {
                if nameBuilder_ == nil {
                    nameBuilder_ = Present.UserName.Builder()
                    builderResult.name = nameBuilder_.getMessage()
                    if name != nil {
                        try! nameBuilder_.mergeFrom(other: name)
                    }
                }
                return nameBuilder_
            }
            @discardableResult
            public func setName(_ value:Present.UserName!) -> Present.UserProfileRequest.Builder {
                self.name = value
                return self
            }
            @discardableResult
            public func mergeName(value:Present.UserName) throws -> Present.UserProfileRequest.Builder {
                if builderResult.hasName {
                    builderResult.name = try Present.UserName.builderWithPrototype(prototype:builderResult.name).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.name = value
                }
                builderResult.hasName = true
                return self
            }
            @discardableResult
            public func clearName() -> Present.UserProfileRequest.Builder {
                nameBuilder_ = nil
                builderResult.hasName = false
                builderResult.name = nil
                return self
            }
            /// A content reference for an uploaded user photo.
            public var photo:Present.ContentReferenceRequest! {
                get {
                    if photoBuilder_ != nil {
                        builderResult.photo = photoBuilder_.getMessage()
                    }
                    return builderResult.photo
                }
                set (value) {
                    builderResult.hasPhoto = true
                    builderResult.photo = value
                }
            }
            public var hasPhoto:Bool {
                get {
                    return builderResult.hasPhoto
                }
            }
            fileprivate var photoBuilder_:Present.ContentReferenceRequest.Builder! {
                didSet {
                    builderResult.hasPhoto = true
                }
            }
            public func getPhotoBuilder() -> Present.ContentReferenceRequest.Builder {
                if photoBuilder_ == nil {
                    photoBuilder_ = Present.ContentReferenceRequest.Builder()
                    builderResult.photo = photoBuilder_.getMessage()
                    if photo != nil {
                        try! photoBuilder_.mergeFrom(other: photo)
                    }
                }
                return photoBuilder_
            }
            @discardableResult
            public func setPhoto(_ value:Present.ContentReferenceRequest!) -> Present.UserProfileRequest.Builder {
                self.photo = value
                return self
            }
            @discardableResult
            public func mergePhoto(value:Present.ContentReferenceRequest) throws -> Present.UserProfileRequest.Builder {
                if builderResult.hasPhoto {
                    builderResult.photo = try Present.ContentReferenceRequest.builderWithPrototype(prototype:builderResult.photo).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.photo = value
                }
                builderResult.hasPhoto = true
                return self
            }
            @discardableResult
            public func clearPhoto() -> Present.UserProfileRequest.Builder {
                photoBuilder_ = nil
                builderResult.hasPhoto = false
                builderResult.photo = nil
                return self
            }
            /// A short self description
            public var bio:String {
                get {
                    return builderResult.bio
                }
                set (value) {
                    builderResult.hasBio = true
                    builderResult.bio = value
                }
            }
            public var hasBio:Bool {
                get {
                    return builderResult.hasBio
                }
            }
            @discardableResult
            public func setBio(_ value:String) -> Present.UserProfileRequest.Builder {
                self.bio = value
                return self
            }
            @discardableResult
            public func clearBio() -> Present.UserProfileRequest.Builder{
                builderResult.hasBio = false
                builderResult.bio = ""
                return self
            }
            /// A set of interests chosen by the user.
            public var interests:Array<String> {
                get {
                    return builderResult.interests
                }
                set (array) {
                    builderResult.interests = array
                }
            }
            @discardableResult
            public func setInterests(_ value:Array<String>) -> Present.UserProfileRequest.Builder {
                self.interests = value
                return self
            }
            @discardableResult
            public func clearInterests() -> Present.UserProfileRequest.Builder {
                builderResult.interests.removeAll(keepingCapacity: false)
                return self
            }
            /// User's 5-digit zip code
            public var zip:String {
                get {
                    return builderResult.zip
                }
                set (value) {
                    builderResult.hasZip = true
                    builderResult.zip = value
                }
            }
            public var hasZip:Bool {
                get {
                    return builderResult.hasZip
                }
            }
            @discardableResult
            public func setZip(_ value:String) -> Present.UserProfileRequest.Builder {
                self.zip = value
                return self
            }
            @discardableResult
            public func clearZip() -> Present.UserProfileRequest.Builder{
                builderResult.hasZip = false
                builderResult.zip = ""
                return self
            }
            /// The user's notification preferences.
            /// Each setting is optional and may be updated indivdiually.
            public var notificationSettings:Present.UserNotificationSettings! {
                get {
                    if notificationSettingsBuilder_ != nil {
                        builderResult.notificationSettings = notificationSettingsBuilder_.getMessage()
                    }
                    return builderResult.notificationSettings
                }
                set (value) {
                    builderResult.hasNotificationSettings = true
                    builderResult.notificationSettings = value
                }
            }
            public var hasNotificationSettings:Bool {
                get {
                    return builderResult.hasNotificationSettings
                }
            }
            fileprivate var notificationSettingsBuilder_:Present.UserNotificationSettings.Builder! {
                didSet {
                    builderResult.hasNotificationSettings = true
                }
            }
            public func getNotificationSettingsBuilder() -> Present.UserNotificationSettings.Builder {
                if notificationSettingsBuilder_ == nil {
                    notificationSettingsBuilder_ = Present.UserNotificationSettings.Builder()
                    builderResult.notificationSettings = notificationSettingsBuilder_.getMessage()
                    if notificationSettings != nil {
                        try! notificationSettingsBuilder_.mergeFrom(other: notificationSettings)
                    }
                }
                return notificationSettingsBuilder_
            }
            @discardableResult
            public func setNotificationSettings(_ value:Present.UserNotificationSettings!) -> Present.UserProfileRequest.Builder {
                self.notificationSettings = value
                return self
            }
            @discardableResult
            public func mergeNotificationSettings(value:Present.UserNotificationSettings) throws -> Present.UserProfileRequest.Builder {
                if builderResult.hasNotificationSettings {
                    builderResult.notificationSettings = try Present.UserNotificationSettings.builderWithPrototype(prototype:builderResult.notificationSettings).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.notificationSettings = value
                }
                builderResult.hasNotificationSettings = true
                return self
            }
            @discardableResult
            public func clearNotificationSettings() -> Present.UserProfileRequest.Builder {
                notificationSettingsBuilder_ = nil
                builderResult.hasNotificationSettings = false
                builderResult.notificationSettings = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UserProfileRequest.Builder {
                builderResult = Present.UserProfileRequest()
                return self
            }
            override public func clone() throws -> Present.UserProfileRequest.Builder {
                return try Present.UserProfileRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UserProfileRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UserProfileRequest {
                let returnMe:Present.UserProfileRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UserProfileRequest) throws -> Present.UserProfileRequest.Builder {
                if other == Present.UserProfileRequest() {
                    return self
                }
                if (other.hasName) {
                    try mergeName(value: other.name)
                }
                if (other.hasPhoto) {
                    try mergePhoto(value: other.photo)
                }
                if other.hasBio {
                    bio = other.bio
                }
                if !other.interests.isEmpty {
                    builderResult.interests += other.interests
                }
                if other.hasZip {
                    zip = other.zip
                }
                if (other.hasNotificationSettings) {
                    try mergeNotificationSettings(value: other.notificationSettings)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UserProfileRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserProfileRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.UserName.Builder = Present.UserName.Builder()
                        if hasName {
                            try subBuilder.mergeFrom(other: name)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        name = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Present.ContentReferenceRequest.Builder = Present.ContentReferenceRequest.Builder()
                        if hasPhoto {
                            try subBuilder.mergeFrom(other: photo)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        photo = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Present.UserNotificationSettings.Builder = Present.UserNotificationSettings.Builder()
                        if hasNotificationSettings {
                            try subBuilder.mergeFrom(other: notificationSettings)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        notificationSettings = subBuilder.buildPartial()

                    case 42:
                        bio = try codedInputStream.readString()

                    case 50:
                        interests += [try codedInputStream.readString()]

                    case 58:
                        zip = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UserProfileRequest.Builder {
                let resultDecodedBuilder = Present.UserProfileRequest.Builder()
                if let jsonValueName = jsonMap["name"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.name = try Present.UserName.Builder.decodeToBuilder(jsonMap:jsonValueName).build()

                }
                if let jsonValuePhoto = jsonMap["photo"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.photo = try Present.ContentReferenceRequest.Builder.decodeToBuilder(jsonMap:jsonValuePhoto).build()

                }
                if let jsonValueBio = jsonMap["bio"] as? String {
                    resultDecodedBuilder.bio = jsonValueBio
                }
                if let jsonValueInterests = jsonMap["interests"] as? Array<String> {
                    var jsonArrayInterests:Array<String> = []
                    for oneValueInterests in jsonValueInterests {
                        jsonArrayInterests.append(oneValueInterests)
                    }
                    resultDecodedBuilder.interests = jsonArrayInterests
                }
                if let jsonValueZip = jsonMap["zip"] as? String {
                    resultDecodedBuilder.zip = jsonValueZip
                }
                if let jsonValueNotificationSettings = jsonMap["notificationSettings"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.notificationSettings = try Present.UserNotificationSettings.Builder.decodeToBuilder(jsonMap:jsonValueNotificationSettings).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UserProfileRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UserProfileRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PutUserPhotoRequest : GeneratedMessage {

        public static func == (lhs: Present.PutUserPhotoRequest, rhs: Present.PutUserPhotoRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPhotoRef == rhs.hasPhotoRef) && (!lhs.hasPhotoRef || lhs.photoRef == rhs.photoRef)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var photoRef:Present.ContentReferenceRequest!
        public fileprivate(set) var hasPhotoRef:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasPhotoRef {
                return false
            }
            if !photoRef.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPhotoRef {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:photoRef)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPhotoRef {
                if let varSizephotoRef = photoRef?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizephotoRef
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PutUserPhotoRequest.Builder {
            return Present.PutUserPhotoRequest.classBuilder() as! Present.PutUserPhotoRequest.Builder
        }
        public func getBuilder() -> Present.PutUserPhotoRequest.Builder {
            return classBuilder() as! Present.PutUserPhotoRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutUserPhotoRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutUserPhotoRequest.Builder()
        }
        public func toBuilder() throws -> Present.PutUserPhotoRequest.Builder {
            return try Present.PutUserPhotoRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PutUserPhotoRequest) throws -> Present.PutUserPhotoRequest.Builder {
            return try Present.PutUserPhotoRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPhotoRef {
                jsonMap["photoRef"] = try photoRef.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PutUserPhotoRequest {
            return try Present.PutUserPhotoRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PutUserPhotoRequest {
            return try Present.PutUserPhotoRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPhotoRef {
                output += "\(indent) photoRef {\n"
                if let outDescPhotoRef = photoRef {
                    output += try outDescPhotoRef.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPhotoRef {
                    if let hashValuephotoRef = photoRef?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuephotoRef
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PutUserPhotoRequest"
        }
        override public func className() -> String {
            return "Present.PutUserPhotoRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PutUserPhotoRequest = Present.PutUserPhotoRequest()
            public func getMessage() -> Present.PutUserPhotoRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The user's photo
            public var photoRef:Present.ContentReferenceRequest! {
                get {
                    if photoRefBuilder_ != nil {
                        builderResult.photoRef = photoRefBuilder_.getMessage()
                    }
                    return builderResult.photoRef
                }
                set (value) {
                    builderResult.hasPhotoRef = true
                    builderResult.photoRef = value
                }
            }
            public var hasPhotoRef:Bool {
                get {
                    return builderResult.hasPhotoRef
                }
            }
            fileprivate var photoRefBuilder_:Present.ContentReferenceRequest.Builder! {
                didSet {
                    builderResult.hasPhotoRef = true
                }
            }
            public func getPhotoRefBuilder() -> Present.ContentReferenceRequest.Builder {
                if photoRefBuilder_ == nil {
                    photoRefBuilder_ = Present.ContentReferenceRequest.Builder()
                    builderResult.photoRef = photoRefBuilder_.getMessage()
                    if photoRef != nil {
                        try! photoRefBuilder_.mergeFrom(other: photoRef)
                    }
                }
                return photoRefBuilder_
            }
            @discardableResult
            public func setPhotoRef(_ value:Present.ContentReferenceRequest!) -> Present.PutUserPhotoRequest.Builder {
                self.photoRef = value
                return self
            }
            @discardableResult
            public func mergePhotoRef(value:Present.ContentReferenceRequest) throws -> Present.PutUserPhotoRequest.Builder {
                if builderResult.hasPhotoRef {
                    builderResult.photoRef = try Present.ContentReferenceRequest.builderWithPrototype(prototype:builderResult.photoRef).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.photoRef = value
                }
                builderResult.hasPhotoRef = true
                return self
            }
            @discardableResult
            public func clearPhotoRef() -> Present.PutUserPhotoRequest.Builder {
                photoRefBuilder_ = nil
                builderResult.hasPhotoRef = false
                builderResult.photoRef = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PutUserPhotoRequest.Builder {
                builderResult = Present.PutUserPhotoRequest()
                return self
            }
            override public func clone() throws -> Present.PutUserPhotoRequest.Builder {
                return try Present.PutUserPhotoRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PutUserPhotoRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PutUserPhotoRequest {
                let returnMe:Present.PutUserPhotoRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PutUserPhotoRequest) throws -> Present.PutUserPhotoRequest.Builder {
                if other == Present.PutUserPhotoRequest() {
                    return self
                }
                if (other.hasPhotoRef) {
                    try mergePhotoRef(value: other.photoRef)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PutUserPhotoRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutUserPhotoRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        let subBuilder:Present.ContentReferenceRequest.Builder = Present.ContentReferenceRequest.Builder()
                        if hasPhotoRef {
                            try subBuilder.mergeFrom(other: photoRef)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        photoRef = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PutUserPhotoRequest.Builder {
                let resultDecodedBuilder = Present.PutUserPhotoRequest.Builder()
                if let jsonValuePhotoRef = jsonMap["photoRef"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.photoRef = try Present.ContentReferenceRequest.Builder.decodeToBuilder(jsonMap:jsonValuePhotoRef).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PutUserPhotoRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PutUserPhotoRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PutDeviceTokenRequest : GeneratedMessage {

        public static func == (lhs: Present.PutDeviceTokenRequest, rhs: Present.PutDeviceTokenRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDeviceToken == rhs.hasDeviceToken) && (!lhs.hasDeviceToken || lhs.deviceToken == rhs.deviceToken)
            fieldCheck = fieldCheck && (lhs.hasApnsEnvironment == rhs.hasApnsEnvironment) && (!lhs.hasApnsEnvironment || lhs.apnsEnvironment == rhs.apnsEnvironment)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum ApnsEnvironment:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case sandbox = 1
                case production = 2
                public func toString() -> String {
                    switch self {
                    case .sandbox: return "SANDBOX"
                    case .production: return "PRODUCTION"
                    }
                }
                public static func fromString(str:String) throws -> Present.PutDeviceTokenRequest.ApnsEnvironment {
                    switch str {
                    case "SANDBOX":    return .sandbox
                    case "PRODUCTION":    return .production
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .sandbox: return ".sandbox"
                    case .production: return ".production"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:ApnsEnvironment, rhs:ApnsEnvironment) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// Token that identifies the device to the downstream notification service.
        /// Setting this to null clears the device's token; can be used by the client when switching
        /// between staging and production.
        public fileprivate(set) var deviceToken:String = ""
        public fileprivate(set) var hasDeviceToken:Bool = false

        public fileprivate(set) var apnsEnvironment:Present.PutDeviceTokenRequest.ApnsEnvironment = Present.PutDeviceTokenRequest.ApnsEnvironment.sandbox
        public fileprivate(set) var hasApnsEnvironment:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDeviceToken {
                try codedOutputStream.writeString(fieldNumber: 1, value:deviceToken)
            }
            if hasApnsEnvironment {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:apnsEnvironment.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDeviceToken {
                serialize_size += deviceToken.computeStringSize(fieldNumber: 1)
            }
            if (hasApnsEnvironment) {
                serialize_size += apnsEnvironment.rawValue.computeEnumSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PutDeviceTokenRequest.Builder {
            return Present.PutDeviceTokenRequest.classBuilder() as! Present.PutDeviceTokenRequest.Builder
        }
        public func getBuilder() -> Present.PutDeviceTokenRequest.Builder {
            return classBuilder() as! Present.PutDeviceTokenRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutDeviceTokenRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutDeviceTokenRequest.Builder()
        }
        public func toBuilder() throws -> Present.PutDeviceTokenRequest.Builder {
            return try Present.PutDeviceTokenRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PutDeviceTokenRequest) throws -> Present.PutDeviceTokenRequest.Builder {
            return try Present.PutDeviceTokenRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDeviceToken {
                jsonMap["deviceToken"] = deviceToken
            }
            if hasApnsEnvironment {
                jsonMap["apnsEnvironment"] = apnsEnvironment.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PutDeviceTokenRequest {
            return try Present.PutDeviceTokenRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PutDeviceTokenRequest {
            return try Present.PutDeviceTokenRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDeviceToken {
                output += "\(indent) deviceToken: \(deviceToken) \n"
            }
            if (hasApnsEnvironment) {
                output += "\(indent) apnsEnvironment: \(apnsEnvironment.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDeviceToken {
                    hashCode = (hashCode &* 31) &+ deviceToken.hashValue
                }
                if hasApnsEnvironment {
                     hashCode = (hashCode &* 31) &+ apnsEnvironment.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PutDeviceTokenRequest"
        }
        override public func className() -> String {
            return "Present.PutDeviceTokenRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PutDeviceTokenRequest = Present.PutDeviceTokenRequest()
            public func getMessage() -> Present.PutDeviceTokenRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Token that identifies the device to the downstream notification service.
            /// Setting this to null clears the device's token; can be used by the client when switching
            /// between staging and production.
            public var deviceToken:String {
                get {
                    return builderResult.deviceToken
                }
                set (value) {
                    builderResult.hasDeviceToken = true
                    builderResult.deviceToken = value
                }
            }
            public var hasDeviceToken:Bool {
                get {
                    return builderResult.hasDeviceToken
                }
            }
            @discardableResult
            public func setDeviceToken(_ value:String) -> Present.PutDeviceTokenRequest.Builder {
                self.deviceToken = value
                return self
            }
            @discardableResult
            public func clearDeviceToken() -> Present.PutDeviceTokenRequest.Builder{
                builderResult.hasDeviceToken = false
                builderResult.deviceToken = ""
                return self
            }
            /// iOS only. Which APNS server to send notifications to.
                public var apnsEnvironment:Present.PutDeviceTokenRequest.ApnsEnvironment {
                    get {
                        return builderResult.apnsEnvironment
                    }
                    set (value) {
                        builderResult.hasApnsEnvironment = true
                        builderResult.apnsEnvironment = value
                    }
                }
                public var hasApnsEnvironment:Bool{
                    get {
                        return builderResult.hasApnsEnvironment
                    }
                }
            @discardableResult
                public func setApnsEnvironment(_ value:Present.PutDeviceTokenRequest.ApnsEnvironment) -> Present.PutDeviceTokenRequest.Builder {
                  self.apnsEnvironment = value
                  return self
                }
            @discardableResult
                public func clearApnsEnvironment() -> Present.PutDeviceTokenRequest.Builder {
                   builderResult.hasApnsEnvironment = false
                   builderResult.apnsEnvironment = .sandbox
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PutDeviceTokenRequest.Builder {
                builderResult = Present.PutDeviceTokenRequest()
                return self
            }
            override public func clone() throws -> Present.PutDeviceTokenRequest.Builder {
                return try Present.PutDeviceTokenRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PutDeviceTokenRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PutDeviceTokenRequest {
                let returnMe:Present.PutDeviceTokenRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PutDeviceTokenRequest) throws -> Present.PutDeviceTokenRequest.Builder {
                if other == Present.PutDeviceTokenRequest() {
                    return self
                }
                if other.hasDeviceToken {
                    deviceToken = other.deviceToken
                }
                if other.hasApnsEnvironment {
                    apnsEnvironment = other.apnsEnvironment
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PutDeviceTokenRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutDeviceTokenRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        deviceToken = try codedInputStream.readString()

                    case 32:
                        let valueIntapnsEnvironment = try codedInputStream.readEnum()
                        if let enumsapnsEnvironment = Present.PutDeviceTokenRequest.ApnsEnvironment(rawValue:valueIntapnsEnvironment){
                            apnsEnvironment = enumsapnsEnvironment
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntapnsEnvironment))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PutDeviceTokenRequest.Builder {
                let resultDecodedBuilder = Present.PutDeviceTokenRequest.Builder()
                if let jsonValueDeviceToken = jsonMap["deviceToken"] as? String {
                    resultDecodedBuilder.deviceToken = jsonValueDeviceToken
                }
                if let jsonValueApnsEnvironment = jsonMap["apnsEnvironment"] as? String {
                    resultDecodedBuilder.apnsEnvironment = try Present.PutDeviceTokenRequest.ApnsEnvironment.fromString(str: jsonValueApnsEnvironment)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PutDeviceTokenRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PutDeviceTokenRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A request that simply identifies a Present user
    final public class UserRequest : GeneratedMessage {

        public static func == (lhs: Present.UserRequest, rhs: Present.UserRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasPhoneNumber == rhs.hasPhoneNumber) && (!lhs.hasPhoneNumber || lhs.phoneNumber == rhs.phoneNumber)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Id {
            case OneOfIdNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfIdNotSet: return false
                default: return true
                }
            }
            case UserId(String)

            public static func getUserId(_ value:Id) -> String? {
                switch value {
                case .UserId(let enumValue): return enumValue
                default: return nil
                }
            }
            case PhoneNumber(String)

            public static func getPhoneNumber(_ value:Id) -> String? {
                switch value {
                case .PhoneNumber(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageId:UserRequest.Id =  UserRequest.Id.OneOfIdNotSet
        public func getOneOfId() ->  UserRequest.Id {
            let copyObjectId = storageId
            return copyObjectId
        }
        public fileprivate(set) var userId:String!{
            get {
                return UserRequest.Id.getUserId(storageId)
            }
            set (newvalue) {
                storageId = UserRequest.Id.UserId(newvalue)
            }
        }
        public fileprivate(set) var hasUserId:Bool {
            get {
                guard let _ = UserRequest.Id.getUserId(storageId) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var phoneNumber:String!{
            get {
                return UserRequest.Id.getPhoneNumber(storageId)
            }
            set (newvalue) {
                storageId = UserRequest.Id.PhoneNumber(newvalue)
            }
        }
        public fileprivate(set) var hasPhoneNumber:Bool {
            get {
                guard let _ = UserRequest.Id.getPhoneNumber(storageId) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeString(fieldNumber: 1, value:userId)
            }
            if hasPhoneNumber {
                try codedOutputStream.writeString(fieldNumber: 2, value:phoneNumber)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeStringSize(fieldNumber: 1)
            }
            if hasPhoneNumber {
                serialize_size += phoneNumber.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UserRequest.Builder {
            return Present.UserRequest.classBuilder() as! Present.UserRequest.Builder
        }
        public func getBuilder() -> Present.UserRequest.Builder {
            return classBuilder() as! Present.UserRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserRequest.Builder()
        }
        public func toBuilder() throws -> Present.UserRequest.Builder {
            return try Present.UserRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UserRequest) throws -> Present.UserRequest.Builder {
            return try Present.UserRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = userId
            }
            if hasPhoneNumber {
                jsonMap["phoneNumber"] = phoneNumber
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UserRequest {
            return try Present.UserRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UserRequest {
            return try Present.UserRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasPhoneNumber {
                output += "\(indent) phoneNumber: \(phoneNumber) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasPhoneNumber {
                    hashCode = (hashCode &* 31) &+ phoneNumber.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UserRequest"
        }
        override public func className() -> String {
            return "Present.UserRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UserRequest = Present.UserRequest()
            public func getMessage() -> Present.UserRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:String {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:String) -> Present.UserRequest.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Present.UserRequest.Builder{
                builderResult.hasUserId = false
                builderResult.userId = ""
                return self
            }
            public var phoneNumber:String {
                get {
                    return builderResult.phoneNumber
                }
                set (value) {
                    builderResult.hasPhoneNumber = true
                    builderResult.phoneNumber = value
                }
            }
            public var hasPhoneNumber:Bool {
                get {
                    return builderResult.hasPhoneNumber
                }
            }
            @discardableResult
            public func setPhoneNumber(_ value:String) -> Present.UserRequest.Builder {
                self.phoneNumber = value
                return self
            }
            @discardableResult
            public func clearPhoneNumber() -> Present.UserRequest.Builder{
                builderResult.hasPhoneNumber = false
                builderResult.phoneNumber = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UserRequest.Builder {
                builderResult = Present.UserRequest()
                return self
            }
            override public func clone() throws -> Present.UserRequest.Builder {
                return try Present.UserRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UserRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UserRequest {
                let returnMe:Present.UserRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UserRequest) throws -> Present.UserRequest.Builder {
                if other == Present.UserRequest() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasPhoneNumber {
                    phoneNumber = other.phoneNumber
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UserRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userId = try codedInputStream.readString()

                    case 18:
                        phoneNumber = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UserRequest.Builder {
                let resultDecodedBuilder = Present.UserRequest.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = jsonValueUserId
                }
                if let jsonValuePhoneNumber = jsonMap["phoneNumber"] as? String {
                    resultDecodedBuilder.phoneNumber = jsonValuePhoneNumber
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UserRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UserRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A request that identifies a list of Present users
    final public class UsersRequest : GeneratedMessage {

        public static func == (lhs: Present.UsersRequest, rhs: Present.UsersRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.userIds == rhs.userIds)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userIds:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !userIds.isEmpty {
                for oneValueuserIds in userIds {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValueuserIds)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeUserIds:Int32 = 0
            for oneValueuserIds in userIds {
                dataSizeUserIds += oneValueuserIds.computeStringSizeNoTag()
            }
            serialize_size += dataSizeUserIds
            serialize_size += 1 * Int32(userIds.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UsersRequest.Builder {
            return Present.UsersRequest.classBuilder() as! Present.UsersRequest.Builder
        }
        public func getBuilder() -> Present.UsersRequest.Builder {
            return classBuilder() as! Present.UsersRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UsersRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UsersRequest.Builder()
        }
        public func toBuilder() throws -> Present.UsersRequest.Builder {
            return try Present.UsersRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UsersRequest) throws -> Present.UsersRequest.Builder {
            return try Present.UsersRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !userIds.isEmpty {
                var jsonArrayUserIds:Array<String> = []
                for oneValueUserIds in userIds {
                    jsonArrayUserIds.append(oneValueUserIds)
                }
                jsonMap["userIds"] = jsonArrayUserIds
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UsersRequest {
            return try Present.UsersRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UsersRequest {
            return try Present.UsersRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var userIdsElementIndex:Int = 0
            for oneValueUserIds in userIds  {
                output += "\(indent) userIds[\(userIdsElementIndex)]: \(oneValueUserIds)\n"
                userIdsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueUserIds in userIds {
                    hashCode = (hashCode &* 31) &+ oneValueUserIds.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UsersRequest"
        }
        override public func className() -> String {
            return "Present.UsersRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UsersRequest = Present.UsersRequest()
            public func getMessage() -> Present.UsersRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userIds:Array<String> {
                get {
                    return builderResult.userIds
                }
                set (array) {
                    builderResult.userIds = array
                }
            }
            @discardableResult
            public func setUserIds(_ value:Array<String>) -> Present.UsersRequest.Builder {
                self.userIds = value
                return self
            }
            @discardableResult
            public func clearUserIds() -> Present.UsersRequest.Builder {
                builderResult.userIds.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UsersRequest.Builder {
                builderResult = Present.UsersRequest()
                return self
            }
            override public func clone() throws -> Present.UsersRequest.Builder {
                return try Present.UsersRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UsersRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UsersRequest {
                let returnMe:Present.UsersRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UsersRequest) throws -> Present.UsersRequest.Builder {
                if other == Present.UsersRequest() {
                    return self
                }
                if !other.userIds.isEmpty {
                    builderResult.userIds += other.userIds
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UsersRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UsersRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userIds += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UsersRequest.Builder {
                let resultDecodedBuilder = Present.UsersRequest.Builder()
                if let jsonValueUserIds = jsonMap["userIds"] as? Array<String> {
                    var jsonArrayUserIds:Array<String> = []
                    for oneValueUserIds in jsonValueUserIds {
                        jsonArrayUserIds.append(oneValueUserIds)
                    }
                    resultDecodedBuilder.userIds = jsonArrayUserIds
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UsersRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UsersRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ComputeUnreadCountsRequest : GeneratedMessage {

        public static func == (lhs: Present.ComputeUnreadCountsRequest, rhs: Present.ComputeUnreadCountsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasUnreadVersion == rhs.hasUnreadVersion) && (!lhs.hasUnreadVersion || lhs.unreadVersion == rhs.unreadVersion)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:String = ""
        public fileprivate(set) var hasUserId:Bool = false

        /// From User.unreadVersion.
        public fileprivate(set) var unreadVersion:UInt32 = UInt32(0)
        public fileprivate(set) var hasUnreadVersion:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasUnreadVersion {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeString(fieldNumber: 1, value:userId)
            }
            if hasUnreadVersion {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:unreadVersion)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeStringSize(fieldNumber: 1)
            }
            if hasUnreadVersion {
                serialize_size += unreadVersion.computeUInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.ComputeUnreadCountsRequest.Builder {
            return Present.ComputeUnreadCountsRequest.classBuilder() as! Present.ComputeUnreadCountsRequest.Builder
        }
        public func getBuilder() -> Present.ComputeUnreadCountsRequest.Builder {
            return classBuilder() as! Present.ComputeUnreadCountsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ComputeUnreadCountsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ComputeUnreadCountsRequest.Builder()
        }
        public func toBuilder() throws -> Present.ComputeUnreadCountsRequest.Builder {
            return try Present.ComputeUnreadCountsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.ComputeUnreadCountsRequest) throws -> Present.ComputeUnreadCountsRequest.Builder {
            return try Present.ComputeUnreadCountsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = userId
            }
            if hasUnreadVersion {
                jsonMap["unreadVersion"] = UInt(unreadVersion)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.ComputeUnreadCountsRequest {
            return try Present.ComputeUnreadCountsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.ComputeUnreadCountsRequest {
            return try Present.ComputeUnreadCountsRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasUnreadVersion {
                output += "\(indent) unreadVersion: \(unreadVersion) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasUnreadVersion {
                    hashCode = (hashCode &* 31) &+ unreadVersion.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.ComputeUnreadCountsRequest"
        }
        override public func className() -> String {
            return "Present.ComputeUnreadCountsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.ComputeUnreadCountsRequest = Present.ComputeUnreadCountsRequest()
            public func getMessage() -> Present.ComputeUnreadCountsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:String {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:String) -> Present.ComputeUnreadCountsRequest.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Present.ComputeUnreadCountsRequest.Builder{
                builderResult.hasUserId = false
                builderResult.userId = ""
                return self
            }
            /// From User.unreadVersion.
            public var unreadVersion:UInt32 {
                get {
                    return builderResult.unreadVersion
                }
                set (value) {
                    builderResult.hasUnreadVersion = true
                    builderResult.unreadVersion = value
                }
            }
            public var hasUnreadVersion:Bool {
                get {
                    return builderResult.hasUnreadVersion
                }
            }
            @discardableResult
            public func setUnreadVersion(_ value:UInt32) -> Present.ComputeUnreadCountsRequest.Builder {
                self.unreadVersion = value
                return self
            }
            @discardableResult
            public func clearUnreadVersion() -> Present.ComputeUnreadCountsRequest.Builder{
                builderResult.hasUnreadVersion = false
                builderResult.unreadVersion = UInt32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.ComputeUnreadCountsRequest.Builder {
                builderResult = Present.ComputeUnreadCountsRequest()
                return self
            }
            override public func clone() throws -> Present.ComputeUnreadCountsRequest.Builder {
                return try Present.ComputeUnreadCountsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.ComputeUnreadCountsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.ComputeUnreadCountsRequest {
                let returnMe:Present.ComputeUnreadCountsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.ComputeUnreadCountsRequest) throws -> Present.ComputeUnreadCountsRequest.Builder {
                if other == Present.ComputeUnreadCountsRequest() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasUnreadVersion {
                    unreadVersion = other.unreadVersion
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.ComputeUnreadCountsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ComputeUnreadCountsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userId = try codedInputStream.readString()

                    case 32:
                        unreadVersion = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.ComputeUnreadCountsRequest.Builder {
                let resultDecodedBuilder = Present.ComputeUnreadCountsRequest.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = jsonValueUserId
                }
                if let jsonValueUnreadVersion = jsonMap["unreadVersion"] as? UInt {
                    resultDecodedBuilder.unreadVersion = UInt32(jsonValueUnreadVersion)
                } else if let jsonValueUnreadVersion = jsonMap["unreadVersion"] as? String {
                    resultDecodedBuilder.unreadVersion = UInt32(jsonValueUnreadVersion)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.ComputeUnreadCountsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.ComputeUnreadCountsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SynchronizeRequest : GeneratedMessage {

        public static func == (lhs: Present.SynchronizeRequest, rhs: Present.SynchronizeRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNotificationsEnabled == rhs.hasNotificationsEnabled) && (!lhs.hasNotificationsEnabled || lhs.notificationsEnabled == rhs.notificationsEnabled)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Whether or not notifications are enabled on this client.
        public fileprivate(set) var notificationsEnabled:Bool = false
        public fileprivate(set) var hasNotificationsEnabled:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNotificationsEnabled {
                try codedOutputStream.writeBool(fieldNumber: 1, value:notificationsEnabled)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNotificationsEnabled {
                serialize_size += notificationsEnabled.computeBoolSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.SynchronizeRequest.Builder {
            return Present.SynchronizeRequest.classBuilder() as! Present.SynchronizeRequest.Builder
        }
        public func getBuilder() -> Present.SynchronizeRequest.Builder {
            return classBuilder() as! Present.SynchronizeRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SynchronizeRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SynchronizeRequest.Builder()
        }
        public func toBuilder() throws -> Present.SynchronizeRequest.Builder {
            return try Present.SynchronizeRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.SynchronizeRequest) throws -> Present.SynchronizeRequest.Builder {
            return try Present.SynchronizeRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNotificationsEnabled {
                jsonMap["notificationsEnabled"] = notificationsEnabled
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.SynchronizeRequest {
            return try Present.SynchronizeRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.SynchronizeRequest {
            return try Present.SynchronizeRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNotificationsEnabled {
                output += "\(indent) notificationsEnabled: \(notificationsEnabled) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNotificationsEnabled {
                    hashCode = (hashCode &* 31) &+ notificationsEnabled.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.SynchronizeRequest"
        }
        override public func className() -> String {
            return "Present.SynchronizeRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.SynchronizeRequest = Present.SynchronizeRequest()
            public func getMessage() -> Present.SynchronizeRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Whether or not notifications are enabled on this client.
            public var notificationsEnabled:Bool {
                get {
                    return builderResult.notificationsEnabled
                }
                set (value) {
                    builderResult.hasNotificationsEnabled = true
                    builderResult.notificationsEnabled = value
                }
            }
            public var hasNotificationsEnabled:Bool {
                get {
                    return builderResult.hasNotificationsEnabled
                }
            }
            @discardableResult
            public func setNotificationsEnabled(_ value:Bool) -> Present.SynchronizeRequest.Builder {
                self.notificationsEnabled = value
                return self
            }
            @discardableResult
            public func clearNotificationsEnabled() -> Present.SynchronizeRequest.Builder{
                builderResult.hasNotificationsEnabled = false
                builderResult.notificationsEnabled = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.SynchronizeRequest.Builder {
                builderResult = Present.SynchronizeRequest()
                return self
            }
            override public func clone() throws -> Present.SynchronizeRequest.Builder {
                return try Present.SynchronizeRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.SynchronizeRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.SynchronizeRequest {
                let returnMe:Present.SynchronizeRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.SynchronizeRequest) throws -> Present.SynchronizeRequest.Builder {
                if other == Present.SynchronizeRequest() {
                    return self
                }
                if other.hasNotificationsEnabled {
                    notificationsEnabled = other.notificationsEnabled
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.SynchronizeRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SynchronizeRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        notificationsEnabled = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.SynchronizeRequest.Builder {
                let resultDecodedBuilder = Present.SynchronizeRequest.Builder()
                if let jsonValueNotificationsEnabled = jsonMap["notificationsEnabled"] as? Bool {
                    resultDecodedBuilder.notificationsEnabled = jsonValueNotificationsEnabled
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.SynchronizeRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.SynchronizeRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Inform the server that the client received a push notification
    final public class NotificationReceivedRequest : GeneratedMessage {

        public static func == (lhs: Present.NotificationReceivedRequest, rhs: Present.NotificationReceivedRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNotification == rhs.hasNotification) && (!lhs.hasNotification || lhs.notification == rhs.notification)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// A JSON string containing the full notification as received
        public fileprivate(set) var notification:String = ""
        public fileprivate(set) var hasNotification:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNotification {
                try codedOutputStream.writeString(fieldNumber: 1, value:notification)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNotification {
                serialize_size += notification.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.NotificationReceivedRequest.Builder {
            return Present.NotificationReceivedRequest.classBuilder() as! Present.NotificationReceivedRequest.Builder
        }
        public func getBuilder() -> Present.NotificationReceivedRequest.Builder {
            return classBuilder() as! Present.NotificationReceivedRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.NotificationReceivedRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.NotificationReceivedRequest.Builder()
        }
        public func toBuilder() throws -> Present.NotificationReceivedRequest.Builder {
            return try Present.NotificationReceivedRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.NotificationReceivedRequest) throws -> Present.NotificationReceivedRequest.Builder {
            return try Present.NotificationReceivedRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNotification {
                jsonMap["notification"] = notification
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.NotificationReceivedRequest {
            return try Present.NotificationReceivedRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.NotificationReceivedRequest {
            return try Present.NotificationReceivedRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNotification {
                output += "\(indent) notification: \(notification) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNotification {
                    hashCode = (hashCode &* 31) &+ notification.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.NotificationReceivedRequest"
        }
        override public func className() -> String {
            return "Present.NotificationReceivedRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.NotificationReceivedRequest = Present.NotificationReceivedRequest()
            public func getMessage() -> Present.NotificationReceivedRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// A JSON string containing the full notification as received
            public var notification:String {
                get {
                    return builderResult.notification
                }
                set (value) {
                    builderResult.hasNotification = true
                    builderResult.notification = value
                }
            }
            public var hasNotification:Bool {
                get {
                    return builderResult.hasNotification
                }
            }
            @discardableResult
            public func setNotification(_ value:String) -> Present.NotificationReceivedRequest.Builder {
                self.notification = value
                return self
            }
            @discardableResult
            public func clearNotification() -> Present.NotificationReceivedRequest.Builder{
                builderResult.hasNotification = false
                builderResult.notification = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.NotificationReceivedRequest.Builder {
                builderResult = Present.NotificationReceivedRequest()
                return self
            }
            override public func clone() throws -> Present.NotificationReceivedRequest.Builder {
                return try Present.NotificationReceivedRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.NotificationReceivedRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.NotificationReceivedRequest {
                let returnMe:Present.NotificationReceivedRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.NotificationReceivedRequest) throws -> Present.NotificationReceivedRequest.Builder {
                if other == Present.NotificationReceivedRequest() {
                    return self
                }
                if other.hasNotification {
                    notification = other.notification
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.NotificationReceivedRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.NotificationReceivedRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        notification = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.NotificationReceivedRequest.Builder {
                let resultDecodedBuilder = Present.NotificationReceivedRequest.Builder()
                if let jsonValueNotification = jsonMap["notification"] as? String {
                    resultDecodedBuilder.notification = jsonValueNotification
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.NotificationReceivedRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.NotificationReceivedRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UserSearchRequest : GeneratedMessage {

        public static func == (lhs: Present.UserSearchRequest, rhs: Present.UserSearchRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSearchText == rhs.hasSearchText) && (!lhs.hasSearchText || lhs.searchText == rhs.searchText)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var searchText:String = ""
        public fileprivate(set) var hasSearchText:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasSearchText {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSearchText {
                try codedOutputStream.writeString(fieldNumber: 1, value:searchText)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSearchText {
                serialize_size += searchText.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UserSearchRequest.Builder {
            return Present.UserSearchRequest.classBuilder() as! Present.UserSearchRequest.Builder
        }
        public func getBuilder() -> Present.UserSearchRequest.Builder {
            return classBuilder() as! Present.UserSearchRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserSearchRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UserSearchRequest.Builder()
        }
        public func toBuilder() throws -> Present.UserSearchRequest.Builder {
            return try Present.UserSearchRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UserSearchRequest) throws -> Present.UserSearchRequest.Builder {
            return try Present.UserSearchRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSearchText {
                jsonMap["searchText"] = searchText
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UserSearchRequest {
            return try Present.UserSearchRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UserSearchRequest {
            return try Present.UserSearchRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSearchText {
                output += "\(indent) searchText: \(searchText) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSearchText {
                    hashCode = (hashCode &* 31) &+ searchText.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UserSearchRequest"
        }
        override public func className() -> String {
            return "Present.UserSearchRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UserSearchRequest = Present.UserSearchRequest()
            public func getMessage() -> Present.UserSearchRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var searchText:String {
                get {
                    return builderResult.searchText
                }
                set (value) {
                    builderResult.hasSearchText = true
                    builderResult.searchText = value
                }
            }
            public var hasSearchText:Bool {
                get {
                    return builderResult.hasSearchText
                }
            }
            @discardableResult
            public func setSearchText(_ value:String) -> Present.UserSearchRequest.Builder {
                self.searchText = value
                return self
            }
            @discardableResult
            public func clearSearchText() -> Present.UserSearchRequest.Builder{
                builderResult.hasSearchText = false
                builderResult.searchText = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UserSearchRequest.Builder {
                builderResult = Present.UserSearchRequest()
                return self
            }
            override public func clone() throws -> Present.UserSearchRequest.Builder {
                return try Present.UserSearchRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UserSearchRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UserSearchRequest {
                let returnMe:Present.UserSearchRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UserSearchRequest) throws -> Present.UserSearchRequest.Builder {
                if other == Present.UserSearchRequest() {
                    return self
                }
                if other.hasSearchText {
                    searchText = other.searchText
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UserSearchRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserSearchRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        searchText = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UserSearchRequest.Builder {
                let resultDecodedBuilder = Present.UserSearchRequest.Builder()
                if let jsonValueSearchText = jsonMap["searchText"] as? String {
                    resultDecodedBuilder.searchText = jsonValueSearchText
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UserSearchRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UserSearchRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnreadCounts : GeneratedMessage {

        public static func == (lhs: Present.UnreadCounts, rhs: Present.UnreadCounts) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTotal == rhs.hasTotal) && (!lhs.hasTotal || lhs.total == rhs.total)
            fieldCheck = fieldCheck && (lhs.hasGroups == rhs.hasGroups) && (!lhs.hasGroups || lhs.groups == rhs.groups)
            fieldCheck = fieldCheck && (lhs.hasIncomingFriendRequests == rhs.hasIncomingFriendRequests) && (!lhs.hasIncomingFriendRequests || lhs.incomingFriendRequests == rhs.incomingFriendRequests)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var total:UInt32 = UInt32(0)
        public fileprivate(set) var hasTotal:Bool = false

        public fileprivate(set) var groups:UInt32 = UInt32(0)
        public fileprivate(set) var hasGroups:Bool = false

        /// field 3 was used for chats
        public fileprivate(set) var incomingFriendRequests:UInt32 = UInt32(0)
        public fileprivate(set) var hasIncomingFriendRequests:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasTotal {
                return false
            }
            if !hasGroups {
                return false
            }
            if !hasIncomingFriendRequests {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTotal {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:total)
            }
            if hasGroups {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:groups)
            }
            if hasIncomingFriendRequests {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:incomingFriendRequests)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTotal {
                serialize_size += total.computeUInt32Size(fieldNumber: 1)
            }
            if hasGroups {
                serialize_size += groups.computeUInt32Size(fieldNumber: 2)
            }
            if hasIncomingFriendRequests {
                serialize_size += incomingFriendRequests.computeUInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UnreadCounts.Builder {
            return Present.UnreadCounts.classBuilder() as! Present.UnreadCounts.Builder
        }
        public func getBuilder() -> Present.UnreadCounts.Builder {
            return classBuilder() as! Present.UnreadCounts.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UnreadCounts.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UnreadCounts.Builder()
        }
        public func toBuilder() throws -> Present.UnreadCounts.Builder {
            return try Present.UnreadCounts.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UnreadCounts) throws -> Present.UnreadCounts.Builder {
            return try Present.UnreadCounts.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTotal {
                jsonMap["total"] = UInt(total)
            }
            if hasGroups {
                jsonMap["groups"] = UInt(groups)
            }
            if hasIncomingFriendRequests {
                jsonMap["incomingFriendRequests"] = UInt(incomingFriendRequests)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UnreadCounts {
            return try Present.UnreadCounts.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UnreadCounts {
            return try Present.UnreadCounts.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTotal {
                output += "\(indent) total: \(total) \n"
            }
            if hasGroups {
                output += "\(indent) groups: \(groups) \n"
            }
            if hasIncomingFriendRequests {
                output += "\(indent) incomingFriendRequests: \(incomingFriendRequests) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTotal {
                    hashCode = (hashCode &* 31) &+ total.hashValue
                }
                if hasGroups {
                    hashCode = (hashCode &* 31) &+ groups.hashValue
                }
                if hasIncomingFriendRequests {
                    hashCode = (hashCode &* 31) &+ incomingFriendRequests.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UnreadCounts"
        }
        override public func className() -> String {
            return "Present.UnreadCounts"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UnreadCounts = Present.UnreadCounts()
            public func getMessage() -> Present.UnreadCounts {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var total:UInt32 {
                get {
                    return builderResult.total
                }
                set (value) {
                    builderResult.hasTotal = true
                    builderResult.total = value
                }
            }
            public var hasTotal:Bool {
                get {
                    return builderResult.hasTotal
                }
            }
            @discardableResult
            public func setTotal(_ value:UInt32) -> Present.UnreadCounts.Builder {
                self.total = value
                return self
            }
            @discardableResult
            public func clearTotal() -> Present.UnreadCounts.Builder{
                builderResult.hasTotal = false
                builderResult.total = UInt32(0)
                return self
            }
            public var groups:UInt32 {
                get {
                    return builderResult.groups
                }
                set (value) {
                    builderResult.hasGroups = true
                    builderResult.groups = value
                }
            }
            public var hasGroups:Bool {
                get {
                    return builderResult.hasGroups
                }
            }
            @discardableResult
            public func setGroups(_ value:UInt32) -> Present.UnreadCounts.Builder {
                self.groups = value
                return self
            }
            @discardableResult
            public func clearGroups() -> Present.UnreadCounts.Builder{
                builderResult.hasGroups = false
                builderResult.groups = UInt32(0)
                return self
            }
            /// field 3 was used for chats
            public var incomingFriendRequests:UInt32 {
                get {
                    return builderResult.incomingFriendRequests
                }
                set (value) {
                    builderResult.hasIncomingFriendRequests = true
                    builderResult.incomingFriendRequests = value
                }
            }
            public var hasIncomingFriendRequests:Bool {
                get {
                    return builderResult.hasIncomingFriendRequests
                }
            }
            @discardableResult
            public func setIncomingFriendRequests(_ value:UInt32) -> Present.UnreadCounts.Builder {
                self.incomingFriendRequests = value
                return self
            }
            @discardableResult
            public func clearIncomingFriendRequests() -> Present.UnreadCounts.Builder{
                builderResult.hasIncomingFriendRequests = false
                builderResult.incomingFriendRequests = UInt32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UnreadCounts.Builder {
                builderResult = Present.UnreadCounts()
                return self
            }
            override public func clone() throws -> Present.UnreadCounts.Builder {
                return try Present.UnreadCounts.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UnreadCounts {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UnreadCounts {
                let returnMe:Present.UnreadCounts = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UnreadCounts) throws -> Present.UnreadCounts.Builder {
                if other == Present.UnreadCounts() {
                    return self
                }
                if other.hasTotal {
                    total = other.total
                }
                if other.hasGroups {
                    groups = other.groups
                }
                if other.hasIncomingFriendRequests {
                    incomingFriendRequests = other.incomingFriendRequests
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UnreadCounts.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UnreadCounts.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        total = try codedInputStream.readUInt32()

                    case 16:
                        groups = try codedInputStream.readUInt32()

                    case 32:
                        incomingFriendRequests = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UnreadCounts.Builder {
                let resultDecodedBuilder = Present.UnreadCounts.Builder()
                if let jsonValueTotal = jsonMap["total"] as? UInt {
                    resultDecodedBuilder.total = UInt32(jsonValueTotal)
                } else if let jsonValueTotal = jsonMap["total"] as? String {
                    resultDecodedBuilder.total = UInt32(jsonValueTotal)!
                }
                if let jsonValueGroups = jsonMap["groups"] as? UInt {
                    resultDecodedBuilder.groups = UInt32(jsonValueGroups)
                } else if let jsonValueGroups = jsonMap["groups"] as? String {
                    resultDecodedBuilder.groups = UInt32(jsonValueGroups)!
                }
                if let jsonValueIncomingFriendRequests = jsonMap["incomingFriendRequests"] as? UInt {
                    resultDecodedBuilder.incomingFriendRequests = UInt32(jsonValueIncomingFriendRequests)
                } else if let jsonValueIncomingFriendRequests = jsonMap["incomingFriendRequests"] as? String {
                    resultDecodedBuilder.incomingFriendRequests = UInt32(jsonValueIncomingFriendRequests)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UnreadCounts.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UnreadCounts.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SummaryRequest : GeneratedMessage {

        public static func == (lhs: Present.SummaryRequest, rhs: Present.SummaryRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:String = ""
        public fileprivate(set) var hasUserId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeString(fieldNumber: 1, value:userId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.SummaryRequest.Builder {
            return Present.SummaryRequest.classBuilder() as! Present.SummaryRequest.Builder
        }
        public func getBuilder() -> Present.SummaryRequest.Builder {
            return classBuilder() as! Present.SummaryRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SummaryRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SummaryRequest.Builder()
        }
        public func toBuilder() throws -> Present.SummaryRequest.Builder {
            return try Present.SummaryRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.SummaryRequest) throws -> Present.SummaryRequest.Builder {
            return try Present.SummaryRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = userId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.SummaryRequest {
            return try Present.SummaryRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.SummaryRequest {
            return try Present.SummaryRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.SummaryRequest"
        }
        override public func className() -> String {
            return "Present.SummaryRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.SummaryRequest = Present.SummaryRequest()
            public func getMessage() -> Present.SummaryRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:String {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:String) -> Present.SummaryRequest.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Present.SummaryRequest.Builder{
                builderResult.hasUserId = false
                builderResult.userId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.SummaryRequest.Builder {
                builderResult = Present.SummaryRequest()
                return self
            }
            override public func clone() throws -> Present.SummaryRequest.Builder {
                return try Present.SummaryRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.SummaryRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.SummaryRequest {
                let returnMe:Present.SummaryRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.SummaryRequest) throws -> Present.SummaryRequest.Builder {
                if other == Present.SummaryRequest() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.SummaryRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SummaryRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.SummaryRequest.Builder {
                let resultDecodedBuilder = Present.SummaryRequest.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = jsonValueUserId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.SummaryRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.SummaryRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class VerifyRequest : GeneratedMessage {

        public static func == (lhs: Present.VerifyRequest, rhs: Present.VerifyRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
            fieldCheck = fieldCheck && (lhs.hasCode == rhs.hasCode) && (!lhs.hasCode || lhs.code == rhs.code)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Value {
            case OneOfValueNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfValueNotSet: return false
                default: return true
                }
            }
            case Url(String)

            public static func getUrl(_ value:Value) -> String? {
                switch value {
                case .Url(let enumValue): return enumValue
                default: return nil
                }
            }
            case Code(String)

            public static func getCode(_ value:Value) -> String? {
                switch value {
                case .Code(let enumValue): return enumValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageValue:VerifyRequest.Value =  VerifyRequest.Value.OneOfValueNotSet
        public func getOneOfValue() ->  VerifyRequest.Value {
            let copyObjectValue = storageValue
            return copyObjectValue
        }
        /// https://present.co/v/[code]
        public fileprivate(set) var url:String!{
            get {
                return VerifyRequest.Value.getUrl(storageValue)
            }
            set (newvalue) {
                storageValue = VerifyRequest.Value.Url(newvalue)
            }
        }
        public fileprivate(set) var hasUrl:Bool {
            get {
                guard let _ = VerifyRequest.Value.getUrl(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        /// N-digit code typed by user. Length should match VerificationRequestResponse.codeLength.
        public fileprivate(set) var code:String!{
            get {
                return VerifyRequest.Value.getCode(storageValue)
            }
            set (newvalue) {
                storageValue = VerifyRequest.Value.Code(newvalue)
            }
        }
        public fileprivate(set) var hasCode:Bool {
            get {
                guard let _ = VerifyRequest.Value.getCode(storageValue) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUrl {
                try codedOutputStream.writeString(fieldNumber: 1, value:url)
            }
            if hasCode {
                try codedOutputStream.writeString(fieldNumber: 2, value:code)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUrl {
                serialize_size += url.computeStringSize(fieldNumber: 1)
            }
            if hasCode {
                serialize_size += code.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.VerifyRequest.Builder {
            return Present.VerifyRequest.classBuilder() as! Present.VerifyRequest.Builder
        }
        public func getBuilder() -> Present.VerifyRequest.Builder {
            return classBuilder() as! Present.VerifyRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.VerifyRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.VerifyRequest.Builder()
        }
        public func toBuilder() throws -> Present.VerifyRequest.Builder {
            return try Present.VerifyRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.VerifyRequest) throws -> Present.VerifyRequest.Builder {
            return try Present.VerifyRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUrl {
                jsonMap["url"] = url
            }
            if hasCode {
                jsonMap["code"] = code
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.VerifyRequest {
            return try Present.VerifyRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.VerifyRequest {
            return try Present.VerifyRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUrl {
                output += "\(indent) url: \(url) \n"
            }
            if hasCode {
                output += "\(indent) code: \(code) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUrl {
                    hashCode = (hashCode &* 31) &+ url.hashValue
                }
                if hasCode {
                    hashCode = (hashCode &* 31) &+ code.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.VerifyRequest"
        }
        override public func className() -> String {
            return "Present.VerifyRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.VerifyRequest = Present.VerifyRequest()
            public func getMessage() -> Present.VerifyRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// https://present.co/v/[code]
            public var url:String {
                get {
                    return builderResult.url
                }
                set (value) {
                    builderResult.hasUrl = true
                    builderResult.url = value
                }
            }
            public var hasUrl:Bool {
                get {
                    return builderResult.hasUrl
                }
            }
            @discardableResult
            public func setUrl(_ value:String) -> Present.VerifyRequest.Builder {
                self.url = value
                return self
            }
            @discardableResult
            public func clearUrl() -> Present.VerifyRequest.Builder{
                builderResult.hasUrl = false
                builderResult.url = ""
                return self
            }
            /// N-digit code typed by user. Length should match VerificationRequestResponse.codeLength.
            public var code:String {
                get {
                    return builderResult.code
                }
                set (value) {
                    builderResult.hasCode = true
                    builderResult.code = value
                }
            }
            public var hasCode:Bool {
                get {
                    return builderResult.hasCode
                }
            }
            @discardableResult
            public func setCode(_ value:String) -> Present.VerifyRequest.Builder {
                self.code = value
                return self
            }
            @discardableResult
            public func clearCode() -> Present.VerifyRequest.Builder{
                builderResult.hasCode = false
                builderResult.code = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.VerifyRequest.Builder {
                builderResult = Present.VerifyRequest()
                return self
            }
            override public func clone() throws -> Present.VerifyRequest.Builder {
                return try Present.VerifyRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.VerifyRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.VerifyRequest {
                let returnMe:Present.VerifyRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.VerifyRequest) throws -> Present.VerifyRequest.Builder {
                if other == Present.VerifyRequest() {
                    return self
                }
                if other.hasUrl {
                    url = other.url
                }
                if other.hasCode {
                    code = other.code
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.VerifyRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.VerifyRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        url = try codedInputStream.readString()

                    case 18:
                        code = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.VerifyRequest.Builder {
                let resultDecodedBuilder = Present.VerifyRequest.Builder()
                if let jsonValueUrl = jsonMap["url"] as? String {
                    resultDecodedBuilder.url = jsonValueUrl
                }
                if let jsonValueCode = jsonMap["code"] as? String {
                    resultDecodedBuilder.code = jsonValueCode
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.VerifyRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.VerifyRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SpacesResponse : GeneratedMessage {

        public static func == (lhs: Present.SpacesResponse, rhs: Present.SpacesResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.spaces == rhs.spaces)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var spaces:Array<Present.SpaceResponse>  = Array<Present.SpaceResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitSpaces:Bool = true
            for oneElementSpaces in spaces {
                if !oneElementSpaces.isInitialized() {
                    isInitSpaces = false
                    break 
                }
            }
            if !isInitSpaces {
                return isInitSpaces
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementSpaces in spaces {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementSpaces)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementSpaces in spaces {
                serialize_size += oneElementSpaces.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.SpacesResponse.Builder {
            return Present.SpacesResponse.classBuilder() as! Present.SpacesResponse.Builder
        }
        public func getBuilder() -> Present.SpacesResponse.Builder {
            return classBuilder() as! Present.SpacesResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SpacesResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SpacesResponse.Builder()
        }
        public func toBuilder() throws -> Present.SpacesResponse.Builder {
            return try Present.SpacesResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.SpacesResponse) throws -> Present.SpacesResponse.Builder {
            return try Present.SpacesResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !spaces.isEmpty {
                var jsonArraySpaces:Array<Dictionary<String,Any>> = []
                for oneValueSpaces in spaces {
                    let ecodedMessageSpaces = try oneValueSpaces.encode()
                    jsonArraySpaces.append(ecodedMessageSpaces)
                }
                jsonMap["spaces"] = jsonArraySpaces
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.SpacesResponse {
            return try Present.SpacesResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.SpacesResponse {
            return try Present.SpacesResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var spacesElementIndex:Int = 0
            for oneElementSpaces in spaces {
                output += "\(indent) spaces[\(spacesElementIndex)] {\n"
                output += try oneElementSpaces.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                spacesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementSpaces in spaces {
                    hashCode = (hashCode &* 31) &+ oneElementSpaces.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.SpacesResponse"
        }
        override public func className() -> String {
            return "Present.SpacesResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.SpacesResponse = Present.SpacesResponse()
            public func getMessage() -> Present.SpacesResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var spaces:Array<Present.SpaceResponse> {
                get {
                    return builderResult.spaces
                }
                set (value) {
                    builderResult.spaces = value
                }
            }
            @discardableResult
            public func setSpaces(_ value:Array<Present.SpaceResponse>) -> Present.SpacesResponse.Builder {
                self.spaces = value
                return self
            }
            @discardableResult
            public func clearSpaces() -> Present.SpacesResponse.Builder {
                builderResult.spaces.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.SpacesResponse.Builder {
                builderResult = Present.SpacesResponse()
                return self
            }
            override public func clone() throws -> Present.SpacesResponse.Builder {
                return try Present.SpacesResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.SpacesResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.SpacesResponse {
                let returnMe:Present.SpacesResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.SpacesResponse) throws -> Present.SpacesResponse.Builder {
                if other == Present.SpacesResponse() {
                    return self
                }
                if !other.spaces.isEmpty  {
                     builderResult.spaces += other.spaces
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.SpacesResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SpacesResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.SpaceResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        spaces.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.SpacesResponse.Builder {
                let resultDecodedBuilder = Present.SpacesResponse.Builder()
                if let jsonValueSpaces = jsonMap["spaces"] as? Array<Dictionary<String,Any>> {
                    var jsonArraySpaces:Array<Present.SpaceResponse> = []
                    for oneValueSpaces in jsonValueSpaces {
                        let messageFromStringSpaces = try Present.SpaceResponse.Builder.decodeToBuilder(jsonMap:oneValueSpaces).build()

                        jsonArraySpaces.append(messageFromStringSpaces)
                    }
                    resultDecodedBuilder.spaces = jsonArraySpaces
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.SpacesResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.SpacesResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ValidStateTransitionResponse : GeneratedMessage {

        public static func == (lhs: Present.ValidStateTransitionResponse, rhs: Present.ValidStateTransitionResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
            fieldCheck = fieldCheck && (lhs.hasVerb == rhs.hasVerb) && (!lhs.hasVerb || lhs.verb == rhs.verb)
            fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var id:String = ""
        public fileprivate(set) var hasId:Bool = false

        /// Action of transitioning to this state. Intended for use in UI.
        public fileprivate(set) var verb:String = ""
        public fileprivate(set) var hasVerb:Bool = false

        /// Describes this state.
        public fileprivate(set) var description_:String = ""
        public fileprivate(set) var hasDescription:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasId {
                return false
            }
            if !hasVerb {
                return false
            }
            if !hasDescription {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasId {
                try codedOutputStream.writeString(fieldNumber: 1, value:id)
            }
            if hasVerb {
                try codedOutputStream.writeString(fieldNumber: 2, value:verb)
            }
            if hasDescription {
                try codedOutputStream.writeString(fieldNumber: 3, value:description_)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasId {
                serialize_size += id.computeStringSize(fieldNumber: 1)
            }
            if hasVerb {
                serialize_size += verb.computeStringSize(fieldNumber: 2)
            }
            if hasDescription {
                serialize_size += description_.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.ValidStateTransitionResponse.Builder {
            return Present.ValidStateTransitionResponse.classBuilder() as! Present.ValidStateTransitionResponse.Builder
        }
        public func getBuilder() -> Present.ValidStateTransitionResponse.Builder {
            return classBuilder() as! Present.ValidStateTransitionResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ValidStateTransitionResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ValidStateTransitionResponse.Builder()
        }
        public func toBuilder() throws -> Present.ValidStateTransitionResponse.Builder {
            return try Present.ValidStateTransitionResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.ValidStateTransitionResponse) throws -> Present.ValidStateTransitionResponse.Builder {
            return try Present.ValidStateTransitionResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasId {
                jsonMap["id"] = id
            }
            if hasVerb {
                jsonMap["verb"] = verb
            }
            if hasDescription {
                jsonMap["description"] = description_
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.ValidStateTransitionResponse {
            return try Present.ValidStateTransitionResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.ValidStateTransitionResponse {
            return try Present.ValidStateTransitionResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasId {
                output += "\(indent) id: \(id) \n"
            }
            if hasVerb {
                output += "\(indent) verb: \(verb) \n"
            }
            if hasDescription {
                output += "\(indent) description: \(description_) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasId {
                    hashCode = (hashCode &* 31) &+ id.hashValue
                }
                if hasVerb {
                    hashCode = (hashCode &* 31) &+ verb.hashValue
                }
                if hasDescription {
                    hashCode = (hashCode &* 31) &+ description_.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.ValidStateTransitionResponse"
        }
        override public func className() -> String {
            return "Present.ValidStateTransitionResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.ValidStateTransitionResponse = Present.ValidStateTransitionResponse()
            public func getMessage() -> Present.ValidStateTransitionResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var id:String {
                get {
                    return builderResult.id
                }
                set (value) {
                    builderResult.hasId = true
                    builderResult.id = value
                }
            }
            public var hasId:Bool {
                get {
                    return builderResult.hasId
                }
            }
            @discardableResult
            public func setId(_ value:String) -> Present.ValidStateTransitionResponse.Builder {
                self.id = value
                return self
            }
            @discardableResult
            public func clearId() -> Present.ValidStateTransitionResponse.Builder{
                builderResult.hasId = false
                builderResult.id = ""
                return self
            }
            /// Action of transitioning to this state. Intended for use in UI.
            public var verb:String {
                get {
                    return builderResult.verb
                }
                set (value) {
                    builderResult.hasVerb = true
                    builderResult.verb = value
                }
            }
            public var hasVerb:Bool {
                get {
                    return builderResult.hasVerb
                }
            }
            @discardableResult
            public func setVerb(_ value:String) -> Present.ValidStateTransitionResponse.Builder {
                self.verb = value
                return self
            }
            @discardableResult
            public func clearVerb() -> Present.ValidStateTransitionResponse.Builder{
                builderResult.hasVerb = false
                builderResult.verb = ""
                return self
            }
            /// Describes this state.
            public var description_:String {
                get {
                    return builderResult.description_
                }
                set (value) {
                    builderResult.hasDescription = true
                    builderResult.description_ = value
                }
            }
            public var hasDescription:Bool {
                get {
                    return builderResult.hasDescription
                }
            }
            @discardableResult
            public func setDescription(_ value:String) -> Present.ValidStateTransitionResponse.Builder {
                self.description_ = value
                return self
            }
            @discardableResult
            public func clearDescription() -> Present.ValidStateTransitionResponse.Builder{
                builderResult.hasDescription = false
                builderResult.description_ = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.ValidStateTransitionResponse.Builder {
                builderResult = Present.ValidStateTransitionResponse()
                return self
            }
            override public func clone() throws -> Present.ValidStateTransitionResponse.Builder {
                return try Present.ValidStateTransitionResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.ValidStateTransitionResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.ValidStateTransitionResponse {
                let returnMe:Present.ValidStateTransitionResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.ValidStateTransitionResponse) throws -> Present.ValidStateTransitionResponse.Builder {
                if other == Present.ValidStateTransitionResponse() {
                    return self
                }
                if other.hasId {
                    id = other.id
                }
                if other.hasVerb {
                    verb = other.verb
                }
                if other.hasDescription {
                    description_ = other.description_
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.ValidStateTransitionResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ValidStateTransitionResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        id = try codedInputStream.readString()

                    case 18:
                        verb = try codedInputStream.readString()

                    case 26:
                        description_ = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.ValidStateTransitionResponse.Builder {
                let resultDecodedBuilder = Present.ValidStateTransitionResponse.Builder()
                if let jsonValueId = jsonMap["id"] as? String {
                    resultDecodedBuilder.id = jsonValueId
                }
                if let jsonValueVerb = jsonMap["verb"] as? String {
                    resultDecodedBuilder.verb = jsonValueVerb
                }
                if let jsonValueDescription = jsonMap["description"] as? String {
                    resultDecodedBuilder.description_ = jsonValueDescription
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.ValidStateTransitionResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.ValidStateTransitionResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ValidStateTransitionsResponse : GeneratedMessage {

        public static func == (lhs: Present.ValidStateTransitionsResponse, rhs: Present.ValidStateTransitionsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.validStateTransitions == rhs.validStateTransitions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var validStateTransitions:Array<Present.ValidStateTransitionResponse>  = Array<Present.ValidStateTransitionResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitValidStateTransitions:Bool = true
            for oneElementValidStateTransitions in validStateTransitions {
                if !oneElementValidStateTransitions.isInitialized() {
                    isInitValidStateTransitions = false
                    break 
                }
            }
            if !isInitValidStateTransitions {
                return isInitValidStateTransitions
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementValidStateTransitions in validStateTransitions {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementValidStateTransitions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementValidStateTransitions in validStateTransitions {
                serialize_size += oneElementValidStateTransitions.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.ValidStateTransitionsResponse.Builder {
            return Present.ValidStateTransitionsResponse.classBuilder() as! Present.ValidStateTransitionsResponse.Builder
        }
        public func getBuilder() -> Present.ValidStateTransitionsResponse.Builder {
            return classBuilder() as! Present.ValidStateTransitionsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ValidStateTransitionsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ValidStateTransitionsResponse.Builder()
        }
        public func toBuilder() throws -> Present.ValidStateTransitionsResponse.Builder {
            return try Present.ValidStateTransitionsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.ValidStateTransitionsResponse) throws -> Present.ValidStateTransitionsResponse.Builder {
            return try Present.ValidStateTransitionsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !validStateTransitions.isEmpty {
                var jsonArrayValidStateTransitions:Array<Dictionary<String,Any>> = []
                for oneValueValidStateTransitions in validStateTransitions {
                    let ecodedMessageValidStateTransitions = try oneValueValidStateTransitions.encode()
                    jsonArrayValidStateTransitions.append(ecodedMessageValidStateTransitions)
                }
                jsonMap["validStateTransitions"] = jsonArrayValidStateTransitions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.ValidStateTransitionsResponse {
            return try Present.ValidStateTransitionsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.ValidStateTransitionsResponse {
            return try Present.ValidStateTransitionsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var validStateTransitionsElementIndex:Int = 0
            for oneElementValidStateTransitions in validStateTransitions {
                output += "\(indent) validStateTransitions[\(validStateTransitionsElementIndex)] {\n"
                output += try oneElementValidStateTransitions.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                validStateTransitionsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementValidStateTransitions in validStateTransitions {
                    hashCode = (hashCode &* 31) &+ oneElementValidStateTransitions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.ValidStateTransitionsResponse"
        }
        override public func className() -> String {
            return "Present.ValidStateTransitionsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.ValidStateTransitionsResponse = Present.ValidStateTransitionsResponse()
            public func getMessage() -> Present.ValidStateTransitionsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var validStateTransitions:Array<Present.ValidStateTransitionResponse> {
                get {
                    return builderResult.validStateTransitions
                }
                set (value) {
                    builderResult.validStateTransitions = value
                }
            }
            @discardableResult
            public func setValidStateTransitions(_ value:Array<Present.ValidStateTransitionResponse>) -> Present.ValidStateTransitionsResponse.Builder {
                self.validStateTransitions = value
                return self
            }
            @discardableResult
            public func clearValidStateTransitions() -> Present.ValidStateTransitionsResponse.Builder {
                builderResult.validStateTransitions.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.ValidStateTransitionsResponse.Builder {
                builderResult = Present.ValidStateTransitionsResponse()
                return self
            }
            override public func clone() throws -> Present.ValidStateTransitionsResponse.Builder {
                return try Present.ValidStateTransitionsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.ValidStateTransitionsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.ValidStateTransitionsResponse {
                let returnMe:Present.ValidStateTransitionsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.ValidStateTransitionsResponse) throws -> Present.ValidStateTransitionsResponse.Builder {
                if other == Present.ValidStateTransitionsResponse() {
                    return self
                }
                if !other.validStateTransitions.isEmpty  {
                     builderResult.validStateTransitions += other.validStateTransitions
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.ValidStateTransitionsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ValidStateTransitionsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.ValidStateTransitionResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        validStateTransitions.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.ValidStateTransitionsResponse.Builder {
                let resultDecodedBuilder = Present.ValidStateTransitionsResponse.Builder()
                if let jsonValueValidStateTransitions = jsonMap["validStateTransitions"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayValidStateTransitions:Array<Present.ValidStateTransitionResponse> = []
                    for oneValueValidStateTransitions in jsonValueValidStateTransitions {
                        let messageFromStringValidStateTransitions = try Present.ValidStateTransitionResponse.Builder.decodeToBuilder(jsonMap:oneValueValidStateTransitions).build()

                        jsonArrayValidStateTransitions.append(messageFromStringValidStateTransitions)
                    }
                    resultDecodedBuilder.validStateTransitions = jsonArrayValidStateTransitions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.ValidStateTransitionsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.ValidStateTransitionsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransitionStateRequest : GeneratedMessage {

        public static func == (lhs: Present.TransitionStateRequest, rhs: Present.TransitionStateRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasStateId == rhs.hasStateId) && (!lhs.hasStateId || lhs.stateId == rhs.stateId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:String = ""
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var stateId:String = ""
        public fileprivate(set) var hasStateId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasStateId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeString(fieldNumber: 1, value:userId)
            }
            if hasStateId {
                try codedOutputStream.writeString(fieldNumber: 2, value:stateId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeStringSize(fieldNumber: 1)
            }
            if hasStateId {
                serialize_size += stateId.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.TransitionStateRequest.Builder {
            return Present.TransitionStateRequest.classBuilder() as! Present.TransitionStateRequest.Builder
        }
        public func getBuilder() -> Present.TransitionStateRequest.Builder {
            return classBuilder() as! Present.TransitionStateRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.TransitionStateRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.TransitionStateRequest.Builder()
        }
        public func toBuilder() throws -> Present.TransitionStateRequest.Builder {
            return try Present.TransitionStateRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.TransitionStateRequest) throws -> Present.TransitionStateRequest.Builder {
            return try Present.TransitionStateRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = userId
            }
            if hasStateId {
                jsonMap["stateId"] = stateId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.TransitionStateRequest {
            return try Present.TransitionStateRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.TransitionStateRequest {
            return try Present.TransitionStateRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasStateId {
                output += "\(indent) stateId: \(stateId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasStateId {
                    hashCode = (hashCode &* 31) &+ stateId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.TransitionStateRequest"
        }
        override public func className() -> String {
            return "Present.TransitionStateRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.TransitionStateRequest = Present.TransitionStateRequest()
            public func getMessage() -> Present.TransitionStateRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:String {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:String) -> Present.TransitionStateRequest.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Present.TransitionStateRequest.Builder{
                builderResult.hasUserId = false
                builderResult.userId = ""
                return self
            }
            public var stateId:String {
                get {
                    return builderResult.stateId
                }
                set (value) {
                    builderResult.hasStateId = true
                    builderResult.stateId = value
                }
            }
            public var hasStateId:Bool {
                get {
                    return builderResult.hasStateId
                }
            }
            @discardableResult
            public func setStateId(_ value:String) -> Present.TransitionStateRequest.Builder {
                self.stateId = value
                return self
            }
            @discardableResult
            public func clearStateId() -> Present.TransitionStateRequest.Builder{
                builderResult.hasStateId = false
                builderResult.stateId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.TransitionStateRequest.Builder {
                builderResult = Present.TransitionStateRequest()
                return self
            }
            override public func clone() throws -> Present.TransitionStateRequest.Builder {
                return try Present.TransitionStateRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.TransitionStateRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.TransitionStateRequest {
                let returnMe:Present.TransitionStateRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.TransitionStateRequest) throws -> Present.TransitionStateRequest.Builder {
                if other == Present.TransitionStateRequest() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasStateId {
                    stateId = other.stateId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.TransitionStateRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.TransitionStateRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userId = try codedInputStream.readString()

                    case 18:
                        stateId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.TransitionStateRequest.Builder {
                let resultDecodedBuilder = Present.TransitionStateRequest.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = jsonValueUserId
                }
                if let jsonValueStateId = jsonMap["stateId"] as? String {
                    resultDecodedBuilder.stateId = jsonValueStateId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.TransitionStateRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.TransitionStateRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class AdminSearchRequest : GeneratedMessage {

        public static func == (lhs: Present.AdminSearchRequest, rhs: Present.AdminSearchRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCursor == rhs.hasCursor) && (!lhs.hasCursor || lhs.cursor == rhs.cursor)
            fieldCheck = fieldCheck && (lhs.hasNumResults == rhs.hasNumResults) && (!lhs.hasNumResults || lhs.numResults == rhs.numResults)
            fieldCheck = fieldCheck && (lhs.hasDirection == rhs.hasDirection) && (!lhs.hasDirection || lhs.direction == rhs.direction)
            fieldCheck = fieldCheck && (lhs.hasSearchText == rhs.hasSearchText) && (!lhs.hasSearchText || lhs.searchText == rhs.searchText)
            fieldCheck = fieldCheck && (lhs.filters == rhs.filters)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Query cursor
        public fileprivate(set) var cursor:String = ""
        public fileprivate(set) var hasCursor:Bool = false

        /// Number of results to return
        public fileprivate(set) var numResults:UInt32 = UInt32(0)
        public fileprivate(set) var hasNumResults:Bool = false

        /// Optional signed page offset and direction
        public fileprivate(set) var direction:Int32 = Int32(0)
        public fileprivate(set) var hasDirection:Bool = false

        /// Optional search text
        public fileprivate(set) var searchText:String = ""
        public fileprivate(set) var hasSearchText:Bool = false

        public fileprivate(set) var filters:Array<Present.AdminSearchFilter>  = Array<Present.AdminSearchFilter>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitFilters:Bool = true
            for oneElementFilters in filters {
                if !oneElementFilters.isInitialized() {
                    isInitFilters = false
                    break 
                }
            }
            if !isInitFilters {
                return isInitFilters
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCursor {
                try codedOutputStream.writeString(fieldNumber: 1, value:cursor)
            }
            if hasNumResults {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:numResults)
            }
            if hasDirection {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:direction)
            }
            if hasSearchText {
                try codedOutputStream.writeString(fieldNumber: 4, value:searchText)
            }
            for oneElementFilters in filters {
                  try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementFilters)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCursor {
                serialize_size += cursor.computeStringSize(fieldNumber: 1)
            }
            if hasNumResults {
                serialize_size += numResults.computeUInt32Size(fieldNumber: 2)
            }
            if hasDirection {
                serialize_size += direction.computeInt32Size(fieldNumber: 3)
            }
            if hasSearchText {
                serialize_size += searchText.computeStringSize(fieldNumber: 4)
            }
            for oneElementFilters in filters {
                serialize_size += oneElementFilters.computeMessageSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AdminSearchRequest.Builder {
            return Present.AdminSearchRequest.classBuilder() as! Present.AdminSearchRequest.Builder
        }
        public func getBuilder() -> Present.AdminSearchRequest.Builder {
            return classBuilder() as! Present.AdminSearchRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AdminSearchRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AdminSearchRequest.Builder()
        }
        public func toBuilder() throws -> Present.AdminSearchRequest.Builder {
            return try Present.AdminSearchRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AdminSearchRequest) throws -> Present.AdminSearchRequest.Builder {
            return try Present.AdminSearchRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCursor {
                jsonMap["cursor"] = cursor
            }
            if hasNumResults {
                jsonMap["numResults"] = UInt(numResults)
            }
            if hasDirection {
                jsonMap["direction"] = Int(direction)
            }
            if hasSearchText {
                jsonMap["searchText"] = searchText
            }
            if !filters.isEmpty {
                var jsonArrayFilters:Array<Dictionary<String,Any>> = []
                for oneValueFilters in filters {
                    let ecodedMessageFilters = try oneValueFilters.encode()
                    jsonArrayFilters.append(ecodedMessageFilters)
                }
                jsonMap["filters"] = jsonArrayFilters
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AdminSearchRequest {
            return try Present.AdminSearchRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AdminSearchRequest {
            return try Present.AdminSearchRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCursor {
                output += "\(indent) cursor: \(cursor) \n"
            }
            if hasNumResults {
                output += "\(indent) numResults: \(numResults) \n"
            }
            if hasDirection {
                output += "\(indent) direction: \(direction) \n"
            }
            if hasSearchText {
                output += "\(indent) searchText: \(searchText) \n"
            }
            var filtersElementIndex:Int = 0
            for oneElementFilters in filters {
                output += "\(indent) filters[\(filtersElementIndex)] {\n"
                output += try oneElementFilters.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                filtersElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCursor {
                    hashCode = (hashCode &* 31) &+ cursor.hashValue
                }
                if hasNumResults {
                    hashCode = (hashCode &* 31) &+ numResults.hashValue
                }
                if hasDirection {
                    hashCode = (hashCode &* 31) &+ direction.hashValue
                }
                if hasSearchText {
                    hashCode = (hashCode &* 31) &+ searchText.hashValue
                }
                for oneElementFilters in filters {
                    hashCode = (hashCode &* 31) &+ oneElementFilters.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AdminSearchRequest"
        }
        override public func className() -> String {
            return "Present.AdminSearchRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AdminSearchRequest = Present.AdminSearchRequest()
            public func getMessage() -> Present.AdminSearchRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Query cursor
            public var cursor:String {
                get {
                    return builderResult.cursor
                }
                set (value) {
                    builderResult.hasCursor = true
                    builderResult.cursor = value
                }
            }
            public var hasCursor:Bool {
                get {
                    return builderResult.hasCursor
                }
            }
            @discardableResult
            public func setCursor(_ value:String) -> Present.AdminSearchRequest.Builder {
                self.cursor = value
                return self
            }
            @discardableResult
            public func clearCursor() -> Present.AdminSearchRequest.Builder{
                builderResult.hasCursor = false
                builderResult.cursor = ""
                return self
            }
            /// Number of results to return
            public var numResults:UInt32 {
                get {
                    return builderResult.numResults
                }
                set (value) {
                    builderResult.hasNumResults = true
                    builderResult.numResults = value
                }
            }
            public var hasNumResults:Bool {
                get {
                    return builderResult.hasNumResults
                }
            }
            @discardableResult
            public func setNumResults(_ value:UInt32) -> Present.AdminSearchRequest.Builder {
                self.numResults = value
                return self
            }
            @discardableResult
            public func clearNumResults() -> Present.AdminSearchRequest.Builder{
                builderResult.hasNumResults = false
                builderResult.numResults = UInt32(0)
                return self
            }
            /// Optional signed page offset and direction
            public var direction:Int32 {
                get {
                    return builderResult.direction
                }
                set (value) {
                    builderResult.hasDirection = true
                    builderResult.direction = value
                }
            }
            public var hasDirection:Bool {
                get {
                    return builderResult.hasDirection
                }
            }
            @discardableResult
            public func setDirection(_ value:Int32) -> Present.AdminSearchRequest.Builder {
                self.direction = value
                return self
            }
            @discardableResult
            public func clearDirection() -> Present.AdminSearchRequest.Builder{
                builderResult.hasDirection = false
                builderResult.direction = Int32(0)
                return self
            }
            /// Optional search text
            public var searchText:String {
                get {
                    return builderResult.searchText
                }
                set (value) {
                    builderResult.hasSearchText = true
                    builderResult.searchText = value
                }
            }
            public var hasSearchText:Bool {
                get {
                    return builderResult.hasSearchText
                }
            }
            @discardableResult
            public func setSearchText(_ value:String) -> Present.AdminSearchRequest.Builder {
                self.searchText = value
                return self
            }
            @discardableResult
            public func clearSearchText() -> Present.AdminSearchRequest.Builder{
                builderResult.hasSearchText = false
                builderResult.searchText = ""
                return self
            }
            /// Optional filter(s)
            public var filters:Array<Present.AdminSearchFilter> {
                get {
                    return builderResult.filters
                }
                set (value) {
                    builderResult.filters = value
                }
            }
            @discardableResult
            public func setFilters(_ value:Array<Present.AdminSearchFilter>) -> Present.AdminSearchRequest.Builder {
                self.filters = value
                return self
            }
            @discardableResult
            public func clearFilters() -> Present.AdminSearchRequest.Builder {
                builderResult.filters.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AdminSearchRequest.Builder {
                builderResult = Present.AdminSearchRequest()
                return self
            }
            override public func clone() throws -> Present.AdminSearchRequest.Builder {
                return try Present.AdminSearchRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AdminSearchRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AdminSearchRequest {
                let returnMe:Present.AdminSearchRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AdminSearchRequest) throws -> Present.AdminSearchRequest.Builder {
                if other == Present.AdminSearchRequest() {
                    return self
                }
                if other.hasCursor {
                    cursor = other.cursor
                }
                if other.hasNumResults {
                    numResults = other.numResults
                }
                if other.hasDirection {
                    direction = other.direction
                }
                if other.hasSearchText {
                    searchText = other.searchText
                }
                if !other.filters.isEmpty  {
                     builderResult.filters += other.filters
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AdminSearchRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        cursor = try codedInputStream.readString()

                    case 16:
                        numResults = try codedInputStream.readUInt32()

                    case 24:
                        direction = try codedInputStream.readInt32()

                    case 34:
                        searchText = try codedInputStream.readString()

                    case 42:
                        let subBuilder = Present.AdminSearchFilter.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        filters.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AdminSearchRequest.Builder {
                let resultDecodedBuilder = Present.AdminSearchRequest.Builder()
                if let jsonValueCursor = jsonMap["cursor"] as? String {
                    resultDecodedBuilder.cursor = jsonValueCursor
                }
                if let jsonValueNumResults = jsonMap["numResults"] as? UInt {
                    resultDecodedBuilder.numResults = UInt32(jsonValueNumResults)
                } else if let jsonValueNumResults = jsonMap["numResults"] as? String {
                    resultDecodedBuilder.numResults = UInt32(jsonValueNumResults)!
                }
                if let jsonValueDirection = jsonMap["direction"] as? Int {
                    resultDecodedBuilder.direction = Int32(jsonValueDirection)
                } else if let jsonValueDirection = jsonMap["direction"] as? String {
                    resultDecodedBuilder.direction = Int32(jsonValueDirection)!
                }
                if let jsonValueSearchText = jsonMap["searchText"] as? String {
                    resultDecodedBuilder.searchText = jsonValueSearchText
                }
                if let jsonValueFilters = jsonMap["filters"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayFilters:Array<Present.AdminSearchFilter> = []
                    for oneValueFilters in jsonValueFilters {
                        let messageFromStringFilters = try Present.AdminSearchFilter.Builder.decodeToBuilder(jsonMap:oneValueFilters).build()

                        jsonArrayFilters.append(messageFromStringFilters)
                    }
                    resultDecodedBuilder.filters = jsonArrayFilters
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AdminSearchRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AdminSearchRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class AdminSearchResponse : GeneratedMessage {

        public static func == (lhs: Present.AdminSearchResponse, rhs: Present.AdminSearchResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCursor == rhs.hasCursor) && (!lhs.hasCursor || lhs.cursor == rhs.cursor)
            fieldCheck = fieldCheck && (lhs.adminSearchResponse == rhs.adminSearchResponse)
            fieldCheck = fieldCheck && (lhs.hasTotalUsers == rhs.hasTotalUsers) && (!lhs.hasTotalUsers || lhs.totalUsers == rhs.totalUsers)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var cursor:String = ""
        public fileprivate(set) var hasCursor:Bool = false

        public fileprivate(set) var adminSearchResponse:Array<Present.AdminUserResponse>  = Array<Present.AdminUserResponse>()
        public fileprivate(set) var totalUsers:UInt64 = UInt64(0)
        public fileprivate(set) var hasTotalUsers:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasCursor {
                return false
            }
            var isInitAdminSearchResponse:Bool = true
            for oneElementAdminSearchResponse in adminSearchResponse {
                if !oneElementAdminSearchResponse.isInitialized() {
                    isInitAdminSearchResponse = false
                    break 
                }
            }
            if !isInitAdminSearchResponse {
                return isInitAdminSearchResponse
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCursor {
                try codedOutputStream.writeString(fieldNumber: 1, value:cursor)
            }
            for oneElementAdminSearchResponse in adminSearchResponse {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementAdminSearchResponse)
            }
            if hasTotalUsers {
                try codedOutputStream.writeUInt64(fieldNumber: 3, value:totalUsers)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCursor {
                serialize_size += cursor.computeStringSize(fieldNumber: 1)
            }
            for oneElementAdminSearchResponse in adminSearchResponse {
                serialize_size += oneElementAdminSearchResponse.computeMessageSize(fieldNumber: 2)
            }
            if hasTotalUsers {
                serialize_size += totalUsers.computeUInt64Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AdminSearchResponse.Builder {
            return Present.AdminSearchResponse.classBuilder() as! Present.AdminSearchResponse.Builder
        }
        public func getBuilder() -> Present.AdminSearchResponse.Builder {
            return classBuilder() as! Present.AdminSearchResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AdminSearchResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AdminSearchResponse.Builder()
        }
        public func toBuilder() throws -> Present.AdminSearchResponse.Builder {
            return try Present.AdminSearchResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AdminSearchResponse) throws -> Present.AdminSearchResponse.Builder {
            return try Present.AdminSearchResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCursor {
                jsonMap["cursor"] = cursor
            }
            if !adminSearchResponse.isEmpty {
                var jsonArrayAdminSearchResponse:Array<Dictionary<String,Any>> = []
                for oneValueAdminSearchResponse in adminSearchResponse {
                    let ecodedMessageAdminSearchResponse = try oneValueAdminSearchResponse.encode()
                    jsonArrayAdminSearchResponse.append(ecodedMessageAdminSearchResponse)
                }
                jsonMap["adminSearchResponse"] = jsonArrayAdminSearchResponse
            }
            if hasTotalUsers {
                jsonMap["totalUsers"] = "\(totalUsers)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AdminSearchResponse {
            return try Present.AdminSearchResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AdminSearchResponse {
            return try Present.AdminSearchResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCursor {
                output += "\(indent) cursor: \(cursor) \n"
            }
            var adminSearchResponseElementIndex:Int = 0
            for oneElementAdminSearchResponse in adminSearchResponse {
                output += "\(indent) adminSearchResponse[\(adminSearchResponseElementIndex)] {\n"
                output += try oneElementAdminSearchResponse.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                adminSearchResponseElementIndex += 1
            }
            if hasTotalUsers {
                output += "\(indent) totalUsers: \(totalUsers) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCursor {
                    hashCode = (hashCode &* 31) &+ cursor.hashValue
                }
                for oneElementAdminSearchResponse in adminSearchResponse {
                    hashCode = (hashCode &* 31) &+ oneElementAdminSearchResponse.hashValue
                }
                if hasTotalUsers {
                    hashCode = (hashCode &* 31) &+ totalUsers.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AdminSearchResponse"
        }
        override public func className() -> String {
            return "Present.AdminSearchResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AdminSearchResponse = Present.AdminSearchResponse()
            public func getMessage() -> Present.AdminSearchResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var cursor:String {
                get {
                    return builderResult.cursor
                }
                set (value) {
                    builderResult.hasCursor = true
                    builderResult.cursor = value
                }
            }
            public var hasCursor:Bool {
                get {
                    return builderResult.hasCursor
                }
            }
            @discardableResult
            public func setCursor(_ value:String) -> Present.AdminSearchResponse.Builder {
                self.cursor = value
                return self
            }
            @discardableResult
            public func clearCursor() -> Present.AdminSearchResponse.Builder{
                builderResult.hasCursor = false
                builderResult.cursor = ""
                return self
            }
            public var adminSearchResponse:Array<Present.AdminUserResponse> {
                get {
                    return builderResult.adminSearchResponse
                }
                set (value) {
                    builderResult.adminSearchResponse = value
                }
            }
            @discardableResult
            public func setAdminSearchResponse(_ value:Array<Present.AdminUserResponse>) -> Present.AdminSearchResponse.Builder {
                self.adminSearchResponse = value
                return self
            }
            @discardableResult
            public func clearAdminSearchResponse() -> Present.AdminSearchResponse.Builder {
                builderResult.adminSearchResponse.removeAll(keepingCapacity: false)
                return self
            }
            public var totalUsers:UInt64 {
                get {
                    return builderResult.totalUsers
                }
                set (value) {
                    builderResult.hasTotalUsers = true
                    builderResult.totalUsers = value
                }
            }
            public var hasTotalUsers:Bool {
                get {
                    return builderResult.hasTotalUsers
                }
            }
            @discardableResult
            public func setTotalUsers(_ value:UInt64) -> Present.AdminSearchResponse.Builder {
                self.totalUsers = value
                return self
            }
            @discardableResult
            public func clearTotalUsers() -> Present.AdminSearchResponse.Builder{
                builderResult.hasTotalUsers = false
                builderResult.totalUsers = UInt64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AdminSearchResponse.Builder {
                builderResult = Present.AdminSearchResponse()
                return self
            }
            override public func clone() throws -> Present.AdminSearchResponse.Builder {
                return try Present.AdminSearchResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AdminSearchResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AdminSearchResponse {
                let returnMe:Present.AdminSearchResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AdminSearchResponse) throws -> Present.AdminSearchResponse.Builder {
                if other == Present.AdminSearchResponse() {
                    return self
                }
                if other.hasCursor {
                    cursor = other.cursor
                }
                if !other.adminSearchResponse.isEmpty  {
                     builderResult.adminSearchResponse += other.adminSearchResponse
                }
                if other.hasTotalUsers {
                    totalUsers = other.totalUsers
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AdminSearchResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        cursor = try codedInputStream.readString()

                    case 18:
                        let subBuilder = Present.AdminUserResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        adminSearchResponse.append(subBuilder.buildPartial())

                    case 24:
                        totalUsers = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AdminSearchResponse.Builder {
                let resultDecodedBuilder = Present.AdminSearchResponse.Builder()
                if let jsonValueCursor = jsonMap["cursor"] as? String {
                    resultDecodedBuilder.cursor = jsonValueCursor
                }
                if let jsonValueAdminSearchResponse = jsonMap["adminSearchResponse"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayAdminSearchResponse:Array<Present.AdminUserResponse> = []
                    for oneValueAdminSearchResponse in jsonValueAdminSearchResponse {
                        let messageFromStringAdminSearchResponse = try Present.AdminUserResponse.Builder.decodeToBuilder(jsonMap:oneValueAdminSearchResponse).build()

                        jsonArrayAdminSearchResponse.append(messageFromStringAdminSearchResponse)
                    }
                    resultDecodedBuilder.adminSearchResponse = jsonArrayAdminSearchResponse
                }
                if let jsonValueTotalUsers = jsonMap["totalUsers"] as? String {
                    resultDecodedBuilder.totalUsers = UInt64(jsonValueTotalUsers)!
                } else if let jsonValueTotalUsers = jsonMap["totalUsers"] as? UInt {
                    resultDecodedBuilder.totalUsers = UInt64(jsonValueTotalUsers)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AdminSearchResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AdminSearchResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class AdminSearchFilter : GeneratedMessage {

        public static func == (lhs: Present.AdminSearchFilter, rhs: Present.AdminSearchFilter) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasField == rhs.hasField) && (!lhs.hasField || lhs.field == rhs.field)
            fieldCheck = fieldCheck && (lhs.hasSearchString == rhs.hasSearchString) && (!lhs.hasSearchString || lhs.searchString == rhs.searchString)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var field:String = ""
        public fileprivate(set) var hasField:Bool = false

        public fileprivate(set) var searchString:String = ""
        public fileprivate(set) var hasSearchString:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasField {
                return false
            }
            if !hasSearchString {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasField {
                try codedOutputStream.writeString(fieldNumber: 1, value:field)
            }
            if hasSearchString {
                try codedOutputStream.writeString(fieldNumber: 2, value:searchString)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasField {
                serialize_size += field.computeStringSize(fieldNumber: 1)
            }
            if hasSearchString {
                serialize_size += searchString.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AdminSearchFilter.Builder {
            return Present.AdminSearchFilter.classBuilder() as! Present.AdminSearchFilter.Builder
        }
        public func getBuilder() -> Present.AdminSearchFilter.Builder {
            return classBuilder() as! Present.AdminSearchFilter.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AdminSearchFilter.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AdminSearchFilter.Builder()
        }
        public func toBuilder() throws -> Present.AdminSearchFilter.Builder {
            return try Present.AdminSearchFilter.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AdminSearchFilter) throws -> Present.AdminSearchFilter.Builder {
            return try Present.AdminSearchFilter.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasField {
                jsonMap["field"] = field
            }
            if hasSearchString {
                jsonMap["searchString"] = searchString
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AdminSearchFilter {
            return try Present.AdminSearchFilter.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AdminSearchFilter {
            return try Present.AdminSearchFilter.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasField {
                output += "\(indent) field: \(field) \n"
            }
            if hasSearchString {
                output += "\(indent) searchString: \(searchString) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasField {
                    hashCode = (hashCode &* 31) &+ field.hashValue
                }
                if hasSearchString {
                    hashCode = (hashCode &* 31) &+ searchString.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AdminSearchFilter"
        }
        override public func className() -> String {
            return "Present.AdminSearchFilter"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AdminSearchFilter = Present.AdminSearchFilter()
            public func getMessage() -> Present.AdminSearchFilter {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var field:String {
                get {
                    return builderResult.field
                }
                set (value) {
                    builderResult.hasField = true
                    builderResult.field = value
                }
            }
            public var hasField:Bool {
                get {
                    return builderResult.hasField
                }
            }
            @discardableResult
            public func setField(_ value:String) -> Present.AdminSearchFilter.Builder {
                self.field = value
                return self
            }
            @discardableResult
            public func clearField() -> Present.AdminSearchFilter.Builder{
                builderResult.hasField = false
                builderResult.field = ""
                return self
            }
            public var searchString:String {
                get {
                    return builderResult.searchString
                }
                set (value) {
                    builderResult.hasSearchString = true
                    builderResult.searchString = value
                }
            }
            public var hasSearchString:Bool {
                get {
                    return builderResult.hasSearchString
                }
            }
            @discardableResult
            public func setSearchString(_ value:String) -> Present.AdminSearchFilter.Builder {
                self.searchString = value
                return self
            }
            @discardableResult
            public func clearSearchString() -> Present.AdminSearchFilter.Builder{
                builderResult.hasSearchString = false
                builderResult.searchString = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AdminSearchFilter.Builder {
                builderResult = Present.AdminSearchFilter()
                return self
            }
            override public func clone() throws -> Present.AdminSearchFilter.Builder {
                return try Present.AdminSearchFilter.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AdminSearchFilter {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AdminSearchFilter {
                let returnMe:Present.AdminSearchFilter = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AdminSearchFilter) throws -> Present.AdminSearchFilter.Builder {
                if other == Present.AdminSearchFilter() {
                    return self
                }
                if other.hasField {
                    field = other.field
                }
                if other.hasSearchString {
                    searchString = other.searchString
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AdminSearchFilter.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchFilter.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        field = try codedInputStream.readString()

                    case 18:
                        searchString = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AdminSearchFilter.Builder {
                let resultDecodedBuilder = Present.AdminSearchFilter.Builder()
                if let jsonValueField = jsonMap["field"] as? String {
                    resultDecodedBuilder.field = jsonValueField
                }
                if let jsonValueSearchString = jsonMap["searchString"] as? String {
                    resultDecodedBuilder.searchString = jsonValueSearchString
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AdminSearchFilter.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AdminSearchFilter.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Full profile of a Present user
    final public class AdminUserResponse : GeneratedMessage {

        public static func == (lhs: Present.AdminUserResponse, rhs: Present.AdminUserResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUuid == rhs.hasUuid) && (!lhs.hasUuid || lhs.uuid == rhs.uuid)
            fieldCheck = fieldCheck && (lhs.hasPhoto == rhs.hasPhoto) && (!lhs.hasPhoto || lhs.photo == rhs.photo)
            fieldCheck = fieldCheck && (lhs.hasFirstName == rhs.hasFirstName) && (!lhs.hasFirstName || lhs.firstName == rhs.firstName)
            fieldCheck = fieldCheck && (lhs.hasLastName == rhs.hasLastName) && (!lhs.hasLastName || lhs.lastName == rhs.lastName)
            fieldCheck = fieldCheck && (lhs.hasGender == rhs.hasGender) && (!lhs.hasGender || lhs.gender == rhs.gender)
            fieldCheck = fieldCheck && (lhs.hasPhone == rhs.hasPhone) && (!lhs.hasPhone || lhs.phone == rhs.phone)
            fieldCheck = fieldCheck && (lhs.hasEmail == rhs.hasEmail) && (!lhs.hasEmail || lhs.email == rhs.email)
            fieldCheck = fieldCheck && (lhs.hasFacebookLink == rhs.hasFacebookLink) && (!lhs.hasFacebookLink || lhs.facebookLink == rhs.facebookLink)
            fieldCheck = fieldCheck && (lhs.hasPresentLink == rhs.hasPresentLink) && (!lhs.hasPresentLink || lhs.presentLink == rhs.presentLink)
            fieldCheck = fieldCheck && (lhs.hasSignupTime == rhs.hasSignupTime) && (!lhs.hasSignupTime || lhs.signupTime == rhs.signupTime)
            fieldCheck = fieldCheck && (lhs.hasNotificationsEnabled == rhs.hasNotificationsEnabled) && (!lhs.hasNotificationsEnabled || lhs.notificationsEnabled == rhs.notificationsEnabled)
            fieldCheck = fieldCheck && (lhs.hasLastActivityTime == rhs.hasLastActivityTime) && (!lhs.hasLastActivityTime || lhs.lastActivityTime == rhs.lastActivityTime)
            fieldCheck = fieldCheck && (lhs.hasSignupCity == rhs.hasSignupCity) && (!lhs.hasSignupCity || lhs.signupCity == rhs.signupCity)
            fieldCheck = fieldCheck && (lhs.hasSignupState == rhs.hasSignupState) && (!lhs.hasSignupState || lhs.signupState == rhs.signupState)
            fieldCheck = fieldCheck && (lhs.hasSignupLat == rhs.hasSignupLat) && (!lhs.hasSignupLat || lhs.signupLat == rhs.signupLat)
            fieldCheck = fieldCheck && (lhs.hasSignupLong == rhs.hasSignupLong) && (!lhs.hasSignupLong || lhs.signupLong == rhs.signupLong)
            fieldCheck = fieldCheck && (lhs.hasSignupLocationAccuracy == rhs.hasSignupLocationAccuracy) && (!lhs.hasSignupLocationAccuracy || lhs.signupLocationAccuracy == rhs.signupLocationAccuracy)
            fieldCheck = fieldCheck && (lhs.hasUserState == rhs.hasUserState) && (!lhs.hasUserState || lhs.userState == rhs.userState)
            fieldCheck = fieldCheck && (lhs.hasReview == rhs.hasReview) && (!lhs.hasReview || lhs.review == rhs.review)
            fieldCheck = fieldCheck && (lhs.clients == rhs.clients)
            fieldCheck = fieldCheck && (lhs.availableActions == rhs.availableActions)
            fieldCheck = fieldCheck && (lhs.hasDebugString == rhs.hasDebugString) && (!lhs.hasDebugString || lhs.debugString == rhs.debugString)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// User uuid
        public fileprivate(set) var uuid:String = ""
        public fileprivate(set) var hasUuid:Bool = false

        /// URL to profile photo
        public fileprivate(set) var photo:String = ""
        public fileprivate(set) var hasPhoto:Bool = false

        public fileprivate(set) var firstName:String = ""
        public fileprivate(set) var hasFirstName:Bool = false

        public fileprivate(set) var lastName:String = ""
        public fileprivate(set) var hasLastName:Bool = false

        public fileprivate(set) var gender:String = ""
        public fileprivate(set) var hasGender:Bool = false

        public fileprivate(set) var phone:String = ""
        public fileprivate(set) var hasPhone:Bool = false

        public fileprivate(set) var email:String = ""
        public fileprivate(set) var hasEmail:Bool = false

        /// Facebook profile url
        public fileprivate(set) var facebookLink:String = ""
        public fileprivate(set) var hasFacebookLink:Bool = false

        /// Present profile url
        public fileprivate(set) var presentLink:String = ""
        public fileprivate(set) var hasPresentLink:Bool = false

        public fileprivate(set) var signupTime:UInt64 = UInt64(0)
        public fileprivate(set) var hasSignupTime:Bool = false

        public fileprivate(set) var notificationsEnabled:Bool = false
        public fileprivate(set) var hasNotificationsEnabled:Bool = false

        public fileprivate(set) var lastActivityTime:UInt64 = UInt64(0)
        public fileprivate(set) var hasLastActivityTime:Bool = false

        public fileprivate(set) var signupCity:String = ""
        public fileprivate(set) var hasSignupCity:Bool = false

        public fileprivate(set) var signupState:String = ""
        public fileprivate(set) var hasSignupState:Bool = false

        public fileprivate(set) var signupLat:Double = Double(0)
        public fileprivate(set) var hasSignupLat:Bool = false

        public fileprivate(set) var signupLong:Double = Double(0)
        public fileprivate(set) var hasSignupLong:Bool = false

        public fileprivate(set) var signupLocationAccuracy:Double = Double(0)
        public fileprivate(set) var hasSignupLocationAccuracy:Bool = false

        public fileprivate(set) var userState:String = ""
        public fileprivate(set) var hasUserState:Bool = false

        public fileprivate(set) var review:String = ""
        public fileprivate(set) var hasReview:Bool = false

        public fileprivate(set) var clients:Array<String> = Array<String>()
        public fileprivate(set) var availableActions:Array<String> = Array<String>()
        public fileprivate(set) var debugString:String = ""
        public fileprivate(set) var hasDebugString:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUuid {
                return false
            }
            if !hasPhoto {
                return false
            }
            if !hasFirstName {
                return false
            }
            if !hasLastName {
                return false
            }
            if !hasGender {
                return false
            }
            if !hasPhone {
                return false
            }
            if !hasEmail {
                return false
            }
            if !hasFacebookLink {
                return false
            }
            if !hasPresentLink {
                return false
            }
            if !hasSignupTime {
                return false
            }
            if !hasNotificationsEnabled {
                return false
            }
            if !hasLastActivityTime {
                return false
            }
            if !hasSignupCity {
                return false
            }
            if !hasSignupState {
                return false
            }
            if !hasSignupLat {
                return false
            }
            if !hasSignupLong {
                return false
            }
            if !hasSignupLocationAccuracy {
                return false
            }
            if !hasUserState {
                return false
            }
            if !hasReview {
                return false
            }
            if !hasDebugString {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUuid {
                try codedOutputStream.writeString(fieldNumber: 1, value:uuid)
            }
            if hasPhoto {
                try codedOutputStream.writeString(fieldNumber: 2, value:photo)
            }
            if hasFirstName {
                try codedOutputStream.writeString(fieldNumber: 3, value:firstName)
            }
            if hasLastName {
                try codedOutputStream.writeString(fieldNumber: 4, value:lastName)
            }
            if hasGender {
                try codedOutputStream.writeString(fieldNumber: 5, value:gender)
            }
            if hasPhone {
                try codedOutputStream.writeString(fieldNumber: 6, value:phone)
            }
            if hasEmail {
                try codedOutputStream.writeString(fieldNumber: 7, value:email)
            }
            if hasFacebookLink {
                try codedOutputStream.writeString(fieldNumber: 8, value:facebookLink)
            }
            if hasPresentLink {
                try codedOutputStream.writeString(fieldNumber: 9, value:presentLink)
            }
            if hasSignupTime {
                try codedOutputStream.writeUInt64(fieldNumber: 10, value:signupTime)
            }
            if hasNotificationsEnabled {
                try codedOutputStream.writeBool(fieldNumber: 11, value:notificationsEnabled)
            }
            if hasLastActivityTime {
                try codedOutputStream.writeUInt64(fieldNumber: 12, value:lastActivityTime)
            }
            if hasSignupCity {
                try codedOutputStream.writeString(fieldNumber: 13, value:signupCity)
            }
            if hasSignupState {
                try codedOutputStream.writeString(fieldNumber: 14, value:signupState)
            }
            if hasSignupLat {
                try codedOutputStream.writeDouble(fieldNumber: 15, value:signupLat)
            }
            if hasSignupLong {
                try codedOutputStream.writeDouble(fieldNumber: 16, value:signupLong)
            }
            if hasSignupLocationAccuracy {
                try codedOutputStream.writeDouble(fieldNumber: 17, value:signupLocationAccuracy)
            }
            if hasUserState {
                try codedOutputStream.writeString(fieldNumber: 18, value:userState)
            }
            if hasReview {
                try codedOutputStream.writeString(fieldNumber: 19, value:review)
            }
            if !clients.isEmpty {
                for oneValueclients in clients {
                    try codedOutputStream.writeString(fieldNumber: 20, value:oneValueclients)
                }
            }
            if !availableActions.isEmpty {
                for oneValueavailableActions in availableActions {
                    try codedOutputStream.writeString(fieldNumber: 21, value:oneValueavailableActions)
                }
            }
            if hasDebugString {
                try codedOutputStream.writeString(fieldNumber: 22, value:debugString)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUuid {
                serialize_size += uuid.computeStringSize(fieldNumber: 1)
            }
            if hasPhoto {
                serialize_size += photo.computeStringSize(fieldNumber: 2)
            }
            if hasFirstName {
                serialize_size += firstName.computeStringSize(fieldNumber: 3)
            }
            if hasLastName {
                serialize_size += lastName.computeStringSize(fieldNumber: 4)
            }
            if hasGender {
                serialize_size += gender.computeStringSize(fieldNumber: 5)
            }
            if hasPhone {
                serialize_size += phone.computeStringSize(fieldNumber: 6)
            }
            if hasEmail {
                serialize_size += email.computeStringSize(fieldNumber: 7)
            }
            if hasFacebookLink {
                serialize_size += facebookLink.computeStringSize(fieldNumber: 8)
            }
            if hasPresentLink {
                serialize_size += presentLink.computeStringSize(fieldNumber: 9)
            }
            if hasSignupTime {
                serialize_size += signupTime.computeUInt64Size(fieldNumber: 10)
            }
            if hasNotificationsEnabled {
                serialize_size += notificationsEnabled.computeBoolSize(fieldNumber: 11)
            }
            if hasLastActivityTime {
                serialize_size += lastActivityTime.computeUInt64Size(fieldNumber: 12)
            }
            if hasSignupCity {
                serialize_size += signupCity.computeStringSize(fieldNumber: 13)
            }
            if hasSignupState {
                serialize_size += signupState.computeStringSize(fieldNumber: 14)
            }
            if hasSignupLat {
                serialize_size += signupLat.computeDoubleSize(fieldNumber: 15)
            }
            if hasSignupLong {
                serialize_size += signupLong.computeDoubleSize(fieldNumber: 16)
            }
            if hasSignupLocationAccuracy {
                serialize_size += signupLocationAccuracy.computeDoubleSize(fieldNumber: 17)
            }
            if hasUserState {
                serialize_size += userState.computeStringSize(fieldNumber: 18)
            }
            if hasReview {
                serialize_size += review.computeStringSize(fieldNumber: 19)
            }
            var dataSizeClients:Int32 = 0
            for oneValueclients in clients {
                dataSizeClients += oneValueclients.computeStringSizeNoTag()
            }
            serialize_size += dataSizeClients
            serialize_size += 2 * Int32(clients.count)
            var dataSizeAvailableActions:Int32 = 0
            for oneValueavailableActions in availableActions {
                dataSizeAvailableActions += oneValueavailableActions.computeStringSizeNoTag()
            }
            serialize_size += dataSizeAvailableActions
            serialize_size += 2 * Int32(availableActions.count)
            if hasDebugString {
                serialize_size += debugString.computeStringSize(fieldNumber: 22)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AdminUserResponse.Builder {
            return Present.AdminUserResponse.classBuilder() as! Present.AdminUserResponse.Builder
        }
        public func getBuilder() -> Present.AdminUserResponse.Builder {
            return classBuilder() as! Present.AdminUserResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AdminUserResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AdminUserResponse.Builder()
        }
        public func toBuilder() throws -> Present.AdminUserResponse.Builder {
            return try Present.AdminUserResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AdminUserResponse) throws -> Present.AdminUserResponse.Builder {
            return try Present.AdminUserResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUuid {
                jsonMap["uuid"] = uuid
            }
            if hasPhoto {
                jsonMap["photo"] = photo
            }
            if hasFirstName {
                jsonMap["firstName"] = firstName
            }
            if hasLastName {
                jsonMap["lastName"] = lastName
            }
            if hasGender {
                jsonMap["gender"] = gender
            }
            if hasPhone {
                jsonMap["phone"] = phone
            }
            if hasEmail {
                jsonMap["email"] = email
            }
            if hasFacebookLink {
                jsonMap["facebookLink"] = facebookLink
            }
            if hasPresentLink {
                jsonMap["presentLink"] = presentLink
            }
            if hasSignupTime {
                jsonMap["signupTime"] = "\(signupTime)"
            }
            if hasNotificationsEnabled {
                jsonMap["notificationsEnabled"] = notificationsEnabled
            }
            if hasLastActivityTime {
                jsonMap["lastActivityTime"] = "\(lastActivityTime)"
            }
            if hasSignupCity {
                jsonMap["signupCity"] = signupCity
            }
            if hasSignupState {
                jsonMap["signupState"] = signupState
            }
            if hasSignupLat {
                jsonMap["signupLat"] = Double(signupLat)
            }
            if hasSignupLong {
                jsonMap["signupLong"] = Double(signupLong)
            }
            if hasSignupLocationAccuracy {
                jsonMap["signupLocationAccuracy"] = Double(signupLocationAccuracy)
            }
            if hasUserState {
                jsonMap["userState"] = userState
            }
            if hasReview {
                jsonMap["review"] = review
            }
            if !clients.isEmpty {
                var jsonArrayClients:Array<String> = []
                for oneValueClients in clients {
                    jsonArrayClients.append(oneValueClients)
                }
                jsonMap["clients"] = jsonArrayClients
            }
            if !availableActions.isEmpty {
                var jsonArrayAvailableActions:Array<String> = []
                for oneValueAvailableActions in availableActions {
                    jsonArrayAvailableActions.append(oneValueAvailableActions)
                }
                jsonMap["availableActions"] = jsonArrayAvailableActions
            }
            if hasDebugString {
                jsonMap["debugString"] = debugString
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AdminUserResponse {
            return try Present.AdminUserResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AdminUserResponse {
            return try Present.AdminUserResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUuid {
                output += "\(indent) uuid: \(uuid) \n"
            }
            if hasPhoto {
                output += "\(indent) photo: \(photo) \n"
            }
            if hasFirstName {
                output += "\(indent) firstName: \(firstName) \n"
            }
            if hasLastName {
                output += "\(indent) lastName: \(lastName) \n"
            }
            if hasGender {
                output += "\(indent) gender: \(gender) \n"
            }
            if hasPhone {
                output += "\(indent) phone: \(phone) \n"
            }
            if hasEmail {
                output += "\(indent) email: \(email) \n"
            }
            if hasFacebookLink {
                output += "\(indent) facebookLink: \(facebookLink) \n"
            }
            if hasPresentLink {
                output += "\(indent) presentLink: \(presentLink) \n"
            }
            if hasSignupTime {
                output += "\(indent) signupTime: \(signupTime) \n"
            }
            if hasNotificationsEnabled {
                output += "\(indent) notificationsEnabled: \(notificationsEnabled) \n"
            }
            if hasLastActivityTime {
                output += "\(indent) lastActivityTime: \(lastActivityTime) \n"
            }
            if hasSignupCity {
                output += "\(indent) signupCity: \(signupCity) \n"
            }
            if hasSignupState {
                output += "\(indent) signupState: \(signupState) \n"
            }
            if hasSignupLat {
                output += "\(indent) signupLat: \(signupLat) \n"
            }
            if hasSignupLong {
                output += "\(indent) signupLong: \(signupLong) \n"
            }
            if hasSignupLocationAccuracy {
                output += "\(indent) signupLocationAccuracy: \(signupLocationAccuracy) \n"
            }
            if hasUserState {
                output += "\(indent) userState: \(userState) \n"
            }
            if hasReview {
                output += "\(indent) review: \(review) \n"
            }
            var clientsElementIndex:Int = 0
            for oneValueClients in clients  {
                output += "\(indent) clients[\(clientsElementIndex)]: \(oneValueClients)\n"
                clientsElementIndex += 1
            }
            var availableActionsElementIndex:Int = 0
            for oneValueAvailableActions in availableActions  {
                output += "\(indent) availableActions[\(availableActionsElementIndex)]: \(oneValueAvailableActions)\n"
                availableActionsElementIndex += 1
            }
            if hasDebugString {
                output += "\(indent) debugString: \(debugString) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUuid {
                    hashCode = (hashCode &* 31) &+ uuid.hashValue
                }
                if hasPhoto {
                    hashCode = (hashCode &* 31) &+ photo.hashValue
                }
                if hasFirstName {
                    hashCode = (hashCode &* 31) &+ firstName.hashValue
                }
                if hasLastName {
                    hashCode = (hashCode &* 31) &+ lastName.hashValue
                }
                if hasGender {
                    hashCode = (hashCode &* 31) &+ gender.hashValue
                }
                if hasPhone {
                    hashCode = (hashCode &* 31) &+ phone.hashValue
                }
                if hasEmail {
                    hashCode = (hashCode &* 31) &+ email.hashValue
                }
                if hasFacebookLink {
                    hashCode = (hashCode &* 31) &+ facebookLink.hashValue
                }
                if hasPresentLink {
                    hashCode = (hashCode &* 31) &+ presentLink.hashValue
                }
                if hasSignupTime {
                    hashCode = (hashCode &* 31) &+ signupTime.hashValue
                }
                if hasNotificationsEnabled {
                    hashCode = (hashCode &* 31) &+ notificationsEnabled.hashValue
                }
                if hasLastActivityTime {
                    hashCode = (hashCode &* 31) &+ lastActivityTime.hashValue
                }
                if hasSignupCity {
                    hashCode = (hashCode &* 31) &+ signupCity.hashValue
                }
                if hasSignupState {
                    hashCode = (hashCode &* 31) &+ signupState.hashValue
                }
                if hasSignupLat {
                    hashCode = (hashCode &* 31) &+ signupLat.hashValue
                }
                if hasSignupLong {
                    hashCode = (hashCode &* 31) &+ signupLong.hashValue
                }
                if hasSignupLocationAccuracy {
                    hashCode = (hashCode &* 31) &+ signupLocationAccuracy.hashValue
                }
                if hasUserState {
                    hashCode = (hashCode &* 31) &+ userState.hashValue
                }
                if hasReview {
                    hashCode = (hashCode &* 31) &+ review.hashValue
                }
                for oneValueClients in clients {
                    hashCode = (hashCode &* 31) &+ oneValueClients.hashValue
                }
                for oneValueAvailableActions in availableActions {
                    hashCode = (hashCode &* 31) &+ oneValueAvailableActions.hashValue
                }
                if hasDebugString {
                    hashCode = (hashCode &* 31) &+ debugString.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AdminUserResponse"
        }
        override public func className() -> String {
            return "Present.AdminUserResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AdminUserResponse = Present.AdminUserResponse()
            public func getMessage() -> Present.AdminUserResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// User uuid
            public var uuid:String {
                get {
                    return builderResult.uuid
                }
                set (value) {
                    builderResult.hasUuid = true
                    builderResult.uuid = value
                }
            }
            public var hasUuid:Bool {
                get {
                    return builderResult.hasUuid
                }
            }
            @discardableResult
            public func setUuid(_ value:String) -> Present.AdminUserResponse.Builder {
                self.uuid = value
                return self
            }
            @discardableResult
            public func clearUuid() -> Present.AdminUserResponse.Builder{
                builderResult.hasUuid = false
                builderResult.uuid = ""
                return self
            }
            /// URL to profile photo
            public var photo:String {
                get {
                    return builderResult.photo
                }
                set (value) {
                    builderResult.hasPhoto = true
                    builderResult.photo = value
                }
            }
            public var hasPhoto:Bool {
                get {
                    return builderResult.hasPhoto
                }
            }
            @discardableResult
            public func setPhoto(_ value:String) -> Present.AdminUserResponse.Builder {
                self.photo = value
                return self
            }
            @discardableResult
            public func clearPhoto() -> Present.AdminUserResponse.Builder{
                builderResult.hasPhoto = false
                builderResult.photo = ""
                return self
            }
            public var firstName:String {
                get {
                    return builderResult.firstName
                }
                set (value) {
                    builderResult.hasFirstName = true
                    builderResult.firstName = value
                }
            }
            public var hasFirstName:Bool {
                get {
                    return builderResult.hasFirstName
                }
            }
            @discardableResult
            public func setFirstName(_ value:String) -> Present.AdminUserResponse.Builder {
                self.firstName = value
                return self
            }
            @discardableResult
            public func clearFirstName() -> Present.AdminUserResponse.Builder{
                builderResult.hasFirstName = false
                builderResult.firstName = ""
                return self
            }
            public var lastName:String {
                get {
                    return builderResult.lastName
                }
                set (value) {
                    builderResult.hasLastName = true
                    builderResult.lastName = value
                }
            }
            public var hasLastName:Bool {
                get {
                    return builderResult.hasLastName
                }
            }
            @discardableResult
            public func setLastName(_ value:String) -> Present.AdminUserResponse.Builder {
                self.lastName = value
                return self
            }
            @discardableResult
            public func clearLastName() -> Present.AdminUserResponse.Builder{
                builderResult.hasLastName = false
                builderResult.lastName = ""
                return self
            }
            public var gender:String {
                get {
                    return builderResult.gender
                }
                set (value) {
                    builderResult.hasGender = true
                    builderResult.gender = value
                }
            }
            public var hasGender:Bool {
                get {
                    return builderResult.hasGender
                }
            }
            @discardableResult
            public func setGender(_ value:String) -> Present.AdminUserResponse.Builder {
                self.gender = value
                return self
            }
            @discardableResult
            public func clearGender() -> Present.AdminUserResponse.Builder{
                builderResult.hasGender = false
                builderResult.gender = ""
                return self
            }
            public var phone:String {
                get {
                    return builderResult.phone
                }
                set (value) {
                    builderResult.hasPhone = true
                    builderResult.phone = value
                }
            }
            public var hasPhone:Bool {
                get {
                    return builderResult.hasPhone
                }
            }
            @discardableResult
            public func setPhone(_ value:String) -> Present.AdminUserResponse.Builder {
                self.phone = value
                return self
            }
            @discardableResult
            public func clearPhone() -> Present.AdminUserResponse.Builder{
                builderResult.hasPhone = false
                builderResult.phone = ""
                return self
            }
            public var email:String {
                get {
                    return builderResult.email
                }
                set (value) {
                    builderResult.hasEmail = true
                    builderResult.email = value
                }
            }
            public var hasEmail:Bool {
                get {
                    return builderResult.hasEmail
                }
            }
            @discardableResult
            public func setEmail(_ value:String) -> Present.AdminUserResponse.Builder {
                self.email = value
                return self
            }
            @discardableResult
            public func clearEmail() -> Present.AdminUserResponse.Builder{
                builderResult.hasEmail = false
                builderResult.email = ""
                return self
            }
            /// Facebook profile url
            public var facebookLink:String {
                get {
                    return builderResult.facebookLink
                }
                set (value) {
                    builderResult.hasFacebookLink = true
                    builderResult.facebookLink = value
                }
            }
            public var hasFacebookLink:Bool {
                get {
                    return builderResult.hasFacebookLink
                }
            }
            @discardableResult
            public func setFacebookLink(_ value:String) -> Present.AdminUserResponse.Builder {
                self.facebookLink = value
                return self
            }
            @discardableResult
            public func clearFacebookLink() -> Present.AdminUserResponse.Builder{
                builderResult.hasFacebookLink = false
                builderResult.facebookLink = ""
                return self
            }
            /// Present profile url
            public var presentLink:String {
                get {
                    return builderResult.presentLink
                }
                set (value) {
                    builderResult.hasPresentLink = true
                    builderResult.presentLink = value
                }
            }
            public var hasPresentLink:Bool {
                get {
                    return builderResult.hasPresentLink
                }
            }
            @discardableResult
            public func setPresentLink(_ value:String) -> Present.AdminUserResponse.Builder {
                self.presentLink = value
                return self
            }
            @discardableResult
            public func clearPresentLink() -> Present.AdminUserResponse.Builder{
                builderResult.hasPresentLink = false
                builderResult.presentLink = ""
                return self
            }
            public var signupTime:UInt64 {
                get {
                    return builderResult.signupTime
                }
                set (value) {
                    builderResult.hasSignupTime = true
                    builderResult.signupTime = value
                }
            }
            public var hasSignupTime:Bool {
                get {
                    return builderResult.hasSignupTime
                }
            }
            @discardableResult
            public func setSignupTime(_ value:UInt64) -> Present.AdminUserResponse.Builder {
                self.signupTime = value
                return self
            }
            @discardableResult
            public func clearSignupTime() -> Present.AdminUserResponse.Builder{
                builderResult.hasSignupTime = false
                builderResult.signupTime = UInt64(0)
                return self
            }
            public var notificationsEnabled:Bool {
                get {
                    return builderResult.notificationsEnabled
                }
                set (value) {
                    builderResult.hasNotificationsEnabled = true
                    builderResult.notificationsEnabled = value
                }
            }
            public var hasNotificationsEnabled:Bool {
                get {
                    return builderResult.hasNotificationsEnabled
                }
            }
            @discardableResult
            public func setNotificationsEnabled(_ value:Bool) -> Present.AdminUserResponse.Builder {
                self.notificationsEnabled = value
                return self
            }
            @discardableResult
            public func clearNotificationsEnabled() -> Present.AdminUserResponse.Builder{
                builderResult.hasNotificationsEnabled = false
                builderResult.notificationsEnabled = false
                return self
            }
            public var lastActivityTime:UInt64 {
                get {
                    return builderResult.lastActivityTime
                }
                set (value) {
                    builderResult.hasLastActivityTime = true
                    builderResult.lastActivityTime = value
                }
            }
            public var hasLastActivityTime:Bool {
                get {
                    return builderResult.hasLastActivityTime
                }
            }
            @discardableResult
            public func setLastActivityTime(_ value:UInt64) -> Present.AdminUserResponse.Builder {
                self.lastActivityTime = value
                return self
            }
            @discardableResult
            public func clearLastActivityTime() -> Present.AdminUserResponse.Builder{
                builderResult.hasLastActivityTime = false
                builderResult.lastActivityTime = UInt64(0)
                return self
            }
            public var signupCity:String {
                get {
                    return builderResult.signupCity
                }
                set (value) {
                    builderResult.hasSignupCity = true
                    builderResult.signupCity = value
                }
            }
            public var hasSignupCity:Bool {
                get {
                    return builderResult.hasSignupCity
                }
            }
            @discardableResult
            public func setSignupCity(_ value:String) -> Present.AdminUserResponse.Builder {
                self.signupCity = value
                return self
            }
            @discardableResult
            public func clearSignupCity() -> Present.AdminUserResponse.Builder{
                builderResult.hasSignupCity = false
                builderResult.signupCity = ""
                return self
            }
            public var signupState:String {
                get {
                    return builderResult.signupState
                }
                set (value) {
                    builderResult.hasSignupState = true
                    builderResult.signupState = value
                }
            }
            public var hasSignupState:Bool {
                get {
                    return builderResult.hasSignupState
                }
            }
            @discardableResult
            public func setSignupState(_ value:String) -> Present.AdminUserResponse.Builder {
                self.signupState = value
                return self
            }
            @discardableResult
            public func clearSignupState() -> Present.AdminUserResponse.Builder{
                builderResult.hasSignupState = false
                builderResult.signupState = ""
                return self
            }
            public var signupLat:Double {
                get {
                    return builderResult.signupLat
                }
                set (value) {
                    builderResult.hasSignupLat = true
                    builderResult.signupLat = value
                }
            }
            public var hasSignupLat:Bool {
                get {
                    return builderResult.hasSignupLat
                }
            }
            @discardableResult
            public func setSignupLat(_ value:Double) -> Present.AdminUserResponse.Builder {
                self.signupLat = value
                return self
            }
            @discardableResult
            public func clearSignupLat() -> Present.AdminUserResponse.Builder{
                builderResult.hasSignupLat = false
                builderResult.signupLat = Double(0)
                return self
            }
            public var signupLong:Double {
                get {
                    return builderResult.signupLong
                }
                set (value) {
                    builderResult.hasSignupLong = true
                    builderResult.signupLong = value
                }
            }
            public var hasSignupLong:Bool {
                get {
                    return builderResult.hasSignupLong
                }
            }
            @discardableResult
            public func setSignupLong(_ value:Double) -> Present.AdminUserResponse.Builder {
                self.signupLong = value
                return self
            }
            @discardableResult
            public func clearSignupLong() -> Present.AdminUserResponse.Builder{
                builderResult.hasSignupLong = false
                builderResult.signupLong = Double(0)
                return self
            }
            public var signupLocationAccuracy:Double {
                get {
                    return builderResult.signupLocationAccuracy
                }
                set (value) {
                    builderResult.hasSignupLocationAccuracy = true
                    builderResult.signupLocationAccuracy = value
                }
            }
            public var hasSignupLocationAccuracy:Bool {
                get {
                    return builderResult.hasSignupLocationAccuracy
                }
            }
            @discardableResult
            public func setSignupLocationAccuracy(_ value:Double) -> Present.AdminUserResponse.Builder {
                self.signupLocationAccuracy = value
                return self
            }
            @discardableResult
            public func clearSignupLocationAccuracy() -> Present.AdminUserResponse.Builder{
                builderResult.hasSignupLocationAccuracy = false
                builderResult.signupLocationAccuracy = Double(0)
                return self
            }
            public var userState:String {
                get {
                    return builderResult.userState
                }
                set (value) {
                    builderResult.hasUserState = true
                    builderResult.userState = value
                }
            }
            public var hasUserState:Bool {
                get {
                    return builderResult.hasUserState
                }
            }
            @discardableResult
            public func setUserState(_ value:String) -> Present.AdminUserResponse.Builder {
                self.userState = value
                return self
            }
            @discardableResult
            public func clearUserState() -> Present.AdminUserResponse.Builder{
                builderResult.hasUserState = false
                builderResult.userState = ""
                return self
            }
            public var review:String {
                get {
                    return builderResult.review
                }
                set (value) {
                    builderResult.hasReview = true
                    builderResult.review = value
                }
            }
            public var hasReview:Bool {
                get {
                    return builderResult.hasReview
                }
            }
            @discardableResult
            public func setReview(_ value:String) -> Present.AdminUserResponse.Builder {
                self.review = value
                return self
            }
            @discardableResult
            public func clearReview() -> Present.AdminUserResponse.Builder{
                builderResult.hasReview = false
                builderResult.review = ""
                return self
            }
            public var clients:Array<String> {
                get {
                    return builderResult.clients
                }
                set (array) {
                    builderResult.clients = array
                }
            }
            @discardableResult
            public func setClients(_ value:Array<String>) -> Present.AdminUserResponse.Builder {
                self.clients = value
                return self
            }
            @discardableResult
            public func clearClients() -> Present.AdminUserResponse.Builder {
                builderResult.clients.removeAll(keepingCapacity: false)
                return self
            }
            public var availableActions:Array<String> {
                get {
                    return builderResult.availableActions
                }
                set (array) {
                    builderResult.availableActions = array
                }
            }
            @discardableResult
            public func setAvailableActions(_ value:Array<String>) -> Present.AdminUserResponse.Builder {
                self.availableActions = value
                return self
            }
            @discardableResult
            public func clearAvailableActions() -> Present.AdminUserResponse.Builder {
                builderResult.availableActions.removeAll(keepingCapacity: false)
                return self
            }
            public var debugString:String {
                get {
                    return builderResult.debugString
                }
                set (value) {
                    builderResult.hasDebugString = true
                    builderResult.debugString = value
                }
            }
            public var hasDebugString:Bool {
                get {
                    return builderResult.hasDebugString
                }
            }
            @discardableResult
            public func setDebugString(_ value:String) -> Present.AdminUserResponse.Builder {
                self.debugString = value
                return self
            }
            @discardableResult
            public func clearDebugString() -> Present.AdminUserResponse.Builder{
                builderResult.hasDebugString = false
                builderResult.debugString = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AdminUserResponse.Builder {
                builderResult = Present.AdminUserResponse()
                return self
            }
            override public func clone() throws -> Present.AdminUserResponse.Builder {
                return try Present.AdminUserResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AdminUserResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AdminUserResponse {
                let returnMe:Present.AdminUserResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AdminUserResponse) throws -> Present.AdminUserResponse.Builder {
                if other == Present.AdminUserResponse() {
                    return self
                }
                if other.hasUuid {
                    uuid = other.uuid
                }
                if other.hasPhoto {
                    photo = other.photo
                }
                if other.hasFirstName {
                    firstName = other.firstName
                }
                if other.hasLastName {
                    lastName = other.lastName
                }
                if other.hasGender {
                    gender = other.gender
                }
                if other.hasPhone {
                    phone = other.phone
                }
                if other.hasEmail {
                    email = other.email
                }
                if other.hasFacebookLink {
                    facebookLink = other.facebookLink
                }
                if other.hasPresentLink {
                    presentLink = other.presentLink
                }
                if other.hasSignupTime {
                    signupTime = other.signupTime
                }
                if other.hasNotificationsEnabled {
                    notificationsEnabled = other.notificationsEnabled
                }
                if other.hasLastActivityTime {
                    lastActivityTime = other.lastActivityTime
                }
                if other.hasSignupCity {
                    signupCity = other.signupCity
                }
                if other.hasSignupState {
                    signupState = other.signupState
                }
                if other.hasSignupLat {
                    signupLat = other.signupLat
                }
                if other.hasSignupLong {
                    signupLong = other.signupLong
                }
                if other.hasSignupLocationAccuracy {
                    signupLocationAccuracy = other.signupLocationAccuracy
                }
                if other.hasUserState {
                    userState = other.userState
                }
                if other.hasReview {
                    review = other.review
                }
                if !other.clients.isEmpty {
                    builderResult.clients += other.clients
                }
                if !other.availableActions.isEmpty {
                    builderResult.availableActions += other.availableActions
                }
                if other.hasDebugString {
                    debugString = other.debugString
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AdminUserResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminUserResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        uuid = try codedInputStream.readString()

                    case 18:
                        photo = try codedInputStream.readString()

                    case 26:
                        firstName = try codedInputStream.readString()

                    case 34:
                        lastName = try codedInputStream.readString()

                    case 42:
                        gender = try codedInputStream.readString()

                    case 50:
                        phone = try codedInputStream.readString()

                    case 58:
                        email = try codedInputStream.readString()

                    case 66:
                        facebookLink = try codedInputStream.readString()

                    case 74:
                        presentLink = try codedInputStream.readString()

                    case 80:
                        signupTime = try codedInputStream.readUInt64()

                    case 88:
                        notificationsEnabled = try codedInputStream.readBool()

                    case 96:
                        lastActivityTime = try codedInputStream.readUInt64()

                    case 106:
                        signupCity = try codedInputStream.readString()

                    case 114:
                        signupState = try codedInputStream.readString()

                    case 121:
                        signupLat = try codedInputStream.readDouble()

                    case 129:
                        signupLong = try codedInputStream.readDouble()

                    case 137:
                        signupLocationAccuracy = try codedInputStream.readDouble()

                    case 146:
                        userState = try codedInputStream.readString()

                    case 154:
                        review = try codedInputStream.readString()

                    case 162:
                        clients += [try codedInputStream.readString()]

                    case 170:
                        availableActions += [try codedInputStream.readString()]

                    case 178:
                        debugString = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AdminUserResponse.Builder {
                let resultDecodedBuilder = Present.AdminUserResponse.Builder()
                if let jsonValueUuid = jsonMap["uuid"] as? String {
                    resultDecodedBuilder.uuid = jsonValueUuid
                }
                if let jsonValuePhoto = jsonMap["photo"] as? String {
                    resultDecodedBuilder.photo = jsonValuePhoto
                }
                if let jsonValueFirstName = jsonMap["firstName"] as? String {
                    resultDecodedBuilder.firstName = jsonValueFirstName
                }
                if let jsonValueLastName = jsonMap["lastName"] as? String {
                    resultDecodedBuilder.lastName = jsonValueLastName
                }
                if let jsonValueGender = jsonMap["gender"] as? String {
                    resultDecodedBuilder.gender = jsonValueGender
                }
                if let jsonValuePhone = jsonMap["phone"] as? String {
                    resultDecodedBuilder.phone = jsonValuePhone
                }
                if let jsonValueEmail = jsonMap["email"] as? String {
                    resultDecodedBuilder.email = jsonValueEmail
                }
                if let jsonValueFacebookLink = jsonMap["facebookLink"] as? String {
                    resultDecodedBuilder.facebookLink = jsonValueFacebookLink
                }
                if let jsonValuePresentLink = jsonMap["presentLink"] as? String {
                    resultDecodedBuilder.presentLink = jsonValuePresentLink
                }
                if let jsonValueSignupTime = jsonMap["signupTime"] as? String {
                    resultDecodedBuilder.signupTime = UInt64(jsonValueSignupTime)!
                } else if let jsonValueSignupTime = jsonMap["signupTime"] as? UInt {
                    resultDecodedBuilder.signupTime = UInt64(jsonValueSignupTime)
                }
                if let jsonValueNotificationsEnabled = jsonMap["notificationsEnabled"] as? Bool {
                    resultDecodedBuilder.notificationsEnabled = jsonValueNotificationsEnabled
                }
                if let jsonValueLastActivityTime = jsonMap["lastActivityTime"] as? String {
                    resultDecodedBuilder.lastActivityTime = UInt64(jsonValueLastActivityTime)!
                } else if let jsonValueLastActivityTime = jsonMap["lastActivityTime"] as? UInt {
                    resultDecodedBuilder.lastActivityTime = UInt64(jsonValueLastActivityTime)
                }
                if let jsonValueSignupCity = jsonMap["signupCity"] as? String {
                    resultDecodedBuilder.signupCity = jsonValueSignupCity
                }
                if let jsonValueSignupState = jsonMap["signupState"] as? String {
                    resultDecodedBuilder.signupState = jsonValueSignupState
                }
                if let jsonValueSignupLat = jsonMap["signupLat"] as? Double {
                    resultDecodedBuilder.signupLat = Double(jsonValueSignupLat)
                } else if let jsonValueSignupLat = jsonMap["signupLat"] as? String {
                    resultDecodedBuilder.signupLat = Double(jsonValueSignupLat)!
                }
                if let jsonValueSignupLong = jsonMap["signupLong"] as? Double {
                    resultDecodedBuilder.signupLong = Double(jsonValueSignupLong)
                } else if let jsonValueSignupLong = jsonMap["signupLong"] as? String {
                    resultDecodedBuilder.signupLong = Double(jsonValueSignupLong)!
                }
                if let jsonValueSignupLocationAccuracy = jsonMap["signupLocationAccuracy"] as? Double {
                    resultDecodedBuilder.signupLocationAccuracy = Double(jsonValueSignupLocationAccuracy)
                } else if let jsonValueSignupLocationAccuracy = jsonMap["signupLocationAccuracy"] as? String {
                    resultDecodedBuilder.signupLocationAccuracy = Double(jsonValueSignupLocationAccuracy)!
                }
                if let jsonValueUserState = jsonMap["userState"] as? String {
                    resultDecodedBuilder.userState = jsonValueUserState
                }
                if let jsonValueReview = jsonMap["review"] as? String {
                    resultDecodedBuilder.review = jsonValueReview
                }
                if let jsonValueClients = jsonMap["clients"] as? Array<String> {
                    var jsonArrayClients:Array<String> = []
                    for oneValueClients in jsonValueClients {
                        jsonArrayClients.append(oneValueClients)
                    }
                    resultDecodedBuilder.clients = jsonArrayClients
                }
                if let jsonValueAvailableActions = jsonMap["availableActions"] as? Array<String> {
                    var jsonArrayAvailableActions:Array<String> = []
                    for oneValueAvailableActions in jsonValueAvailableActions {
                        jsonArrayAvailableActions.append(oneValueAvailableActions)
                    }
                    resultDecodedBuilder.availableActions = jsonArrayAvailableActions
                }
                if let jsonValueDebugString = jsonMap["debugString"] as? String {
                    resultDecodedBuilder.debugString = jsonValueDebugString
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AdminUserResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AdminUserResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RequestVerificationRequest : GeneratedMessage {

        public static func == (lhs: Present.RequestVerificationRequest, rhs: Present.RequestVerificationRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPhoneNumber == rhs.hasPhoneNumber) && (!lhs.hasPhoneNumber || lhs.phoneNumber == rhs.phoneNumber)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// U.S. phone number in E.164 format. Like "14155550000" (1 + 10 digits).
        public fileprivate(set) var phoneNumber:String = ""
        public fileprivate(set) var hasPhoneNumber:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasPhoneNumber {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPhoneNumber {
                try codedOutputStream.writeString(fieldNumber: 1, value:phoneNumber)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPhoneNumber {
                serialize_size += phoneNumber.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.RequestVerificationRequest.Builder {
            return Present.RequestVerificationRequest.classBuilder() as! Present.RequestVerificationRequest.Builder
        }
        public func getBuilder() -> Present.RequestVerificationRequest.Builder {
            return classBuilder() as! Present.RequestVerificationRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.RequestVerificationRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.RequestVerificationRequest.Builder()
        }
        public func toBuilder() throws -> Present.RequestVerificationRequest.Builder {
            return try Present.RequestVerificationRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.RequestVerificationRequest) throws -> Present.RequestVerificationRequest.Builder {
            return try Present.RequestVerificationRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPhoneNumber {
                jsonMap["phoneNumber"] = phoneNumber
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.RequestVerificationRequest {
            return try Present.RequestVerificationRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.RequestVerificationRequest {
            return try Present.RequestVerificationRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPhoneNumber {
                output += "\(indent) phoneNumber: \(phoneNumber) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPhoneNumber {
                    hashCode = (hashCode &* 31) &+ phoneNumber.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.RequestVerificationRequest"
        }
        override public func className() -> String {
            return "Present.RequestVerificationRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.RequestVerificationRequest = Present.RequestVerificationRequest()
            public func getMessage() -> Present.RequestVerificationRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// U.S. phone number in E.164 format. Like "14155550000" (1 + 10 digits).
            public var phoneNumber:String {
                get {
                    return builderResult.phoneNumber
                }
                set (value) {
                    builderResult.hasPhoneNumber = true
                    builderResult.phoneNumber = value
                }
            }
            public var hasPhoneNumber:Bool {
                get {
                    return builderResult.hasPhoneNumber
                }
            }
            @discardableResult
            public func setPhoneNumber(_ value:String) -> Present.RequestVerificationRequest.Builder {
                self.phoneNumber = value
                return self
            }
            @discardableResult
            public func clearPhoneNumber() -> Present.RequestVerificationRequest.Builder{
                builderResult.hasPhoneNumber = false
                builderResult.phoneNumber = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.RequestVerificationRequest.Builder {
                builderResult = Present.RequestVerificationRequest()
                return self
            }
            override public func clone() throws -> Present.RequestVerificationRequest.Builder {
                return try Present.RequestVerificationRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.RequestVerificationRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.RequestVerificationRequest {
                let returnMe:Present.RequestVerificationRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.RequestVerificationRequest) throws -> Present.RequestVerificationRequest.Builder {
                if other == Present.RequestVerificationRequest() {
                    return self
                }
                if other.hasPhoneNumber {
                    phoneNumber = other.phoneNumber
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.RequestVerificationRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.RequestVerificationRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        phoneNumber = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.RequestVerificationRequest.Builder {
                let resultDecodedBuilder = Present.RequestVerificationRequest.Builder()
                if let jsonValuePhoneNumber = jsonMap["phoneNumber"] as? String {
                    resultDecodedBuilder.phoneNumber = jsonValuePhoneNumber
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.RequestVerificationRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.RequestVerificationRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RequestVerificationResponse : GeneratedMessage {

        public static func == (lhs: Present.RequestVerificationResponse, rhs: Present.RequestVerificationResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCodeLength == rhs.hasCodeLength) && (!lhs.hasCodeLength || lhs.codeLength == rhs.codeLength)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var codeLength:UInt32 = UInt32(0)
        public fileprivate(set) var hasCodeLength:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasCodeLength {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCodeLength {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:codeLength)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCodeLength {
                serialize_size += codeLength.computeUInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.RequestVerificationResponse.Builder {
            return Present.RequestVerificationResponse.classBuilder() as! Present.RequestVerificationResponse.Builder
        }
        public func getBuilder() -> Present.RequestVerificationResponse.Builder {
            return classBuilder() as! Present.RequestVerificationResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.RequestVerificationResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.RequestVerificationResponse.Builder()
        }
        public func toBuilder() throws -> Present.RequestVerificationResponse.Builder {
            return try Present.RequestVerificationResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.RequestVerificationResponse) throws -> Present.RequestVerificationResponse.Builder {
            return try Present.RequestVerificationResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCodeLength {
                jsonMap["codeLength"] = UInt(codeLength)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.RequestVerificationResponse {
            return try Present.RequestVerificationResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.RequestVerificationResponse {
            return try Present.RequestVerificationResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCodeLength {
                output += "\(indent) codeLength: \(codeLength) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCodeLength {
                    hashCode = (hashCode &* 31) &+ codeLength.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.RequestVerificationResponse"
        }
        override public func className() -> String {
            return "Present.RequestVerificationResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.RequestVerificationResponse = Present.RequestVerificationResponse()
            public func getMessage() -> Present.RequestVerificationResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var codeLength:UInt32 {
                get {
                    return builderResult.codeLength
                }
                set (value) {
                    builderResult.hasCodeLength = true
                    builderResult.codeLength = value
                }
            }
            public var hasCodeLength:Bool {
                get {
                    return builderResult.hasCodeLength
                }
            }
            @discardableResult
            public func setCodeLength(_ value:UInt32) -> Present.RequestVerificationResponse.Builder {
                self.codeLength = value
                return self
            }
            @discardableResult
            public func clearCodeLength() -> Present.RequestVerificationResponse.Builder{
                builderResult.hasCodeLength = false
                builderResult.codeLength = UInt32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.RequestVerificationResponse.Builder {
                builderResult = Present.RequestVerificationResponse()
                return self
            }
            override public func clone() throws -> Present.RequestVerificationResponse.Builder {
                return try Present.RequestVerificationResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.RequestVerificationResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.RequestVerificationResponse {
                let returnMe:Present.RequestVerificationResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.RequestVerificationResponse) throws -> Present.RequestVerificationResponse.Builder {
                if other == Present.RequestVerificationResponse() {
                    return self
                }
                if other.hasCodeLength {
                    codeLength = other.codeLength
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.RequestVerificationResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.RequestVerificationResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        codeLength = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.RequestVerificationResponse.Builder {
                let resultDecodedBuilder = Present.RequestVerificationResponse.Builder()
                if let jsonValueCodeLength = jsonMap["codeLength"] as? UInt {
                    resultDecodedBuilder.codeLength = UInt32(jsonValueCodeLength)
                } else if let jsonValueCodeLength = jsonMap["codeLength"] as? String {
                    resultDecodedBuilder.codeLength = UInt32(jsonValueCodeLength)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.RequestVerificationResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.RequestVerificationResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class AddFriendResponse : GeneratedMessage {

        public static func == (lhs: Present.AddFriendResponse, rhs: Present.AddFriendResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
            fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var result:Present.FriendshipState = Present.FriendshipState.requested
        public fileprivate(set) var hasResult:Bool = false
        public fileprivate(set) var user:Present.UserResponse!
        public fileprivate(set) var hasUser:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasResult {
                return false
            }
            if !hasUser {
                return false
            }
            if !user.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasResult {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
            }
            if hasUser {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:user)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasResult) {
                serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasUser {
                if let varSizeuser = user?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeuser
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AddFriendResponse.Builder {
            return Present.AddFriendResponse.classBuilder() as! Present.AddFriendResponse.Builder
        }
        public func getBuilder() -> Present.AddFriendResponse.Builder {
            return classBuilder() as! Present.AddFriendResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AddFriendResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AddFriendResponse.Builder()
        }
        public func toBuilder() throws -> Present.AddFriendResponse.Builder {
            return try Present.AddFriendResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AddFriendResponse) throws -> Present.AddFriendResponse.Builder {
            return try Present.AddFriendResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasResult {
                jsonMap["result"] = result.toString()
            }
            if hasUser {
                jsonMap["user"] = try user.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AddFriendResponse {
            return try Present.AddFriendResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AddFriendResponse {
            return try Present.AddFriendResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasResult) {
                output += "\(indent) result: \(result.description)\n"
            }
            if hasUser {
                output += "\(indent) user {\n"
                if let outDescUser = user {
                    output += try outDescUser.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasResult {
                     hashCode = (hashCode &* 31) &+ result.hashValue
                }
                if hasUser {
                    if let hashValueuser = user?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuser
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AddFriendResponse"
        }
        override public func className() -> String {
            return "Present.AddFriendResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AddFriendResponse = Present.AddFriendResponse()
            public func getMessage() -> Present.AddFriendResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
                public var result:Present.FriendshipState {
                    get {
                        return builderResult.result
                    }
                    set (value) {
                        builderResult.hasResult = true
                        builderResult.result = value
                    }
                }
                public var hasResult:Bool{
                    get {
                        return builderResult.hasResult
                    }
                }
            @discardableResult
                public func setResult(_ value:Present.FriendshipState) -> Present.AddFriendResponse.Builder {
                  self.result = value
                  return self
                }
            @discardableResult
                public func clearResult() -> Present.AddFriendResponse.Builder {
                   builderResult.hasResult = false
                   builderResult.result = .requested
                   return self
                }
            /// The existing or newly created (placeholder) user added by the request.
            public var user:Present.UserResponse! {
                get {
                    if userBuilder_ != nil {
                        builderResult.user = userBuilder_.getMessage()
                    }
                    return builderResult.user
                }
                set (value) {
                    builderResult.hasUser = true
                    builderResult.user = value
                }
            }
            public var hasUser:Bool {
                get {
                    return builderResult.hasUser
                }
            }
            fileprivate var userBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasUser = true
                }
            }
            public func getUserBuilder() -> Present.UserResponse.Builder {
                if userBuilder_ == nil {
                    userBuilder_ = Present.UserResponse.Builder()
                    builderResult.user = userBuilder_.getMessage()
                    if user != nil {
                        try! userBuilder_.mergeFrom(other: user)
                    }
                }
                return userBuilder_
            }
            @discardableResult
            public func setUser(_ value:Present.UserResponse!) -> Present.AddFriendResponse.Builder {
                self.user = value
                return self
            }
            @discardableResult
            public func mergeUser(value:Present.UserResponse) throws -> Present.AddFriendResponse.Builder {
                if builderResult.hasUser {
                    builderResult.user = try Present.UserResponse.builderWithPrototype(prototype:builderResult.user).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.user = value
                }
                builderResult.hasUser = true
                return self
            }
            @discardableResult
            public func clearUser() -> Present.AddFriendResponse.Builder {
                userBuilder_ = nil
                builderResult.hasUser = false
                builderResult.user = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AddFriendResponse.Builder {
                builderResult = Present.AddFriendResponse()
                return self
            }
            override public func clone() throws -> Present.AddFriendResponse.Builder {
                return try Present.AddFriendResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AddFriendResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AddFriendResponse {
                let returnMe:Present.AddFriendResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AddFriendResponse) throws -> Present.AddFriendResponse.Builder {
                if other == Present.AddFriendResponse() {
                    return self
                }
                if other.hasResult {
                    result = other.result
                }
                if (other.hasUser) {
                    try mergeUser(value: other.user)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AddFriendResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddFriendResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntresult = try codedInputStream.readEnum()
                        if let enumsresult = Present.FriendshipState(rawValue:valueIntresult){
                            result = enumsresult
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
                        }

                    case 18:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasUser {
                            try subBuilder.mergeFrom(other: user)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        user = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AddFriendResponse.Builder {
                let resultDecodedBuilder = Present.AddFriendResponse.Builder()
                if let jsonValueResult = jsonMap["result"] as? String {
                    resultDecodedBuilder.result = try Present.FriendshipState.fromString(str: jsonValueResult)
                }
                if let jsonValueUser = jsonMap["user"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.user = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueUser).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AddFriendResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AddFriendResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ContactRequest : GeneratedMessage {

        public static func == (lhs: Present.ContactRequest, rhs: Present.ContactRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPhoneNumber == rhs.hasPhoneNumber) && (!lhs.hasPhoneNumber || lhs.phoneNumber == rhs.phoneNumber)
            fieldCheck = fieldCheck && (lhs.hasFullName == rhs.hasFullName) && (!lhs.hasFullName || lhs.fullName == rhs.fullName)
            fieldCheck = fieldCheck && (lhs.hasFirstName == rhs.hasFirstName) && (!lhs.hasFirstName || lhs.firstName == rhs.firstName)
            fieldCheck = fieldCheck && (lhs.hasLastName == rhs.hasLastName) && (!lhs.hasLastName || lhs.lastName == rhs.lastName)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Phone number in E.164 format.
        public fileprivate(set) var phoneNumber:String = ""
        public fileprivate(set) var hasPhoneNumber:Bool = false

        public fileprivate(set) var fullName:String = ""
        public fileprivate(set) var hasFullName:Bool = false

        public fileprivate(set) var firstName:String = ""
        public fileprivate(set) var hasFirstName:Bool = false

        public fileprivate(set) var lastName:String = ""
        public fileprivate(set) var hasLastName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasPhoneNumber {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPhoneNumber {
                try codedOutputStream.writeString(fieldNumber: 1, value:phoneNumber)
            }
            if hasFullName {
                try codedOutputStream.writeString(fieldNumber: 2, value:fullName)
            }
            if hasFirstName {
                try codedOutputStream.writeString(fieldNumber: 3, value:firstName)
            }
            if hasLastName {
                try codedOutputStream.writeString(fieldNumber: 4, value:lastName)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPhoneNumber {
                serialize_size += phoneNumber.computeStringSize(fieldNumber: 1)
            }
            if hasFullName {
                serialize_size += fullName.computeStringSize(fieldNumber: 2)
            }
            if hasFirstName {
                serialize_size += firstName.computeStringSize(fieldNumber: 3)
            }
            if hasLastName {
                serialize_size += lastName.computeStringSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.ContactRequest.Builder {
            return Present.ContactRequest.classBuilder() as! Present.ContactRequest.Builder
        }
        public func getBuilder() -> Present.ContactRequest.Builder {
            return classBuilder() as! Present.ContactRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ContactRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ContactRequest.Builder()
        }
        public func toBuilder() throws -> Present.ContactRequest.Builder {
            return try Present.ContactRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.ContactRequest) throws -> Present.ContactRequest.Builder {
            return try Present.ContactRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPhoneNumber {
                jsonMap["phoneNumber"] = phoneNumber
            }
            if hasFullName {
                jsonMap["fullName"] = fullName
            }
            if hasFirstName {
                jsonMap["firstName"] = firstName
            }
            if hasLastName {
                jsonMap["lastName"] = lastName
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.ContactRequest {
            return try Present.ContactRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.ContactRequest {
            return try Present.ContactRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPhoneNumber {
                output += "\(indent) phoneNumber: \(phoneNumber) \n"
            }
            if hasFullName {
                output += "\(indent) fullName: \(fullName) \n"
            }
            if hasFirstName {
                output += "\(indent) firstName: \(firstName) \n"
            }
            if hasLastName {
                output += "\(indent) lastName: \(lastName) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPhoneNumber {
                    hashCode = (hashCode &* 31) &+ phoneNumber.hashValue
                }
                if hasFullName {
                    hashCode = (hashCode &* 31) &+ fullName.hashValue
                }
                if hasFirstName {
                    hashCode = (hashCode &* 31) &+ firstName.hashValue
                }
                if hasLastName {
                    hashCode = (hashCode &* 31) &+ lastName.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.ContactRequest"
        }
        override public func className() -> String {
            return "Present.ContactRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.ContactRequest = Present.ContactRequest()
            public func getMessage() -> Present.ContactRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Phone number in E.164 format.
            public var phoneNumber:String {
                get {
                    return builderResult.phoneNumber
                }
                set (value) {
                    builderResult.hasPhoneNumber = true
                    builderResult.phoneNumber = value
                }
            }
            public var hasPhoneNumber:Bool {
                get {
                    return builderResult.hasPhoneNumber
                }
            }
            @discardableResult
            public func setPhoneNumber(_ value:String) -> Present.ContactRequest.Builder {
                self.phoneNumber = value
                return self
            }
            @discardableResult
            public func clearPhoneNumber() -> Present.ContactRequest.Builder{
                builderResult.hasPhoneNumber = false
                builderResult.phoneNumber = ""
                return self
            }
            public var fullName:String {
                get {
                    return builderResult.fullName
                }
                set (value) {
                    builderResult.hasFullName = true
                    builderResult.fullName = value
                }
            }
            public var hasFullName:Bool {
                get {
                    return builderResult.hasFullName
                }
            }
            @discardableResult
            public func setFullName(_ value:String) -> Present.ContactRequest.Builder {
                self.fullName = value
                return self
            }
            @discardableResult
            public func clearFullName() -> Present.ContactRequest.Builder{
                builderResult.hasFullName = false
                builderResult.fullName = ""
                return self
            }
            public var firstName:String {
                get {
                    return builderResult.firstName
                }
                set (value) {
                    builderResult.hasFirstName = true
                    builderResult.firstName = value
                }
            }
            public var hasFirstName:Bool {
                get {
                    return builderResult.hasFirstName
                }
            }
            @discardableResult
            public func setFirstName(_ value:String) -> Present.ContactRequest.Builder {
                self.firstName = value
                return self
            }
            @discardableResult
            public func clearFirstName() -> Present.ContactRequest.Builder{
                builderResult.hasFirstName = false
                builderResult.firstName = ""
                return self
            }
            public var lastName:String {
                get {
                    return builderResult.lastName
                }
                set (value) {
                    builderResult.hasLastName = true
                    builderResult.lastName = value
                }
            }
            public var hasLastName:Bool {
                get {
                    return builderResult.hasLastName
                }
            }
            @discardableResult
            public func setLastName(_ value:String) -> Present.ContactRequest.Builder {
                self.lastName = value
                return self
            }
            @discardableResult
            public func clearLastName() -> Present.ContactRequest.Builder{
                builderResult.hasLastName = false
                builderResult.lastName = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.ContactRequest.Builder {
                builderResult = Present.ContactRequest()
                return self
            }
            override public func clone() throws -> Present.ContactRequest.Builder {
                return try Present.ContactRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.ContactRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.ContactRequest {
                let returnMe:Present.ContactRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.ContactRequest) throws -> Present.ContactRequest.Builder {
                if other == Present.ContactRequest() {
                    return self
                }
                if other.hasPhoneNumber {
                    phoneNumber = other.phoneNumber
                }
                if other.hasFullName {
                    fullName = other.fullName
                }
                if other.hasFirstName {
                    firstName = other.firstName
                }
                if other.hasLastName {
                    lastName = other.lastName
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.ContactRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ContactRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        phoneNumber = try codedInputStream.readString()

                    case 18:
                        fullName = try codedInputStream.readString()

                    case 26:
                        firstName = try codedInputStream.readString()

                    case 34:
                        lastName = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.ContactRequest.Builder {
                let resultDecodedBuilder = Present.ContactRequest.Builder()
                if let jsonValuePhoneNumber = jsonMap["phoneNumber"] as? String {
                    resultDecodedBuilder.phoneNumber = jsonValuePhoneNumber
                }
                if let jsonValueFullName = jsonMap["fullName"] as? String {
                    resultDecodedBuilder.fullName = jsonValueFullName
                }
                if let jsonValueFirstName = jsonMap["firstName"] as? String {
                    resultDecodedBuilder.firstName = jsonValueFirstName
                }
                if let jsonValueLastName = jsonMap["lastName"] as? String {
                    resultDecodedBuilder.lastName = jsonValueLastName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.ContactRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.ContactRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class AddContactsRequest : GeneratedMessage {

        public static func == (lhs: Present.AddContactsRequest, rhs: Present.AddContactsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.contacts == rhs.contacts)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var contacts:Array<Present.ContactRequest>  = Array<Present.ContactRequest>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitContacts:Bool = true
            for oneElementContacts in contacts {
                if !oneElementContacts.isInitialized() {
                    isInitContacts = false
                    break 
                }
            }
            if !isInitContacts {
                return isInitContacts
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementContacts in contacts {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementContacts)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementContacts in contacts {
                serialize_size += oneElementContacts.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AddContactsRequest.Builder {
            return Present.AddContactsRequest.classBuilder() as! Present.AddContactsRequest.Builder
        }
        public func getBuilder() -> Present.AddContactsRequest.Builder {
            return classBuilder() as! Present.AddContactsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AddContactsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AddContactsRequest.Builder()
        }
        public func toBuilder() throws -> Present.AddContactsRequest.Builder {
            return try Present.AddContactsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AddContactsRequest) throws -> Present.AddContactsRequest.Builder {
            return try Present.AddContactsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !contacts.isEmpty {
                var jsonArrayContacts:Array<Dictionary<String,Any>> = []
                for oneValueContacts in contacts {
                    let ecodedMessageContacts = try oneValueContacts.encode()
                    jsonArrayContacts.append(ecodedMessageContacts)
                }
                jsonMap["contacts"] = jsonArrayContacts
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AddContactsRequest {
            return try Present.AddContactsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AddContactsRequest {
            return try Present.AddContactsRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var contactsElementIndex:Int = 0
            for oneElementContacts in contacts {
                output += "\(indent) contacts[\(contactsElementIndex)] {\n"
                output += try oneElementContacts.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                contactsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementContacts in contacts {
                    hashCode = (hashCode &* 31) &+ oneElementContacts.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AddContactsRequest"
        }
        override public func className() -> String {
            return "Present.AddContactsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AddContactsRequest = Present.AddContactsRequest()
            public func getMessage() -> Present.AddContactsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var contacts:Array<Present.ContactRequest> {
                get {
                    return builderResult.contacts
                }
                set (value) {
                    builderResult.contacts = value
                }
            }
            @discardableResult
            public func setContacts(_ value:Array<Present.ContactRequest>) -> Present.AddContactsRequest.Builder {
                self.contacts = value
                return self
            }
            @discardableResult
            public func clearContacts() -> Present.AddContactsRequest.Builder {
                builderResult.contacts.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AddContactsRequest.Builder {
                builderResult = Present.AddContactsRequest()
                return self
            }
            override public func clone() throws -> Present.AddContactsRequest.Builder {
                return try Present.AddContactsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AddContactsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AddContactsRequest {
                let returnMe:Present.AddContactsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AddContactsRequest) throws -> Present.AddContactsRequest.Builder {
                if other == Present.AddContactsRequest() {
                    return self
                }
                if !other.contacts.isEmpty  {
                     builderResult.contacts += other.contacts
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AddContactsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddContactsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.ContactRequest.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        contacts.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AddContactsRequest.Builder {
                let resultDecodedBuilder = Present.AddContactsRequest.Builder()
                if let jsonValueContacts = jsonMap["contacts"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayContacts:Array<Present.ContactRequest> = []
                    for oneValueContacts in jsonValueContacts {
                        let messageFromStringContacts = try Present.ContactRequest.Builder.decodeToBuilder(jsonMap:oneValueContacts).build()

                        jsonArrayContacts.append(messageFromStringContacts)
                    }
                    resultDecodedBuilder.contacts = jsonArrayContacts
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AddContactsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AddContactsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PhoneUserResponse : GeneratedMessage {

        public static func == (lhs: Present.PhoneUserResponse, rhs: Present.PhoneUserResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPhoneNumber == rhs.hasPhoneNumber) && (!lhs.hasPhoneNumber || lhs.phoneNumber == rhs.phoneNumber)
            fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var phoneNumber:String = ""
        public fileprivate(set) var hasPhoneNumber:Bool = false

        public fileprivate(set) var user:Present.UserResponse!
        public fileprivate(set) var hasUser:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasPhoneNumber {
                return false
            }
            if !hasUser {
                return false
            }
            if !user.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPhoneNumber {
                try codedOutputStream.writeString(fieldNumber: 1, value:phoneNumber)
            }
            if hasUser {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:user)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPhoneNumber {
                serialize_size += phoneNumber.computeStringSize(fieldNumber: 1)
            }
            if hasUser {
                if let varSizeuser = user?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeuser
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PhoneUserResponse.Builder {
            return Present.PhoneUserResponse.classBuilder() as! Present.PhoneUserResponse.Builder
        }
        public func getBuilder() -> Present.PhoneUserResponse.Builder {
            return classBuilder() as! Present.PhoneUserResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PhoneUserResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PhoneUserResponse.Builder()
        }
        public func toBuilder() throws -> Present.PhoneUserResponse.Builder {
            return try Present.PhoneUserResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PhoneUserResponse) throws -> Present.PhoneUserResponse.Builder {
            return try Present.PhoneUserResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPhoneNumber {
                jsonMap["phoneNumber"] = phoneNumber
            }
            if hasUser {
                jsonMap["user"] = try user.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PhoneUserResponse {
            return try Present.PhoneUserResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PhoneUserResponse {
            return try Present.PhoneUserResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPhoneNumber {
                output += "\(indent) phoneNumber: \(phoneNumber) \n"
            }
            if hasUser {
                output += "\(indent) user {\n"
                if let outDescUser = user {
                    output += try outDescUser.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPhoneNumber {
                    hashCode = (hashCode &* 31) &+ phoneNumber.hashValue
                }
                if hasUser {
                    if let hashValueuser = user?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuser
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PhoneUserResponse"
        }
        override public func className() -> String {
            return "Present.PhoneUserResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PhoneUserResponse = Present.PhoneUserResponse()
            public func getMessage() -> Present.PhoneUserResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var phoneNumber:String {
                get {
                    return builderResult.phoneNumber
                }
                set (value) {
                    builderResult.hasPhoneNumber = true
                    builderResult.phoneNumber = value
                }
            }
            public var hasPhoneNumber:Bool {
                get {
                    return builderResult.hasPhoneNumber
                }
            }
            @discardableResult
            public func setPhoneNumber(_ value:String) -> Present.PhoneUserResponse.Builder {
                self.phoneNumber = value
                return self
            }
            @discardableResult
            public func clearPhoneNumber() -> Present.PhoneUserResponse.Builder{
                builderResult.hasPhoneNumber = false
                builderResult.phoneNumber = ""
                return self
            }
            public var user:Present.UserResponse! {
                get {
                    if userBuilder_ != nil {
                        builderResult.user = userBuilder_.getMessage()
                    }
                    return builderResult.user
                }
                set (value) {
                    builderResult.hasUser = true
                    builderResult.user = value
                }
            }
            public var hasUser:Bool {
                get {
                    return builderResult.hasUser
                }
            }
            fileprivate var userBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasUser = true
                }
            }
            public func getUserBuilder() -> Present.UserResponse.Builder {
                if userBuilder_ == nil {
                    userBuilder_ = Present.UserResponse.Builder()
                    builderResult.user = userBuilder_.getMessage()
                    if user != nil {
                        try! userBuilder_.mergeFrom(other: user)
                    }
                }
                return userBuilder_
            }
            @discardableResult
            public func setUser(_ value:Present.UserResponse!) -> Present.PhoneUserResponse.Builder {
                self.user = value
                return self
            }
            @discardableResult
            public func mergeUser(value:Present.UserResponse) throws -> Present.PhoneUserResponse.Builder {
                if builderResult.hasUser {
                    builderResult.user = try Present.UserResponse.builderWithPrototype(prototype:builderResult.user).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.user = value
                }
                builderResult.hasUser = true
                return self
            }
            @discardableResult
            public func clearUser() -> Present.PhoneUserResponse.Builder {
                userBuilder_ = nil
                builderResult.hasUser = false
                builderResult.user = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PhoneUserResponse.Builder {
                builderResult = Present.PhoneUserResponse()
                return self
            }
            override public func clone() throws -> Present.PhoneUserResponse.Builder {
                return try Present.PhoneUserResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PhoneUserResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PhoneUserResponse {
                let returnMe:Present.PhoneUserResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PhoneUserResponse) throws -> Present.PhoneUserResponse.Builder {
                if other == Present.PhoneUserResponse() {
                    return self
                }
                if other.hasPhoneNumber {
                    phoneNumber = other.phoneNumber
                }
                if (other.hasUser) {
                    try mergeUser(value: other.user)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PhoneUserResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PhoneUserResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        phoneNumber = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasUser {
                            try subBuilder.mergeFrom(other: user)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        user = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PhoneUserResponse.Builder {
                let resultDecodedBuilder = Present.PhoneUserResponse.Builder()
                if let jsonValuePhoneNumber = jsonMap["phoneNumber"] as? String {
                    resultDecodedBuilder.phoneNumber = jsonValuePhoneNumber
                }
                if let jsonValueUser = jsonMap["user"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.user = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueUser).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PhoneUserResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PhoneUserResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class AddContactsResponse : GeneratedMessage {

        public static func == (lhs: Present.AddContactsResponse, rhs: Present.AddContactsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.results == rhs.results)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var results:Array<Present.PhoneUserResponse>  = Array<Present.PhoneUserResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitResults:Bool = true
            for oneElementResults in results {
                if !oneElementResults.isInitialized() {
                    isInitResults = false
                    break 
                }
            }
            if !isInitResults {
                return isInitResults
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementResults in results {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementResults)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementResults in results {
                serialize_size += oneElementResults.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AddContactsResponse.Builder {
            return Present.AddContactsResponse.classBuilder() as! Present.AddContactsResponse.Builder
        }
        public func getBuilder() -> Present.AddContactsResponse.Builder {
            return classBuilder() as! Present.AddContactsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AddContactsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AddContactsResponse.Builder()
        }
        public func toBuilder() throws -> Present.AddContactsResponse.Builder {
            return try Present.AddContactsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AddContactsResponse) throws -> Present.AddContactsResponse.Builder {
            return try Present.AddContactsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !results.isEmpty {
                var jsonArrayResults:Array<Dictionary<String,Any>> = []
                for oneValueResults in results {
                    let ecodedMessageResults = try oneValueResults.encode()
                    jsonArrayResults.append(ecodedMessageResults)
                }
                jsonMap["results"] = jsonArrayResults
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AddContactsResponse {
            return try Present.AddContactsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AddContactsResponse {
            return try Present.AddContactsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var resultsElementIndex:Int = 0
            for oneElementResults in results {
                output += "\(indent) results[\(resultsElementIndex)] {\n"
                output += try oneElementResults.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                resultsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementResults in results {
                    hashCode = (hashCode &* 31) &+ oneElementResults.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AddContactsResponse"
        }
        override public func className() -> String {
            return "Present.AddContactsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AddContactsResponse = Present.AddContactsResponse()
            public func getMessage() -> Present.AddContactsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var results:Array<Present.PhoneUserResponse> {
                get {
                    return builderResult.results
                }
                set (value) {
                    builderResult.results = value
                }
            }
            @discardableResult
            public func setResults(_ value:Array<Present.PhoneUserResponse>) -> Present.AddContactsResponse.Builder {
                self.results = value
                return self
            }
            @discardableResult
            public func clearResults() -> Present.AddContactsResponse.Builder {
                builderResult.results.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AddContactsResponse.Builder {
                builderResult = Present.AddContactsResponse()
                return self
            }
            override public func clone() throws -> Present.AddContactsResponse.Builder {
                return try Present.AddContactsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AddContactsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AddContactsResponse {
                let returnMe:Present.AddContactsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AddContactsResponse) throws -> Present.AddContactsResponse.Builder {
                if other == Present.AddContactsResponse() {
                    return self
                }
                if !other.results.isEmpty  {
                     builderResult.results += other.results
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AddContactsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddContactsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.PhoneUserResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        results.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AddContactsResponse.Builder {
                let resultDecodedBuilder = Present.AddContactsResponse.Builder()
                if let jsonValueResults = jsonMap["results"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayResults:Array<Present.PhoneUserResponse> = []
                    for oneValueResults in jsonValueResults {
                        let messageFromStringResults = try Present.PhoneUserResponse.Builder.decodeToBuilder(jsonMap:oneValueResults).build()

                        jsonArrayResults.append(messageFromStringResults)
                    }
                    resultDecodedBuilder.results = jsonArrayResults
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AddContactsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AddContactsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Present.Authorization: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.Authorization> {
        var mergedArray = Array<Present.Authorization>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.Authorization? {
        return try Present.Authorization.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.Authorization {
        return try Present.Authorization.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.Authorization {
        return try Present.Authorization.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.Authorization {
        return try Present.Authorization.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Authorization {
        return try Present.Authorization.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.Authorization {
        return try Present.Authorization.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Authorization {
        return try Present.Authorization.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nextStep": return self.nextStep
        case "blockScreen": return self.blockScreen
        default: return nil
        }
    }
}
extension Present.Authorization.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nextStep": return self.nextStep
            case "blockScreen": return self.blockScreen
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nextStep":
                guard let newSubscriptValue = newSubscriptValue as? Present.Authorization.NextStep else {
                    return
                }
                self.nextStep = newSubscriptValue
            case "blockScreen":
                guard let newSubscriptValue = newSubscriptValue as? Present.BlockScreen else {
                    return
                }
                self.blockScreen = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.BlockScreen: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.BlockScreen> {
        var mergedArray = Array<Present.BlockScreen>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.BlockScreen? {
        return try Present.BlockScreen.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.BlockScreen {
        return try Present.BlockScreen.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.BlockScreen {
        return try Present.BlockScreen.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.BlockScreen {
        return try Present.BlockScreen.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.BlockScreen {
        return try Present.BlockScreen.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.BlockScreen {
        return try Present.BlockScreen.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.BlockScreen {
        return try Present.BlockScreen.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "text": return self.text
        default: return nil
        }
    }
}
extension Present.BlockScreen.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "text": return self.text
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "text":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.text = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.LinkFacebookRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.LinkFacebookRequest> {
        var mergedArray = Array<Present.LinkFacebookRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.LinkFacebookRequest? {
        return try Present.LinkFacebookRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.LinkFacebookRequest {
        return try Present.LinkFacebookRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.LinkFacebookRequest {
        return try Present.LinkFacebookRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.LinkFacebookRequest {
        return try Present.LinkFacebookRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LinkFacebookRequest {
        return try Present.LinkFacebookRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.LinkFacebookRequest {
        return try Present.LinkFacebookRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LinkFacebookRequest {
        return try Present.LinkFacebookRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "accessToken": return self.accessToken
        case "facebookId": return self.facebookId
        default: return nil
        }
    }
}
extension Present.LinkFacebookRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "accessToken": return self.accessToken
            case "facebookId": return self.facebookId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "accessToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.accessToken = newSubscriptValue
            case "facebookId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.facebookId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AuthorizationResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AuthorizationResponse> {
        var mergedArray = Array<Present.AuthorizationResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AuthorizationResponse? {
        return try Present.AuthorizationResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AuthorizationResponse {
        return try Present.AuthorizationResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AuthorizationResponse {
        return try Present.AuthorizationResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AuthorizationResponse {
        return try Present.AuthorizationResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AuthorizationResponse {
        return try Present.AuthorizationResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AuthorizationResponse {
        return try Present.AuthorizationResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AuthorizationResponse {
        return try Present.AuthorizationResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "authorization": return self.authorization
        case "userProfile": return self.userProfile
        default: return nil
        }
    }
}
extension Present.AuthorizationResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "authorization": return self.authorization
            case "userProfile": return self.userProfile
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "authorization":
                guard let newSubscriptValue = newSubscriptValue as? Present.Authorization else {
                    return
                }
                self.authorization = newSubscriptValue
            case "userProfile":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserProfile else {
                    return
                }
                self.userProfile = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.SynchronizeResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.SynchronizeResponse> {
        var mergedArray = Array<Present.SynchronizeResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.SynchronizeResponse? {
        return try Present.SynchronizeResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.SynchronizeResponse {
        return try Present.SynchronizeResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.SynchronizeResponse {
        return try Present.SynchronizeResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.SynchronizeResponse {
        return try Present.SynchronizeResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SynchronizeResponse {
        return try Present.SynchronizeResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.SynchronizeResponse {
        return try Present.SynchronizeResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SynchronizeResponse {
        return try Present.SynchronizeResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "authorization": return self.authorization
        case "userProfile": return self.userProfile
        case "features": return self.features
        default: return nil
        }
    }
}
extension Present.SynchronizeResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "authorization": return self.authorization
            case "userProfile": return self.userProfile
            case "features": return self.features
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "authorization":
                guard let newSubscriptValue = newSubscriptValue as? Present.Authorization else {
                    return
                }
                self.authorization = newSubscriptValue
            case "userProfile":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserProfile else {
                    return
                }
                self.userProfile = newSubscriptValue
            case "features":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.Feature> else {
                    return
                }
                self.features = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UserResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UserResponse> {
        var mergedArray = Array<Present.UserResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UserResponse? {
        return try Present.UserResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UserResponse {
        return try Present.UserResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UserResponse {
        return try Present.UserResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UserResponse {
        return try Present.UserResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserResponse {
        return try Present.UserResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UserResponse {
        return try Present.UserResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserResponse {
        return try Present.UserResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "name": return self.name
        case "firstName": return self.firstName
        case "photo": return self.photo
        case "bio": return self.bio
        case "interests": return self.interests
        case "friends": return self.friends
        case "signupLocation": return self.signupLocation
        case "link": return self.link
        case "member": return self.member
        default: return nil
        }
    }
}
extension Present.UserResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "name": return self.name
            case "firstName": return self.firstName
            case "photo": return self.photo
            case "bio": return self.bio
            case "interests": return self.interests
            case "friends": return self.friends
            case "signupLocation": return self.signupLocation
            case "link": return self.link
            case "member": return self.member
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.id = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "firstName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.firstName = newSubscriptValue
            case "photo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.photo = newSubscriptValue
            case "bio":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.bio = newSubscriptValue
            case "interests":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.interests = newSubscriptValue
            case "friends":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.FriendResponse> else {
                    return
                }
                self.friends = newSubscriptValue
            case "signupLocation":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.signupLocation = newSubscriptValue
            case "link":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.link = newSubscriptValue
            case "member":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.member = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.FriendResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.FriendResponse> {
        var mergedArray = Array<Present.FriendResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.FriendResponse? {
        return try Present.FriendResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.FriendResponse {
        return try Present.FriendResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.FriendResponse {
        return try Present.FriendResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.FriendResponse {
        return try Present.FriendResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FriendResponse {
        return try Present.FriendResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.FriendResponse {
        return try Present.FriendResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FriendResponse {
        return try Present.FriendResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "user": return self.user
        default: return nil
        }
    }
}
extension Present.FriendResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "user": return self.user
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "user":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.user = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UsersResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UsersResponse> {
        var mergedArray = Array<Present.UsersResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UsersResponse? {
        return try Present.UsersResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UsersResponse {
        return try Present.UsersResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UsersResponse {
        return try Present.UsersResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UsersResponse {
        return try Present.UsersResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UsersResponse {
        return try Present.UsersResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UsersResponse {
        return try Present.UsersResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UsersResponse {
        return try Present.UsersResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "users": return self.users
        default: return nil
        }
    }
}
extension Present.UsersResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "users": return self.users
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "users":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.UserResponse> else {
                    return
                }
                self.users = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UserName: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UserName> {
        var mergedArray = Array<Present.UserName>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UserName? {
        return try Present.UserName.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UserName {
        return try Present.UserName.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UserName {
        return try Present.UserName.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UserName {
        return try Present.UserName.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserName {
        return try Present.UserName.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UserName {
        return try Present.UserName.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserName {
        return try Present.UserName.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "first": return self.first
        case "last": return self.last
        default: return nil
        }
    }
}
extension Present.UserName.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "first": return self.first
            case "last": return self.last
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "first":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.first = newSubscriptValue
            case "last":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.last = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UserNotificationSettings: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UserNotificationSettings> {
        var mergedArray = Array<Present.UserNotificationSettings>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UserNotificationSettings? {
        return try Present.UserNotificationSettings.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UserNotificationSettings {
        return try Present.UserNotificationSettings.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UserNotificationSettings {
        return try Present.UserNotificationSettings.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UserNotificationSettings {
        return try Present.UserNotificationSettings.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserNotificationSettings {
        return try Present.UserNotificationSettings.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UserNotificationSettings {
        return try Present.UserNotificationSettings.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserNotificationSettings {
        return try Present.UserNotificationSettings.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "deprecatedOwnedGroups": return self.deprecatedOwnedGroups
        case "deprecatedFavoritedGroups": return self.deprecatedFavoritedGroups
        case "deprecatedContributedGroups": return self.deprecatedContributedGroups
        case "userCommentsOnJoinedGroup": return self.userCommentsOnJoinedGroup
        case "userJoinsOwnedGroup": return self.userJoinsOwnedGroup
        case "affirmations": return self.affirmations
        default: return nil
        }
    }
}
extension Present.UserNotificationSettings.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "deprecatedOwnedGroups": return self.deprecatedOwnedGroups
            case "deprecatedFavoritedGroups": return self.deprecatedFavoritedGroups
            case "deprecatedContributedGroups": return self.deprecatedContributedGroups
            case "userCommentsOnJoinedGroup": return self.userCommentsOnJoinedGroup
            case "userJoinsOwnedGroup": return self.userJoinsOwnedGroup
            case "affirmations": return self.affirmations
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "deprecatedOwnedGroups":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.deprecatedOwnedGroups = newSubscriptValue
            case "deprecatedFavoritedGroups":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.deprecatedFavoritedGroups = newSubscriptValue
            case "deprecatedContributedGroups":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.deprecatedContributedGroups = newSubscriptValue
            case "userCommentsOnJoinedGroup":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.userCommentsOnJoinedGroup = newSubscriptValue
            case "userJoinsOwnedGroup":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.userJoinsOwnedGroup = newSubscriptValue
            case "affirmations":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.affirmations = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UserProfile: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UserProfile> {
        var mergedArray = Array<Present.UserProfile>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UserProfile? {
        return try Present.UserProfile.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UserProfile {
        return try Present.UserProfile.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UserProfile {
        return try Present.UserProfile.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UserProfile {
        return try Present.UserProfile.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserProfile {
        return try Present.UserProfile.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UserProfile {
        return try Present.UserProfile.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserProfile {
        return try Present.UserProfile.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "name": return self.name
        case "photo": return self.photo
        case "bio": return self.bio
        case "interests": return self.interests
        case "friends": return self.friends
        case "notificationSettings": return self.notificationSettings
        case "isAdmin": return self.isAdmin
        case "appShareLink": return self.appShareLink
        case "home": return self.home
        case "link": return self.link
        case "gender": return self.gender
        case "facebookLinked": return self.facebookLinked
        case "phoneVerified": return self.phoneVerified
        case "incomingFriendRequests": return self.incomingFriendRequests
        default: return nil
        }
    }
}
extension Present.UserProfile.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "name": return self.name
            case "photo": return self.photo
            case "bio": return self.bio
            case "interests": return self.interests
            case "friends": return self.friends
            case "notificationSettings": return self.notificationSettings
            case "isAdmin": return self.isAdmin
            case "appShareLink": return self.appShareLink
            case "home": return self.home
            case "link": return self.link
            case "gender": return self.gender
            case "facebookLinked": return self.facebookLinked
            case "phoneVerified": return self.phoneVerified
            case "incomingFriendRequests": return self.incomingFriendRequests
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.id = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserName else {
                    return
                }
                self.name = newSubscriptValue
            case "photo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.photo = newSubscriptValue
            case "bio":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.bio = newSubscriptValue
            case "interests":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.interests = newSubscriptValue
            case "friends":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.FriendResponse> else {
                    return
                }
                self.friends = newSubscriptValue
            case "notificationSettings":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserNotificationSettings else {
                    return
                }
                self.notificationSettings = newSubscriptValue
            case "isAdmin":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isAdmin = newSubscriptValue
            case "appShareLink":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.appShareLink = newSubscriptValue
            case "home":
                guard let newSubscriptValue = newSubscriptValue as? Present.City else {
                    return
                }
                self.home = newSubscriptValue
            case "link":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.link = newSubscriptValue
            case "gender":
                guard let newSubscriptValue = newSubscriptValue as? Present.Gender else {
                    return
                }
                self.gender = newSubscriptValue
            case "facebookLinked":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.facebookLinked = newSubscriptValue
            case "phoneVerified":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.phoneVerified = newSubscriptValue
            case "incomingFriendRequests":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.incomingFriendRequests = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UserProfileRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UserProfileRequest> {
        var mergedArray = Array<Present.UserProfileRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UserProfileRequest? {
        return try Present.UserProfileRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UserProfileRequest {
        return try Present.UserProfileRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UserProfileRequest {
        return try Present.UserProfileRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UserProfileRequest {
        return try Present.UserProfileRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserProfileRequest {
        return try Present.UserProfileRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UserProfileRequest {
        return try Present.UserProfileRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserProfileRequest {
        return try Present.UserProfileRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "photo": return self.photo
        case "bio": return self.bio
        case "interests": return self.interests
        case "zip": return self.zip
        case "notificationSettings": return self.notificationSettings
        default: return nil
        }
    }
}
extension Present.UserProfileRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "photo": return self.photo
            case "bio": return self.bio
            case "interests": return self.interests
            case "zip": return self.zip
            case "notificationSettings": return self.notificationSettings
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserName else {
                    return
                }
                self.name = newSubscriptValue
            case "photo":
                guard let newSubscriptValue = newSubscriptValue as? Present.ContentReferenceRequest else {
                    return
                }
                self.photo = newSubscriptValue
            case "bio":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.bio = newSubscriptValue
            case "interests":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.interests = newSubscriptValue
            case "zip":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.zip = newSubscriptValue
            case "notificationSettings":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserNotificationSettings else {
                    return
                }
                self.notificationSettings = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.PutUserPhotoRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PutUserPhotoRequest> {
        var mergedArray = Array<Present.PutUserPhotoRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PutUserPhotoRequest? {
        return try Present.PutUserPhotoRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PutUserPhotoRequest {
        return try Present.PutUserPhotoRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PutUserPhotoRequest {
        return try Present.PutUserPhotoRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PutUserPhotoRequest {
        return try Present.PutUserPhotoRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutUserPhotoRequest {
        return try Present.PutUserPhotoRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PutUserPhotoRequest {
        return try Present.PutUserPhotoRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutUserPhotoRequest {
        return try Present.PutUserPhotoRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "photoRef": return self.photoRef
        default: return nil
        }
    }
}
extension Present.PutUserPhotoRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "photoRef": return self.photoRef
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "photoRef":
                guard let newSubscriptValue = newSubscriptValue as? Present.ContentReferenceRequest else {
                    return
                }
                self.photoRef = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.PutDeviceTokenRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PutDeviceTokenRequest> {
        var mergedArray = Array<Present.PutDeviceTokenRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PutDeviceTokenRequest? {
        return try Present.PutDeviceTokenRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PutDeviceTokenRequest {
        return try Present.PutDeviceTokenRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PutDeviceTokenRequest {
        return try Present.PutDeviceTokenRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PutDeviceTokenRequest {
        return try Present.PutDeviceTokenRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutDeviceTokenRequest {
        return try Present.PutDeviceTokenRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PutDeviceTokenRequest {
        return try Present.PutDeviceTokenRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutDeviceTokenRequest {
        return try Present.PutDeviceTokenRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "deviceToken": return self.deviceToken
        case "apnsEnvironment": return self.apnsEnvironment
        default: return nil
        }
    }
}
extension Present.PutDeviceTokenRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "deviceToken": return self.deviceToken
            case "apnsEnvironment": return self.apnsEnvironment
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "deviceToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.deviceToken = newSubscriptValue
            case "apnsEnvironment":
                guard let newSubscriptValue = newSubscriptValue as? Present.PutDeviceTokenRequest.ApnsEnvironment else {
                    return
                }
                self.apnsEnvironment = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UserRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UserRequest> {
        var mergedArray = Array<Present.UserRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UserRequest? {
        return try Present.UserRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UserRequest {
        return try Present.UserRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UserRequest {
        return try Present.UserRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UserRequest {
        return try Present.UserRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserRequest {
        return try Present.UserRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UserRequest {
        return try Present.UserRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserRequest {
        return try Present.UserRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "phoneNumber": return self.phoneNumber
        default: return nil
        }
    }
}
extension Present.UserRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "phoneNumber": return self.phoneNumber
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            case "phoneNumber":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.phoneNumber = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UsersRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UsersRequest> {
        var mergedArray = Array<Present.UsersRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UsersRequest? {
        return try Present.UsersRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UsersRequest {
        return try Present.UsersRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UsersRequest {
        return try Present.UsersRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UsersRequest {
        return try Present.UsersRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UsersRequest {
        return try Present.UsersRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UsersRequest {
        return try Present.UsersRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UsersRequest {
        return try Present.UsersRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userIds": return self.userIds
        default: return nil
        }
    }
}
extension Present.UsersRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userIds": return self.userIds
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userIds":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.userIds = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.ComputeUnreadCountsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.ComputeUnreadCountsRequest> {
        var mergedArray = Array<Present.ComputeUnreadCountsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.ComputeUnreadCountsRequest? {
        return try Present.ComputeUnreadCountsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.ComputeUnreadCountsRequest {
        return try Present.ComputeUnreadCountsRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.ComputeUnreadCountsRequest {
        return try Present.ComputeUnreadCountsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.ComputeUnreadCountsRequest {
        return try Present.ComputeUnreadCountsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ComputeUnreadCountsRequest {
        return try Present.ComputeUnreadCountsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.ComputeUnreadCountsRequest {
        return try Present.ComputeUnreadCountsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ComputeUnreadCountsRequest {
        return try Present.ComputeUnreadCountsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "unreadVersion": return self.unreadVersion
        default: return nil
        }
    }
}
extension Present.ComputeUnreadCountsRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "unreadVersion": return self.unreadVersion
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            case "unreadVersion":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.unreadVersion = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.SynchronizeRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.SynchronizeRequest> {
        var mergedArray = Array<Present.SynchronizeRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.SynchronizeRequest? {
        return try Present.SynchronizeRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.SynchronizeRequest {
        return try Present.SynchronizeRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.SynchronizeRequest {
        return try Present.SynchronizeRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.SynchronizeRequest {
        return try Present.SynchronizeRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SynchronizeRequest {
        return try Present.SynchronizeRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.SynchronizeRequest {
        return try Present.SynchronizeRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SynchronizeRequest {
        return try Present.SynchronizeRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "notificationsEnabled": return self.notificationsEnabled
        default: return nil
        }
    }
}
extension Present.SynchronizeRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "notificationsEnabled": return self.notificationsEnabled
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "notificationsEnabled":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.notificationsEnabled = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.NotificationReceivedRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.NotificationReceivedRequest> {
        var mergedArray = Array<Present.NotificationReceivedRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.NotificationReceivedRequest? {
        return try Present.NotificationReceivedRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.NotificationReceivedRequest {
        return try Present.NotificationReceivedRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.NotificationReceivedRequest {
        return try Present.NotificationReceivedRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.NotificationReceivedRequest {
        return try Present.NotificationReceivedRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.NotificationReceivedRequest {
        return try Present.NotificationReceivedRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.NotificationReceivedRequest {
        return try Present.NotificationReceivedRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.NotificationReceivedRequest {
        return try Present.NotificationReceivedRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "notification": return self.notification
        default: return nil
        }
    }
}
extension Present.NotificationReceivedRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "notification": return self.notification
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "notification":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.notification = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UserSearchRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UserSearchRequest> {
        var mergedArray = Array<Present.UserSearchRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UserSearchRequest? {
        return try Present.UserSearchRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UserSearchRequest {
        return try Present.UserSearchRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UserSearchRequest {
        return try Present.UserSearchRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UserSearchRequest {
        return try Present.UserSearchRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserSearchRequest {
        return try Present.UserSearchRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UserSearchRequest {
        return try Present.UserSearchRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UserSearchRequest {
        return try Present.UserSearchRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "searchText": return self.searchText
        default: return nil
        }
    }
}
extension Present.UserSearchRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "searchText": return self.searchText
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "searchText":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.searchText = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UnreadCounts: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UnreadCounts> {
        var mergedArray = Array<Present.UnreadCounts>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UnreadCounts? {
        return try Present.UnreadCounts.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UnreadCounts {
        return try Present.UnreadCounts.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UnreadCounts {
        return try Present.UnreadCounts.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UnreadCounts {
        return try Present.UnreadCounts.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UnreadCounts {
        return try Present.UnreadCounts.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UnreadCounts {
        return try Present.UnreadCounts.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UnreadCounts {
        return try Present.UnreadCounts.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "total": return self.total
        case "groups": return self.groups
        case "incomingFriendRequests": return self.incomingFriendRequests
        default: return nil
        }
    }
}
extension Present.UnreadCounts.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "total": return self.total
            case "groups": return self.groups
            case "incomingFriendRequests": return self.incomingFriendRequests
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "total":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.total = newSubscriptValue
            case "groups":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groups = newSubscriptValue
            case "incomingFriendRequests":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.incomingFriendRequests = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.SummaryRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.SummaryRequest> {
        var mergedArray = Array<Present.SummaryRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.SummaryRequest? {
        return try Present.SummaryRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.SummaryRequest {
        return try Present.SummaryRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.SummaryRequest {
        return try Present.SummaryRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.SummaryRequest {
        return try Present.SummaryRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SummaryRequest {
        return try Present.SummaryRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.SummaryRequest {
        return try Present.SummaryRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SummaryRequest {
        return try Present.SummaryRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        default: return nil
        }
    }
}
extension Present.SummaryRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.VerifyRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.VerifyRequest> {
        var mergedArray = Array<Present.VerifyRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.VerifyRequest? {
        return try Present.VerifyRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.VerifyRequest {
        return try Present.VerifyRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.VerifyRequest {
        return try Present.VerifyRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.VerifyRequest {
        return try Present.VerifyRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.VerifyRequest {
        return try Present.VerifyRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.VerifyRequest {
        return try Present.VerifyRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.VerifyRequest {
        return try Present.VerifyRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "url": return self.url
        case "code": return self.code
        default: return nil
        }
    }
}
extension Present.VerifyRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "url": return self.url
            case "code": return self.code
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "url":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.url = newSubscriptValue
            case "code":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.code = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.SpacesResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.SpacesResponse> {
        var mergedArray = Array<Present.SpacesResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.SpacesResponse? {
        return try Present.SpacesResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.SpacesResponse {
        return try Present.SpacesResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.SpacesResponse {
        return try Present.SpacesResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.SpacesResponse {
        return try Present.SpacesResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SpacesResponse {
        return try Present.SpacesResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.SpacesResponse {
        return try Present.SpacesResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SpacesResponse {
        return try Present.SpacesResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "spaces": return self.spaces
        default: return nil
        }
    }
}
extension Present.SpacesResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "spaces": return self.spaces
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "spaces":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.SpaceResponse> else {
                    return
                }
                self.spaces = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.ValidStateTransitionResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.ValidStateTransitionResponse> {
        var mergedArray = Array<Present.ValidStateTransitionResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.ValidStateTransitionResponse? {
        return try Present.ValidStateTransitionResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.ValidStateTransitionResponse {
        return try Present.ValidStateTransitionResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.ValidStateTransitionResponse {
        return try Present.ValidStateTransitionResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.ValidStateTransitionResponse {
        return try Present.ValidStateTransitionResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ValidStateTransitionResponse {
        return try Present.ValidStateTransitionResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.ValidStateTransitionResponse {
        return try Present.ValidStateTransitionResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ValidStateTransitionResponse {
        return try Present.ValidStateTransitionResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "verb": return self.verb
        case "description_": return self.description_
        default: return nil
        }
    }
}
extension Present.ValidStateTransitionResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "verb": return self.verb
            case "description_": return self.description_
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.id = newSubscriptValue
            case "verb":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.verb = newSubscriptValue
            case "description_":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.description_ = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.ValidStateTransitionsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.ValidStateTransitionsResponse> {
        var mergedArray = Array<Present.ValidStateTransitionsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.ValidStateTransitionsResponse? {
        return try Present.ValidStateTransitionsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.ValidStateTransitionsResponse {
        return try Present.ValidStateTransitionsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.ValidStateTransitionsResponse {
        return try Present.ValidStateTransitionsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.ValidStateTransitionsResponse {
        return try Present.ValidStateTransitionsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ValidStateTransitionsResponse {
        return try Present.ValidStateTransitionsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.ValidStateTransitionsResponse {
        return try Present.ValidStateTransitionsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ValidStateTransitionsResponse {
        return try Present.ValidStateTransitionsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "validStateTransitions": return self.validStateTransitions
        default: return nil
        }
    }
}
extension Present.ValidStateTransitionsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "validStateTransitions": return self.validStateTransitions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "validStateTransitions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.ValidStateTransitionResponse> else {
                    return
                }
                self.validStateTransitions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.TransitionStateRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.TransitionStateRequest> {
        var mergedArray = Array<Present.TransitionStateRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.TransitionStateRequest? {
        return try Present.TransitionStateRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.TransitionStateRequest {
        return try Present.TransitionStateRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.TransitionStateRequest {
        return try Present.TransitionStateRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.TransitionStateRequest {
        return try Present.TransitionStateRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.TransitionStateRequest {
        return try Present.TransitionStateRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.TransitionStateRequest {
        return try Present.TransitionStateRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.TransitionStateRequest {
        return try Present.TransitionStateRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "stateId": return self.stateId
        default: return nil
        }
    }
}
extension Present.TransitionStateRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "stateId": return self.stateId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            case "stateId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.stateId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AdminSearchRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AdminSearchRequest> {
        var mergedArray = Array<Present.AdminSearchRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AdminSearchRequest? {
        return try Present.AdminSearchRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AdminSearchRequest {
        return try Present.AdminSearchRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchRequest {
        return try Present.AdminSearchRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AdminSearchRequest {
        return try Present.AdminSearchRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchRequest {
        return try Present.AdminSearchRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AdminSearchRequest {
        return try Present.AdminSearchRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchRequest {
        return try Present.AdminSearchRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "cursor": return self.cursor
        case "numResults": return self.numResults
        case "direction": return self.direction
        case "searchText": return self.searchText
        case "filters": return self.filters
        default: return nil
        }
    }
}
extension Present.AdminSearchRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "cursor": return self.cursor
            case "numResults": return self.numResults
            case "direction": return self.direction
            case "searchText": return self.searchText
            case "filters": return self.filters
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "cursor":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.cursor = newSubscriptValue
            case "numResults":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numResults = newSubscriptValue
            case "direction":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.direction = newSubscriptValue
            case "searchText":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.searchText = newSubscriptValue
            case "filters":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.AdminSearchFilter> else {
                    return
                }
                self.filters = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AdminSearchResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AdminSearchResponse> {
        var mergedArray = Array<Present.AdminSearchResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AdminSearchResponse? {
        return try Present.AdminSearchResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AdminSearchResponse {
        return try Present.AdminSearchResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchResponse {
        return try Present.AdminSearchResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AdminSearchResponse {
        return try Present.AdminSearchResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchResponse {
        return try Present.AdminSearchResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AdminSearchResponse {
        return try Present.AdminSearchResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchResponse {
        return try Present.AdminSearchResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "cursor": return self.cursor
        case "adminSearchResponse": return self.adminSearchResponse
        case "totalUsers": return self.totalUsers
        default: return nil
        }
    }
}
extension Present.AdminSearchResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "cursor": return self.cursor
            case "adminSearchResponse": return self.adminSearchResponse
            case "totalUsers": return self.totalUsers
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "cursor":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.cursor = newSubscriptValue
            case "adminSearchResponse":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.AdminUserResponse> else {
                    return
                }
                self.adminSearchResponse = newSubscriptValue
            case "totalUsers":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.totalUsers = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AdminSearchFilter: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AdminSearchFilter> {
        var mergedArray = Array<Present.AdminSearchFilter>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AdminSearchFilter? {
        return try Present.AdminSearchFilter.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AdminSearchFilter {
        return try Present.AdminSearchFilter.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchFilter {
        return try Present.AdminSearchFilter.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AdminSearchFilter {
        return try Present.AdminSearchFilter.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchFilter {
        return try Present.AdminSearchFilter.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AdminSearchFilter {
        return try Present.AdminSearchFilter.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminSearchFilter {
        return try Present.AdminSearchFilter.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "field": return self.field
        case "searchString": return self.searchString
        default: return nil
        }
    }
}
extension Present.AdminSearchFilter.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "field": return self.field
            case "searchString": return self.searchString
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "field":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.field = newSubscriptValue
            case "searchString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.searchString = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AdminUserResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AdminUserResponse> {
        var mergedArray = Array<Present.AdminUserResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AdminUserResponse? {
        return try Present.AdminUserResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AdminUserResponse {
        return try Present.AdminUserResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AdminUserResponse {
        return try Present.AdminUserResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AdminUserResponse {
        return try Present.AdminUserResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminUserResponse {
        return try Present.AdminUserResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AdminUserResponse {
        return try Present.AdminUserResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AdminUserResponse {
        return try Present.AdminUserResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "uuid": return self.uuid
        case "photo": return self.photo
        case "firstName": return self.firstName
        case "lastName": return self.lastName
        case "gender": return self.gender
        case "phone": return self.phone
        case "email": return self.email
        case "facebookLink": return self.facebookLink
        case "presentLink": return self.presentLink
        case "signupTime": return self.signupTime
        case "notificationsEnabled": return self.notificationsEnabled
        case "lastActivityTime": return self.lastActivityTime
        case "signupCity": return self.signupCity
        case "signupState": return self.signupState
        case "signupLat": return self.signupLat
        case "signupLong": return self.signupLong
        case "signupLocationAccuracy": return self.signupLocationAccuracy
        case "userState": return self.userState
        case "review": return self.review
        case "clients": return self.clients
        case "availableActions": return self.availableActions
        case "debugString": return self.debugString
        default: return nil
        }
    }
}
extension Present.AdminUserResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "uuid": return self.uuid
            case "photo": return self.photo
            case "firstName": return self.firstName
            case "lastName": return self.lastName
            case "gender": return self.gender
            case "phone": return self.phone
            case "email": return self.email
            case "facebookLink": return self.facebookLink
            case "presentLink": return self.presentLink
            case "signupTime": return self.signupTime
            case "notificationsEnabled": return self.notificationsEnabled
            case "lastActivityTime": return self.lastActivityTime
            case "signupCity": return self.signupCity
            case "signupState": return self.signupState
            case "signupLat": return self.signupLat
            case "signupLong": return self.signupLong
            case "signupLocationAccuracy": return self.signupLocationAccuracy
            case "userState": return self.userState
            case "review": return self.review
            case "clients": return self.clients
            case "availableActions": return self.availableActions
            case "debugString": return self.debugString
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "uuid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.uuid = newSubscriptValue
            case "photo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.photo = newSubscriptValue
            case "firstName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.firstName = newSubscriptValue
            case "lastName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.lastName = newSubscriptValue
            case "gender":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.gender = newSubscriptValue
            case "phone":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.phone = newSubscriptValue
            case "email":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.email = newSubscriptValue
            case "facebookLink":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.facebookLink = newSubscriptValue
            case "presentLink":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.presentLink = newSubscriptValue
            case "signupTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.signupTime = newSubscriptValue
            case "notificationsEnabled":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.notificationsEnabled = newSubscriptValue
            case "lastActivityTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.lastActivityTime = newSubscriptValue
            case "signupCity":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.signupCity = newSubscriptValue
            case "signupState":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.signupState = newSubscriptValue
            case "signupLat":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.signupLat = newSubscriptValue
            case "signupLong":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.signupLong = newSubscriptValue
            case "signupLocationAccuracy":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.signupLocationAccuracy = newSubscriptValue
            case "userState":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userState = newSubscriptValue
            case "review":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.review = newSubscriptValue
            case "clients":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.clients = newSubscriptValue
            case "availableActions":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.availableActions = newSubscriptValue
            case "debugString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.debugString = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.RequestVerificationRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.RequestVerificationRequest> {
        var mergedArray = Array<Present.RequestVerificationRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.RequestVerificationRequest? {
        return try Present.RequestVerificationRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.RequestVerificationRequest {
        return try Present.RequestVerificationRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.RequestVerificationRequest {
        return try Present.RequestVerificationRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.RequestVerificationRequest {
        return try Present.RequestVerificationRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.RequestVerificationRequest {
        return try Present.RequestVerificationRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.RequestVerificationRequest {
        return try Present.RequestVerificationRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.RequestVerificationRequest {
        return try Present.RequestVerificationRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "phoneNumber": return self.phoneNumber
        default: return nil
        }
    }
}
extension Present.RequestVerificationRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "phoneNumber": return self.phoneNumber
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "phoneNumber":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.phoneNumber = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.RequestVerificationResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.RequestVerificationResponse> {
        var mergedArray = Array<Present.RequestVerificationResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.RequestVerificationResponse? {
        return try Present.RequestVerificationResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.RequestVerificationResponse {
        return try Present.RequestVerificationResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.RequestVerificationResponse {
        return try Present.RequestVerificationResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.RequestVerificationResponse {
        return try Present.RequestVerificationResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.RequestVerificationResponse {
        return try Present.RequestVerificationResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.RequestVerificationResponse {
        return try Present.RequestVerificationResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.RequestVerificationResponse {
        return try Present.RequestVerificationResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "codeLength": return self.codeLength
        default: return nil
        }
    }
}
extension Present.RequestVerificationResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "codeLength": return self.codeLength
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "codeLength":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.codeLength = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AddFriendResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AddFriendResponse> {
        var mergedArray = Array<Present.AddFriendResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AddFriendResponse? {
        return try Present.AddFriendResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AddFriendResponse {
        return try Present.AddFriendResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AddFriendResponse {
        return try Present.AddFriendResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AddFriendResponse {
        return try Present.AddFriendResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddFriendResponse {
        return try Present.AddFriendResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AddFriendResponse {
        return try Present.AddFriendResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddFriendResponse {
        return try Present.AddFriendResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "result": return self.result
        case "user": return self.user
        default: return nil
        }
    }
}
extension Present.AddFriendResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "result": return self.result
            case "user": return self.user
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "result":
                guard let newSubscriptValue = newSubscriptValue as? Present.FriendshipState else {
                    return
                }
                self.result = newSubscriptValue
            case "user":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.user = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.ContactRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.ContactRequest> {
        var mergedArray = Array<Present.ContactRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.ContactRequest? {
        return try Present.ContactRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.ContactRequest {
        return try Present.ContactRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.ContactRequest {
        return try Present.ContactRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.ContactRequest {
        return try Present.ContactRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ContactRequest {
        return try Present.ContactRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.ContactRequest {
        return try Present.ContactRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ContactRequest {
        return try Present.ContactRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "phoneNumber": return self.phoneNumber
        case "fullName": return self.fullName
        case "firstName": return self.firstName
        case "lastName": return self.lastName
        default: return nil
        }
    }
}
extension Present.ContactRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "phoneNumber": return self.phoneNumber
            case "fullName": return self.fullName
            case "firstName": return self.firstName
            case "lastName": return self.lastName
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "phoneNumber":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.phoneNumber = newSubscriptValue
            case "fullName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fullName = newSubscriptValue
            case "firstName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.firstName = newSubscriptValue
            case "lastName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.lastName = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AddContactsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AddContactsRequest> {
        var mergedArray = Array<Present.AddContactsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AddContactsRequest? {
        return try Present.AddContactsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AddContactsRequest {
        return try Present.AddContactsRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AddContactsRequest {
        return try Present.AddContactsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AddContactsRequest {
        return try Present.AddContactsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddContactsRequest {
        return try Present.AddContactsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AddContactsRequest {
        return try Present.AddContactsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddContactsRequest {
        return try Present.AddContactsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "contacts": return self.contacts
        default: return nil
        }
    }
}
extension Present.AddContactsRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "contacts": return self.contacts
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "contacts":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.ContactRequest> else {
                    return
                }
                self.contacts = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.PhoneUserResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PhoneUserResponse> {
        var mergedArray = Array<Present.PhoneUserResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PhoneUserResponse? {
        return try Present.PhoneUserResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PhoneUserResponse {
        return try Present.PhoneUserResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PhoneUserResponse {
        return try Present.PhoneUserResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PhoneUserResponse {
        return try Present.PhoneUserResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PhoneUserResponse {
        return try Present.PhoneUserResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PhoneUserResponse {
        return try Present.PhoneUserResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PhoneUserResponse {
        return try Present.PhoneUserResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "phoneNumber": return self.phoneNumber
        case "user": return self.user
        default: return nil
        }
    }
}
extension Present.PhoneUserResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "phoneNumber": return self.phoneNumber
            case "user": return self.user
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "phoneNumber":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.phoneNumber = newSubscriptValue
            case "user":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.user = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AddContactsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AddContactsResponse> {
        var mergedArray = Array<Present.AddContactsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AddContactsResponse? {
        return try Present.AddContactsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AddContactsResponse {
        return try Present.AddContactsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.UserRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AddContactsResponse {
        return try Present.AddContactsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AddContactsResponse {
        return try Present.AddContactsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddContactsResponse {
        return try Present.AddContactsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AddContactsResponse {
        return try Present.AddContactsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddContactsResponse {
        return try Present.AddContactsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "results": return self.results
        default: return nil
        }
    }
}
extension Present.AddContactsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "results": return self.results
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "results":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.PhoneUserResponse> else {
                    return
                }
                self.results = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
