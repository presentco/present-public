/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "activity.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct Present { }

public extension Present {
    public struct ActivityRoot {
        public static let `default` = ActivityRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Present.UserRoot.default.registerAllExtensions(registry: extensionRegistry)
            Present.GroupRoot.default.registerAllExtensions(registry: extensionRegistry)
            Present.MessagingRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    /// The event type.  This follows the user settings naming convention:
    /// "When a(n)... actor action target", but in the past tense.
    public enum ActivityType:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        /// Protocol Buffers will assign this value for an unrecognized enum on an older client.
        ///UNKNOWN = 0;
        /// TODO: The iOS Client build process requires enum names to be unique.
        /// TODO: We temporarily change the name for the iOS build.  The wire format is unaffected.
        case unknownActivityType = 0
        case friendJoinedPresent = 1

        /// Direct Messaging
        case userSentMessage = 100

        /// Group
        case userCommentedOnGroup = 200
        case userJoinedGroup = 201
        case userInvitedToGroup = 202
        case groupMembershipRequest = 203
        case groupMembershipApproval = 204

        /// Friendship
        case friendRequest = 300
        case friendAccept = 301
        public func toString() -> String {
            switch self {
            case .unknownActivityType: return "UNKNOWN_ACTIVITY_TYPE"
            case .friendJoinedPresent: return "FRIEND_JOINED_PRESENT"
            case .userSentMessage: return "USER_SENT_MESSAGE"
            case .userCommentedOnGroup: return "USER_COMMENTED_ON_GROUP"
            case .userJoinedGroup: return "USER_JOINED_GROUP"
            case .userInvitedToGroup: return "USER_INVITED_TO_GROUP"
            case .groupMembershipRequest: return "GROUP_MEMBERSHIP_REQUEST"
            case .groupMembershipApproval: return "GROUP_MEMBERSHIP_APPROVAL"
            case .friendRequest: return "FRIEND_REQUEST"
            case .friendAccept: return "FRIEND_ACCEPT"
            }
        }
        public static func fromString(str:String) throws -> Present.ActivityType {
            switch str {
            case "UNKNOWN_ACTIVITY_TYPE":    return .unknownActivityType
            case "FRIEND_JOINED_PRESENT":    return .friendJoinedPresent
            case "USER_SENT_MESSAGE":    return .userSentMessage
            case "USER_COMMENTED_ON_GROUP":    return .userCommentedOnGroup
            case "USER_JOINED_GROUP":    return .userJoinedGroup
            case "USER_INVITED_TO_GROUP":    return .userInvitedToGroup
            case "GROUP_MEMBERSHIP_REQUEST":    return .groupMembershipRequest
            case "GROUP_MEMBERSHIP_APPROVAL":    return .groupMembershipApproval
            case "FRIEND_REQUEST":    return .friendRequest
            case "FRIEND_ACCEPT":    return .friendAccept
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .unknownActivityType: return ".unknownActivityType"
            case .friendJoinedPresent: return ".friendJoinedPresent"
            case .userSentMessage: return ".userSentMessage"
            case .userCommentedOnGroup: return ".userCommentedOnGroup"
            case .userJoinedGroup: return ".userJoinedGroup"
            case .userInvitedToGroup: return ".userInvitedToGroup"
            case .groupMembershipRequest: return ".groupMembershipRequest"
            case .groupMembershipApproval: return ".groupMembershipApproval"
            case .friendRequest: return ".friendRequest"
            case .friendAccept: return ".friendAccept"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:ActivityType, rhs:ActivityType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    /// Get past activity for the current user.
    final public class PastActivityRequest : GeneratedMessage {

        public static func == (lhs: Present.PastActivityRequest, rhs: Present.PastActivityRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
            fieldCheck = fieldCheck && (lhs.hasEndTime == rhs.hasEndTime) && (!lhs.hasEndTime || lhs.endTime == rhs.endTime)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Optional starting time. If not provided all activity will be returned.
        public fileprivate(set) var startTime:UInt64 = UInt64(0)
        public fileprivate(set) var hasStartTime:Bool = false

        /// Optional end time. If not provided all activity will be returned.
        public fileprivate(set) var endTime:UInt64 = UInt64(0)
        public fileprivate(set) var hasEndTime:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStartTime {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:startTime)
            }
            if hasEndTime {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:endTime)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStartTime {
                serialize_size += startTime.computeUInt64Size(fieldNumber: 1)
            }
            if hasEndTime {
                serialize_size += endTime.computeUInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PastActivityRequest.Builder {
            return Present.PastActivityRequest.classBuilder() as! Present.PastActivityRequest.Builder
        }
        public func getBuilder() -> Present.PastActivityRequest.Builder {
            return classBuilder() as! Present.PastActivityRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PastActivityRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PastActivityRequest.Builder()
        }
        public func toBuilder() throws -> Present.PastActivityRequest.Builder {
            return try Present.PastActivityRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PastActivityRequest) throws -> Present.PastActivityRequest.Builder {
            return try Present.PastActivityRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStartTime {
                jsonMap["startTime"] = "\(startTime)"
            }
            if hasEndTime {
                jsonMap["endTime"] = "\(endTime)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PastActivityRequest {
            return try Present.PastActivityRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PastActivityRequest {
            return try Present.PastActivityRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStartTime {
                output += "\(indent) startTime: \(startTime) \n"
            }
            if hasEndTime {
                output += "\(indent) endTime: \(endTime) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStartTime {
                    hashCode = (hashCode &* 31) &+ startTime.hashValue
                }
                if hasEndTime {
                    hashCode = (hashCode &* 31) &+ endTime.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PastActivityRequest"
        }
        override public func className() -> String {
            return "Present.PastActivityRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PastActivityRequest = Present.PastActivityRequest()
            public func getMessage() -> Present.PastActivityRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Optional starting time. If not provided all activity will be returned.
            public var startTime:UInt64 {
                get {
                    return builderResult.startTime
                }
                set (value) {
                    builderResult.hasStartTime = true
                    builderResult.startTime = value
                }
            }
            public var hasStartTime:Bool {
                get {
                    return builderResult.hasStartTime
                }
            }
            @discardableResult
            public func setStartTime(_ value:UInt64) -> Present.PastActivityRequest.Builder {
                self.startTime = value
                return self
            }
            @discardableResult
            public func clearStartTime() -> Present.PastActivityRequest.Builder{
                builderResult.hasStartTime = false
                builderResult.startTime = UInt64(0)
                return self
            }
            /// Optional end time. If not provided all activity will be returned.
            public var endTime:UInt64 {
                get {
                    return builderResult.endTime
                }
                set (value) {
                    builderResult.hasEndTime = true
                    builderResult.endTime = value
                }
            }
            public var hasEndTime:Bool {
                get {
                    return builderResult.hasEndTime
                }
            }
            @discardableResult
            public func setEndTime(_ value:UInt64) -> Present.PastActivityRequest.Builder {
                self.endTime = value
                return self
            }
            @discardableResult
            public func clearEndTime() -> Present.PastActivityRequest.Builder{
                builderResult.hasEndTime = false
                builderResult.endTime = UInt64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PastActivityRequest.Builder {
                builderResult = Present.PastActivityRequest()
                return self
            }
            override public func clone() throws -> Present.PastActivityRequest.Builder {
                return try Present.PastActivityRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PastActivityRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PastActivityRequest {
                let returnMe:Present.PastActivityRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PastActivityRequest) throws -> Present.PastActivityRequest.Builder {
                if other == Present.PastActivityRequest() {
                    return self
                }
                if other.hasStartTime {
                    startTime = other.startTime
                }
                if other.hasEndTime {
                    endTime = other.endTime
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PastActivityRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastActivityRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        startTime = try codedInputStream.readUInt64()

                    case 16:
                        endTime = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PastActivityRequest.Builder {
                let resultDecodedBuilder = Present.PastActivityRequest.Builder()
                if let jsonValueStartTime = jsonMap["startTime"] as? String {
                    resultDecodedBuilder.startTime = UInt64(jsonValueStartTime)!
                } else if let jsonValueStartTime = jsonMap["startTime"] as? UInt {
                    resultDecodedBuilder.startTime = UInt64(jsonValueStartTime)
                }
                if let jsonValueEndTime = jsonMap["endTime"] as? String {
                    resultDecodedBuilder.endTime = UInt64(jsonValueEndTime)!
                } else if let jsonValueEndTime = jsonMap["endTime"] as? UInt {
                    resultDecodedBuilder.endTime = UInt64(jsonValueEndTime)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PastActivityRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PastActivityRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Past activity for the current user.
    final public class PastActivityResponse : GeneratedMessage {

        public static func == (lhs: Present.PastActivityResponse, rhs: Present.PastActivityResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.events == rhs.events)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var events:Array<Present.EventResponse>  = Array<Present.EventResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitEvents:Bool = true
            for oneElementEvents in events {
                if !oneElementEvents.isInitialized() {
                    isInitEvents = false
                    break 
                }
            }
            if !isInitEvents {
                return isInitEvents
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementEvents in events {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementEvents)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementEvents in events {
                serialize_size += oneElementEvents.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PastActivityResponse.Builder {
            return Present.PastActivityResponse.classBuilder() as! Present.PastActivityResponse.Builder
        }
        public func getBuilder() -> Present.PastActivityResponse.Builder {
            return classBuilder() as! Present.PastActivityResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PastActivityResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PastActivityResponse.Builder()
        }
        public func toBuilder() throws -> Present.PastActivityResponse.Builder {
            return try Present.PastActivityResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PastActivityResponse) throws -> Present.PastActivityResponse.Builder {
            return try Present.PastActivityResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !events.isEmpty {
                var jsonArrayEvents:Array<Dictionary<String,Any>> = []
                for oneValueEvents in events {
                    let ecodedMessageEvents = try oneValueEvents.encode()
                    jsonArrayEvents.append(ecodedMessageEvents)
                }
                jsonMap["events"] = jsonArrayEvents
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PastActivityResponse {
            return try Present.PastActivityResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PastActivityResponse {
            return try Present.PastActivityResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var eventsElementIndex:Int = 0
            for oneElementEvents in events {
                output += "\(indent) events[\(eventsElementIndex)] {\n"
                output += try oneElementEvents.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                eventsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementEvents in events {
                    hashCode = (hashCode &* 31) &+ oneElementEvents.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PastActivityResponse"
        }
        override public func className() -> String {
            return "Present.PastActivityResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PastActivityResponse = Present.PastActivityResponse()
            public func getMessage() -> Present.PastActivityResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The sequence of events, ordered by time ascending
            public var events:Array<Present.EventResponse> {
                get {
                    return builderResult.events
                }
                set (value) {
                    builderResult.events = value
                }
            }
            @discardableResult
            public func setEvents(_ value:Array<Present.EventResponse>) -> Present.PastActivityResponse.Builder {
                self.events = value
                return self
            }
            @discardableResult
            public func clearEvents() -> Present.PastActivityResponse.Builder {
                builderResult.events.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PastActivityResponse.Builder {
                builderResult = Present.PastActivityResponse()
                return self
            }
            override public func clone() throws -> Present.PastActivityResponse.Builder {
                return try Present.PastActivityResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PastActivityResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PastActivityResponse {
                let returnMe:Present.PastActivityResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PastActivityResponse) throws -> Present.PastActivityResponse.Builder {
                if other == Present.PastActivityResponse() {
                    return self
                }
                if !other.events.isEmpty  {
                     builderResult.events += other.events
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PastActivityResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastActivityResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.EventResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        events.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PastActivityResponse.Builder {
                let resultDecodedBuilder = Present.PastActivityResponse.Builder()
                if let jsonValueEvents = jsonMap["events"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayEvents:Array<Present.EventResponse> = []
                    for oneValueEvents in jsonValueEvents {
                        let messageFromStringEvents = try Present.EventResponse.Builder.decodeToBuilder(jsonMap:oneValueEvents).build()

                        jsonArrayEvents.append(messageFromStringEvents)
                    }
                    resultDecodedBuilder.events = jsonArrayEvents
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PastActivityResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PastActivityResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Describes a system activity or user action of interest to a given user.
    /// e.g. events in the activity feed.
    /// Examples:
    /// - "Bob joined 5 circles."
    /// - "Bob and 5 others joined 'Your Circle.'"
    /// - "Bob and 5 others commented on 'Your Circle.'"
    final public class EventResponse : GeneratedMessage {

        public static func == (lhs: Present.EventResponse, rhs: Present.EventResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUuid == rhs.hasUuid) && (!lhs.hasUuid || lhs.uuid == rhs.uuid)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasWhen == rhs.hasWhen) && (!lhs.hasWhen || lhs.when == rhs.when)
            fieldCheck = fieldCheck && (lhs.hasIcon == rhs.hasIcon) && (!lhs.hasIcon || lhs.icon == rhs.icon)
            fieldCheck = fieldCheck && (lhs.hasSummary == rhs.hasSummary) && (!lhs.hasSummary || lhs.summary == rhs.summary)
            fieldCheck = fieldCheck && (lhs.hasDefaultTarget == rhs.hasDefaultTarget) && (!lhs.hasDefaultTarget || lhs.defaultTarget == rhs.defaultTarget)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The unique id for this event, which can be used for disambiguation.
        public fileprivate(set) var uuid:String = ""
        public fileprivate(set) var hasUuid:Bool = false

        public fileprivate(set) var type:Present.ActivityType = Present.ActivityType.unknownActivityType
        public fileprivate(set) var hasType:Bool = false
        /// Time when the event occurred.
        public fileprivate(set) var when:UInt64 = UInt64(0)
        public fileprivate(set) var hasWhen:Bool = false

        /// URL for icon displayed with the event.
        public fileprivate(set) var icon:String = ""
        public fileprivate(set) var hasIcon:Bool = false

        /// User-visible event description.
        public fileprivate(set) var summary:String = ""
        public fileprivate(set) var hasSummary:Bool = false

        public fileprivate(set) var defaultTarget:Present.ReferenceResponse!
        public fileprivate(set) var hasDefaultTarget:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUuid {
                return false
            }
            if !hasWhen {
                return false
            }
            if !hasSummary {
                return false
            }
            if !hasDefaultTarget {
                return false
            }
            if !defaultTarget.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUuid {
                try codedOutputStream.writeString(fieldNumber: 1, value:uuid)
            }
            if hasType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:type.rawValue)
            }
            if hasWhen {
                try codedOutputStream.writeUInt64(fieldNumber: 3, value:when)
            }
            if hasIcon {
                try codedOutputStream.writeString(fieldNumber: 4, value:icon)
            }
            if hasSummary {
                try codedOutputStream.writeString(fieldNumber: 5, value:summary)
            }
            if hasDefaultTarget {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:defaultTarget)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUuid {
                serialize_size += uuid.computeStringSize(fieldNumber: 1)
            }
            if (hasType) {
                serialize_size += type.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasWhen {
                serialize_size += when.computeUInt64Size(fieldNumber: 3)
            }
            if hasIcon {
                serialize_size += icon.computeStringSize(fieldNumber: 4)
            }
            if hasSummary {
                serialize_size += summary.computeStringSize(fieldNumber: 5)
            }
            if hasDefaultTarget {
                if let varSizedefaultTarget = defaultTarget?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizedefaultTarget
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.EventResponse.Builder {
            return Present.EventResponse.classBuilder() as! Present.EventResponse.Builder
        }
        public func getBuilder() -> Present.EventResponse.Builder {
            return classBuilder() as! Present.EventResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.EventResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.EventResponse.Builder()
        }
        public func toBuilder() throws -> Present.EventResponse.Builder {
            return try Present.EventResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.EventResponse) throws -> Present.EventResponse.Builder {
            return try Present.EventResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUuid {
                jsonMap["uuid"] = uuid
            }
            if hasType {
                jsonMap["type"] = type.toString()
            }
            if hasWhen {
                jsonMap["when"] = "\(when)"
            }
            if hasIcon {
                jsonMap["icon"] = icon
            }
            if hasSummary {
                jsonMap["summary"] = summary
            }
            if hasDefaultTarget {
                jsonMap["defaultTarget"] = try defaultTarget.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.EventResponse {
            return try Present.EventResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.EventResponse {
            return try Present.EventResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUuid {
                output += "\(indent) uuid: \(uuid) \n"
            }
            if (hasType) {
                output += "\(indent) type: \(type.description)\n"
            }
            if hasWhen {
                output += "\(indent) when: \(when) \n"
            }
            if hasIcon {
                output += "\(indent) icon: \(icon) \n"
            }
            if hasSummary {
                output += "\(indent) summary: \(summary) \n"
            }
            if hasDefaultTarget {
                output += "\(indent) defaultTarget {\n"
                if let outDescDefaultTarget = defaultTarget {
                    output += try outDescDefaultTarget.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUuid {
                    hashCode = (hashCode &* 31) &+ uuid.hashValue
                }
                if hasType {
                     hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasWhen {
                    hashCode = (hashCode &* 31) &+ when.hashValue
                }
                if hasIcon {
                    hashCode = (hashCode &* 31) &+ icon.hashValue
                }
                if hasSummary {
                    hashCode = (hashCode &* 31) &+ summary.hashValue
                }
                if hasDefaultTarget {
                    if let hashValuedefaultTarget = defaultTarget?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedefaultTarget
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.EventResponse"
        }
        override public func className() -> String {
            return "Present.EventResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.EventResponse = Present.EventResponse()
            public func getMessage() -> Present.EventResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The unique id for this event, which can be used for disambiguation.
            public var uuid:String {
                get {
                    return builderResult.uuid
                }
                set (value) {
                    builderResult.hasUuid = true
                    builderResult.uuid = value
                }
            }
            public var hasUuid:Bool {
                get {
                    return builderResult.hasUuid
                }
            }
            @discardableResult
            public func setUuid(_ value:String) -> Present.EventResponse.Builder {
                self.uuid = value
                return self
            }
            @discardableResult
            public func clearUuid() -> Present.EventResponse.Builder{
                builderResult.hasUuid = false
                builderResult.uuid = ""
                return self
            }
            /// Type of event.
                public var type:Present.ActivityType {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool{
                    get {
                        return builderResult.hasType
                    }
                }
            @discardableResult
                public func setType(_ value:Present.ActivityType) -> Present.EventResponse.Builder {
                  self.type = value
                  return self
                }
            @discardableResult
                public func clearType() -> Present.EventResponse.Builder {
                   builderResult.hasType = false
                   builderResult.type = .unknownActivityType
                   return self
                }
            /// Time when the event occurred.
            public var when:UInt64 {
                get {
                    return builderResult.when
                }
                set (value) {
                    builderResult.hasWhen = true
                    builderResult.when = value
                }
            }
            public var hasWhen:Bool {
                get {
                    return builderResult.hasWhen
                }
            }
            @discardableResult
            public func setWhen(_ value:UInt64) -> Present.EventResponse.Builder {
                self.when = value
                return self
            }
            @discardableResult
            public func clearWhen() -> Present.EventResponse.Builder{
                builderResult.hasWhen = false
                builderResult.when = UInt64(0)
                return self
            }
            /// URL for icon displayed with the event.
            public var icon:String {
                get {
                    return builderResult.icon
                }
                set (value) {
                    builderResult.hasIcon = true
                    builderResult.icon = value
                }
            }
            public var hasIcon:Bool {
                get {
                    return builderResult.hasIcon
                }
            }
            @discardableResult
            public func setIcon(_ value:String) -> Present.EventResponse.Builder {
                self.icon = value
                return self
            }
            @discardableResult
            public func clearIcon() -> Present.EventResponse.Builder{
                builderResult.hasIcon = false
                builderResult.icon = ""
                return self
            }
            /// User-visible event description.
            public var summary:String {
                get {
                    return builderResult.summary
                }
                set (value) {
                    builderResult.hasSummary = true
                    builderResult.summary = value
                }
            }
            public var hasSummary:Bool {
                get {
                    return builderResult.hasSummary
                }
            }
            @discardableResult
            public func setSummary(_ value:String) -> Present.EventResponse.Builder {
                self.summary = value
                return self
            }
            @discardableResult
            public func clearSummary() -> Present.EventResponse.Builder{
                builderResult.hasSummary = false
                builderResult.summary = ""
                return self
            }
            /// Where should the app take you when you tap the event?
            public var defaultTarget:Present.ReferenceResponse! {
                get {
                    if defaultTargetBuilder_ != nil {
                        builderResult.defaultTarget = defaultTargetBuilder_.getMessage()
                    }
                    return builderResult.defaultTarget
                }
                set (value) {
                    builderResult.hasDefaultTarget = true
                    builderResult.defaultTarget = value
                }
            }
            public var hasDefaultTarget:Bool {
                get {
                    return builderResult.hasDefaultTarget
                }
            }
            fileprivate var defaultTargetBuilder_:Present.ReferenceResponse.Builder! {
                didSet {
                    builderResult.hasDefaultTarget = true
                }
            }
            public func getDefaultTargetBuilder() -> Present.ReferenceResponse.Builder {
                if defaultTargetBuilder_ == nil {
                    defaultTargetBuilder_ = Present.ReferenceResponse.Builder()
                    builderResult.defaultTarget = defaultTargetBuilder_.getMessage()
                    if defaultTarget != nil {
                        try! defaultTargetBuilder_.mergeFrom(other: defaultTarget)
                    }
                }
                return defaultTargetBuilder_
            }
            @discardableResult
            public func setDefaultTarget(_ value:Present.ReferenceResponse!) -> Present.EventResponse.Builder {
                self.defaultTarget = value
                return self
            }
            @discardableResult
            public func mergeDefaultTarget(value:Present.ReferenceResponse) throws -> Present.EventResponse.Builder {
                if builderResult.hasDefaultTarget {
                    builderResult.defaultTarget = try Present.ReferenceResponse.builderWithPrototype(prototype:builderResult.defaultTarget).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.defaultTarget = value
                }
                builderResult.hasDefaultTarget = true
                return self
            }
            @discardableResult
            public func clearDefaultTarget() -> Present.EventResponse.Builder {
                defaultTargetBuilder_ = nil
                builderResult.hasDefaultTarget = false
                builderResult.defaultTarget = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.EventResponse.Builder {
                builderResult = Present.EventResponse()
                return self
            }
            override public func clone() throws -> Present.EventResponse.Builder {
                return try Present.EventResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.EventResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.EventResponse {
                let returnMe:Present.EventResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.EventResponse) throws -> Present.EventResponse.Builder {
                if other == Present.EventResponse() {
                    return self
                }
                if other.hasUuid {
                    uuid = other.uuid
                }
                if other.hasType {
                    type = other.type
                }
                if other.hasWhen {
                    when = other.when
                }
                if other.hasIcon {
                    icon = other.icon
                }
                if other.hasSummary {
                    summary = other.summary
                }
                if (other.hasDefaultTarget) {
                    try mergeDefaultTarget(value: other.defaultTarget)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.EventResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.EventResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        uuid = try codedInputStream.readString()

                    case 16:
                        let valueInttype = try codedInputStream.readEnum()
                        if let enumstype = Present.ActivityType(rawValue:valueInttype){
                            type = enumstype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueInttype))
                        }

                    case 24:
                        when = try codedInputStream.readUInt64()

                    case 34:
                        icon = try codedInputStream.readString()

                    case 42:
                        summary = try codedInputStream.readString()

                    case 50:
                        let subBuilder:Present.ReferenceResponse.Builder = Present.ReferenceResponse.Builder()
                        if hasDefaultTarget {
                            try subBuilder.mergeFrom(other: defaultTarget)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        defaultTarget = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.EventResponse.Builder {
                let resultDecodedBuilder = Present.EventResponse.Builder()
                if let jsonValueUuid = jsonMap["uuid"] as? String {
                    resultDecodedBuilder.uuid = jsonValueUuid
                }
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = try Present.ActivityType.fromString(str: jsonValueType)
                }
                if let jsonValueWhen = jsonMap["when"] as? String {
                    resultDecodedBuilder.when = UInt64(jsonValueWhen)!
                } else if let jsonValueWhen = jsonMap["when"] as? UInt {
                    resultDecodedBuilder.when = UInt64(jsonValueWhen)
                }
                if let jsonValueIcon = jsonMap["icon"] as? String {
                    resultDecodedBuilder.icon = jsonValueIcon
                }
                if let jsonValueSummary = jsonMap["summary"] as? String {
                    resultDecodedBuilder.summary = jsonValueSummary
                }
                if let jsonValueDefaultTarget = jsonMap["defaultTarget"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.defaultTarget = try Present.ReferenceResponse.Builder.decodeToBuilder(jsonMap:jsonValueDefaultTarget).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.EventResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.EventResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// An entity response that can refer to one of many types of entities.
    /// The entity may be referenced by uuid or provide the full response.
    final public class ReferenceResponse : GeneratedMessage {

        public static func == (lhs: Present.ReferenceResponse, rhs: Present.ReferenceResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasGroup == rhs.hasGroup) && (!lhs.hasGroup || lhs.group == rhs.group)
            fieldCheck = fieldCheck && (lhs.hasCommentId == rhs.hasCommentId) && (!lhs.hasCommentId || lhs.commentId == rhs.commentId)
            fieldCheck = fieldCheck && (lhs.hasComment == rhs.hasComment) && (!lhs.hasComment || lhs.comment == rhs.comment)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Response {
            case OneOfResponseNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfResponseNotSet: return false
                default: return true
                }
            }
            case UserId(String)

            public static func getUserId(_ value:Response) -> String? {
                switch value {
                case .UserId(let enumValue): return enumValue
                default: return nil
                }
            }
            case User(Present.UserResponse)

            public static func getUser(_ value:Response) -> Present.UserResponse? {
                switch value {
                case .User(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case GroupId(String)

            public static func getGroupId(_ value:Response) -> String? {
                switch value {
                case .GroupId(let enumValue): return enumValue
                default: return nil
                }
            }
            case Group(Present.GroupResponse)

            public static func getGroup(_ value:Response) -> Present.GroupResponse? {
                switch value {
                case .Group(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case CommentId(String)

            public static func getCommentId(_ value:Response) -> String? {
                switch value {
                case .CommentId(let enumValue): return enumValue
                default: return nil
                }
            }
            case Comment(Present.CommentResponse)

            public static func getComment(_ value:Response) -> Present.CommentResponse? {
                switch value {
                case .Comment(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageResponse:ReferenceResponse.Response =  ReferenceResponse.Response.OneOfResponseNotSet
        public func getOneOfResponse() ->  ReferenceResponse.Response {
            let copyObjectResponse = storageResponse
            return copyObjectResponse
        }
        public fileprivate(set) var userId:String!{
            get {
                return ReferenceResponse.Response.getUserId(storageResponse)
            }
            set (newvalue) {
                storageResponse = ReferenceResponse.Response.UserId(newvalue)
            }
        }
        public fileprivate(set) var hasUserId:Bool {
            get {
                guard let _ = ReferenceResponse.Response.getUserId(storageResponse) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var user:Present.UserResponse!{
            get {
                return ReferenceResponse.Response.getUser(storageResponse)
            }
            set (newvalue) {
                storageResponse = ReferenceResponse.Response.User(newvalue)
            }
        }
        public fileprivate(set) var hasUser:Bool {
            get {
                guard let _ = ReferenceResponse.Response.getUser(storageResponse) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var groupId:String!{
            get {
                return ReferenceResponse.Response.getGroupId(storageResponse)
            }
            set (newvalue) {
                storageResponse = ReferenceResponse.Response.GroupId(newvalue)
            }
        }
        public fileprivate(set) var hasGroupId:Bool {
            get {
                guard let _ = ReferenceResponse.Response.getGroupId(storageResponse) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var group:Present.GroupResponse!{
            get {
                return ReferenceResponse.Response.getGroup(storageResponse)
            }
            set (newvalue) {
                storageResponse = ReferenceResponse.Response.Group(newvalue)
            }
        }
        public fileprivate(set) var hasGroup:Bool {
            get {
                guard let _ = ReferenceResponse.Response.getGroup(storageResponse) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var commentId:String!{
            get {
                return ReferenceResponse.Response.getCommentId(storageResponse)
            }
            set (newvalue) {
                storageResponse = ReferenceResponse.Response.CommentId(newvalue)
            }
        }
        public fileprivate(set) var hasCommentId:Bool {
            get {
                guard let _ = ReferenceResponse.Response.getCommentId(storageResponse) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var comment:Present.CommentResponse!{
            get {
                return ReferenceResponse.Response.getComment(storageResponse)
            }
            set (newvalue) {
                storageResponse = ReferenceResponse.Response.Comment(newvalue)
            }
        }
        public fileprivate(set) var hasComment:Bool {
            get {
                guard let _ = ReferenceResponse.Response.getComment(storageResponse) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if hasUser {
                if !user.isInitialized() {
                    return false
                }
            }
            if hasGroup {
                if !group.isInitialized() {
                    return false
                }
            }
            if hasComment {
                if !comment.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeString(fieldNumber: 1, value:userId)
            }
            if hasUser {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:user)
            }
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 3, value:groupId)
            }
            if hasGroup {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:group)
            }
            if hasCommentId {
                try codedOutputStream.writeString(fieldNumber: 5, value:commentId)
            }
            if hasComment {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:comment)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeStringSize(fieldNumber: 1)
            }
            if hasUser {
                if let varSizeuser = user?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeuser
                }
            }
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 3)
            }
            if hasGroup {
                if let varSizegroup = group?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizegroup
                }
            }
            if hasCommentId {
                serialize_size += commentId.computeStringSize(fieldNumber: 5)
            }
            if hasComment {
                if let varSizecomment = comment?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizecomment
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.ReferenceResponse.Builder {
            return Present.ReferenceResponse.classBuilder() as! Present.ReferenceResponse.Builder
        }
        public func getBuilder() -> Present.ReferenceResponse.Builder {
            return classBuilder() as! Present.ReferenceResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ReferenceResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ReferenceResponse.Builder()
        }
        public func toBuilder() throws -> Present.ReferenceResponse.Builder {
            return try Present.ReferenceResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.ReferenceResponse) throws -> Present.ReferenceResponse.Builder {
            return try Present.ReferenceResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = userId
            }
            if hasUser {
                jsonMap["user"] = try user.encode()
            }
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if hasGroup {
                jsonMap["group"] = try group.encode()
            }
            if hasCommentId {
                jsonMap["commentId"] = commentId
            }
            if hasComment {
                jsonMap["comment"] = try comment.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.ReferenceResponse {
            return try Present.ReferenceResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.ReferenceResponse {
            return try Present.ReferenceResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasUser {
                output += "\(indent) user {\n"
                if let outDescUser = user {
                    output += try outDescUser.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasGroup {
                output += "\(indent) group {\n"
                if let outDescGroup = group {
                    output += try outDescGroup.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCommentId {
                output += "\(indent) commentId: \(commentId) \n"
            }
            if hasComment {
                output += "\(indent) comment {\n"
                if let outDescComment = comment {
                    output += try outDescComment.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasUser {
                    if let hashValueuser = user?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuser
                    }
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasGroup {
                    if let hashValuegroup = group?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegroup
                    }
                }
                if hasCommentId {
                    hashCode = (hashCode &* 31) &+ commentId.hashValue
                }
                if hasComment {
                    if let hashValuecomment = comment?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecomment
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.ReferenceResponse"
        }
        override public func className() -> String {
            return "Present.ReferenceResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.ReferenceResponse = Present.ReferenceResponse()
            public func getMessage() -> Present.ReferenceResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:String {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:String) -> Present.ReferenceResponse.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Present.ReferenceResponse.Builder{
                builderResult.hasUserId = false
                builderResult.userId = ""
                return self
            }
            public var user:Present.UserResponse! {
                get {
                    if userBuilder_ != nil {
                        builderResult.user = userBuilder_.getMessage()
                    }
                    return builderResult.user
                }
                set (value) {
                    builderResult.hasUser = true
                    builderResult.user = value
                }
            }
            public var hasUser:Bool {
                get {
                    return builderResult.hasUser
                }
            }
            fileprivate var userBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasUser = true
                }
            }
            public func getUserBuilder() -> Present.UserResponse.Builder {
                if userBuilder_ == nil {
                    userBuilder_ = Present.UserResponse.Builder()
                    builderResult.user = userBuilder_.getMessage()
                    if user != nil {
                        try! userBuilder_.mergeFrom(other: user)
                    }
                }
                return userBuilder_
            }
            @discardableResult
            public func setUser(_ value:Present.UserResponse!) -> Present.ReferenceResponse.Builder {
                self.user = value
                return self
            }
            @discardableResult
            public func mergeUser(value:Present.UserResponse) throws -> Present.ReferenceResponse.Builder {
                if builderResult.hasUser {
                    builderResult.user = try Present.UserResponse.builderWithPrototype(prototype:builderResult.user).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.user = value
                }
                builderResult.hasUser = true
                return self
            }
            @discardableResult
            public func clearUser() -> Present.ReferenceResponse.Builder {
                userBuilder_ = nil
                builderResult.hasUser = false
                builderResult.user = nil
                return self
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.ReferenceResponse.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.ReferenceResponse.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            public var group:Present.GroupResponse! {
                get {
                    if groupBuilder_ != nil {
                        builderResult.group = groupBuilder_.getMessage()
                    }
                    return builderResult.group
                }
                set (value) {
                    builderResult.hasGroup = true
                    builderResult.group = value
                }
            }
            public var hasGroup:Bool {
                get {
                    return builderResult.hasGroup
                }
            }
            fileprivate var groupBuilder_:Present.GroupResponse.Builder! {
                didSet {
                    builderResult.hasGroup = true
                }
            }
            public func getGroupBuilder() -> Present.GroupResponse.Builder {
                if groupBuilder_ == nil {
                    groupBuilder_ = Present.GroupResponse.Builder()
                    builderResult.group = groupBuilder_.getMessage()
                    if group != nil {
                        try! groupBuilder_.mergeFrom(other: group)
                    }
                }
                return groupBuilder_
            }
            @discardableResult
            public func setGroup(_ value:Present.GroupResponse!) -> Present.ReferenceResponse.Builder {
                self.group = value
                return self
            }
            @discardableResult
            public func mergeGroup(value:Present.GroupResponse) throws -> Present.ReferenceResponse.Builder {
                if builderResult.hasGroup {
                    builderResult.group = try Present.GroupResponse.builderWithPrototype(prototype:builderResult.group).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.group = value
                }
                builderResult.hasGroup = true
                return self
            }
            @discardableResult
            public func clearGroup() -> Present.ReferenceResponse.Builder {
                groupBuilder_ = nil
                builderResult.hasGroup = false
                builderResult.group = nil
                return self
            }
            public var commentId:String {
                get {
                    return builderResult.commentId
                }
                set (value) {
                    builderResult.hasCommentId = true
                    builderResult.commentId = value
                }
            }
            public var hasCommentId:Bool {
                get {
                    return builderResult.hasCommentId
                }
            }
            @discardableResult
            public func setCommentId(_ value:String) -> Present.ReferenceResponse.Builder {
                self.commentId = value
                return self
            }
            @discardableResult
            public func clearCommentId() -> Present.ReferenceResponse.Builder{
                builderResult.hasCommentId = false
                builderResult.commentId = ""
                return self
            }
            public var comment:Present.CommentResponse! {
                get {
                    if commentBuilder_ != nil {
                        builderResult.comment = commentBuilder_.getMessage()
                    }
                    return builderResult.comment
                }
                set (value) {
                    builderResult.hasComment = true
                    builderResult.comment = value
                }
            }
            public var hasComment:Bool {
                get {
                    return builderResult.hasComment
                }
            }
            fileprivate var commentBuilder_:Present.CommentResponse.Builder! {
                didSet {
                    builderResult.hasComment = true
                }
            }
            public func getCommentBuilder() -> Present.CommentResponse.Builder {
                if commentBuilder_ == nil {
                    commentBuilder_ = Present.CommentResponse.Builder()
                    builderResult.comment = commentBuilder_.getMessage()
                    if comment != nil {
                        try! commentBuilder_.mergeFrom(other: comment)
                    }
                }
                return commentBuilder_
            }
            @discardableResult
            public func setComment(_ value:Present.CommentResponse!) -> Present.ReferenceResponse.Builder {
                self.comment = value
                return self
            }
            @discardableResult
            public func mergeComment(value:Present.CommentResponse) throws -> Present.ReferenceResponse.Builder {
                if builderResult.hasComment {
                    builderResult.comment = try Present.CommentResponse.builderWithPrototype(prototype:builderResult.comment).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.comment = value
                }
                builderResult.hasComment = true
                return self
            }
            @discardableResult
            public func clearComment() -> Present.ReferenceResponse.Builder {
                commentBuilder_ = nil
                builderResult.hasComment = false
                builderResult.comment = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.ReferenceResponse.Builder {
                builderResult = Present.ReferenceResponse()
                return self
            }
            override public func clone() throws -> Present.ReferenceResponse.Builder {
                return try Present.ReferenceResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.ReferenceResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.ReferenceResponse {
                let returnMe:Present.ReferenceResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.ReferenceResponse) throws -> Present.ReferenceResponse.Builder {
                if other == Present.ReferenceResponse() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if (other.hasUser) {
                    try mergeUser(value: other.user)
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if (other.hasGroup) {
                    try mergeGroup(value: other.group)
                }
                if other.hasCommentId {
                    commentId = other.commentId
                }
                if (other.hasComment) {
                    try mergeComment(value: other.comment)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.ReferenceResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ReferenceResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userId = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasUser {
                            try subBuilder.mergeFrom(other: user)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        user = subBuilder.buildPartial()

                    case 26:
                        groupId = try codedInputStream.readString()

                    case 34:
                        let subBuilder:Present.GroupResponse.Builder = Present.GroupResponse.Builder()
                        if hasGroup {
                            try subBuilder.mergeFrom(other: group)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        group = subBuilder.buildPartial()

                    case 42:
                        commentId = try codedInputStream.readString()

                    case 50:
                        let subBuilder:Present.CommentResponse.Builder = Present.CommentResponse.Builder()
                        if hasComment {
                            try subBuilder.mergeFrom(other: comment)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        comment = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.ReferenceResponse.Builder {
                let resultDecodedBuilder = Present.ReferenceResponse.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = jsonValueUserId
                }
                if let jsonValueUser = jsonMap["user"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.user = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueUser).build()

                }
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueGroup = jsonMap["group"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.group = try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:jsonValueGroup).build()

                }
                if let jsonValueCommentId = jsonMap["commentId"] as? String {
                    resultDecodedBuilder.commentId = jsonValueCommentId
                }
                if let jsonValueComment = jsonMap["comment"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.comment = try Present.CommentResponse.Builder.decodeToBuilder(jsonMap:jsonValueComment).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.ReferenceResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.ReferenceResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Present.PastActivityRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PastActivityRequest> {
        var mergedArray = Array<Present.PastActivityRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PastActivityRequest? {
        return try Present.PastActivityRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PastActivityRequest {
        return try Present.PastActivityRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.ActivityRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PastActivityRequest {
        return try Present.PastActivityRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PastActivityRequest {
        return try Present.PastActivityRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastActivityRequest {
        return try Present.PastActivityRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PastActivityRequest {
        return try Present.PastActivityRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastActivityRequest {
        return try Present.PastActivityRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "startTime": return self.startTime
        case "endTime": return self.endTime
        default: return nil
        }
    }
}
extension Present.PastActivityRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "startTime": return self.startTime
            case "endTime": return self.endTime
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "startTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.startTime = newSubscriptValue
            case "endTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.endTime = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.PastActivityResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PastActivityResponse> {
        var mergedArray = Array<Present.PastActivityResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PastActivityResponse? {
        return try Present.PastActivityResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PastActivityResponse {
        return try Present.PastActivityResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.ActivityRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PastActivityResponse {
        return try Present.PastActivityResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PastActivityResponse {
        return try Present.PastActivityResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastActivityResponse {
        return try Present.PastActivityResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PastActivityResponse {
        return try Present.PastActivityResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastActivityResponse {
        return try Present.PastActivityResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "events": return self.events
        default: return nil
        }
    }
}
extension Present.PastActivityResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "events": return self.events
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "events":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.EventResponse> else {
                    return
                }
                self.events = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.EventResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.EventResponse> {
        var mergedArray = Array<Present.EventResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.EventResponse? {
        return try Present.EventResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.EventResponse {
        return try Present.EventResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.ActivityRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.EventResponse {
        return try Present.EventResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.EventResponse {
        return try Present.EventResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.EventResponse {
        return try Present.EventResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.EventResponse {
        return try Present.EventResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.EventResponse {
        return try Present.EventResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "uuid": return self.uuid
        case "type": return self.type
        case "when": return self.when
        case "icon": return self.icon
        case "summary": return self.summary
        case "defaultTarget": return self.defaultTarget
        default: return nil
        }
    }
}
extension Present.EventResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "uuid": return self.uuid
            case "type": return self.type
            case "when": return self.when
            case "icon": return self.icon
            case "summary": return self.summary
            case "defaultTarget": return self.defaultTarget
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "uuid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.uuid = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Present.ActivityType else {
                    return
                }
                self.type = newSubscriptValue
            case "when":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.when = newSubscriptValue
            case "icon":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.icon = newSubscriptValue
            case "summary":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.summary = newSubscriptValue
            case "defaultTarget":
                guard let newSubscriptValue = newSubscriptValue as? Present.ReferenceResponse else {
                    return
                }
                self.defaultTarget = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.ReferenceResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.ReferenceResponse> {
        var mergedArray = Array<Present.ReferenceResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.ReferenceResponse? {
        return try Present.ReferenceResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.ReferenceResponse {
        return try Present.ReferenceResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.ActivityRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.ReferenceResponse {
        return try Present.ReferenceResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.ReferenceResponse {
        return try Present.ReferenceResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ReferenceResponse {
        return try Present.ReferenceResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.ReferenceResponse {
        return try Present.ReferenceResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ReferenceResponse {
        return try Present.ReferenceResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "user": return self.user
        case "groupId": return self.groupId
        case "group": return self.group
        case "commentId": return self.commentId
        case "comment": return self.comment
        default: return nil
        }
    }
}
extension Present.ReferenceResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "user": return self.user
            case "groupId": return self.groupId
            case "group": return self.group
            case "commentId": return self.commentId
            case "comment": return self.comment
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            case "user":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.user = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "group":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupResponse else {
                    return
                }
                self.group = newSubscriptValue
            case "commentId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.commentId = newSubscriptValue
            case "comment":
                guard let newSubscriptValue = newSubscriptValue as? Present.CommentResponse else {
                    return
                }
                self.comment = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
