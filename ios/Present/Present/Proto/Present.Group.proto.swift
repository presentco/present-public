/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "group.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public extension Present{}

public extension Present {
    public struct GroupRoot {
        public static let `default` = GroupRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Present.CoreRoot.default.registerAllExtensions(registry: extensionRegistry)
            Present.UserRoot.default.registerAllExtensions(registry: extensionRegistry)
            Present.ContentRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    public enum GroupMembershipState:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        /// User has no association with this group.
        case `none` = 0

        /// TODO: The iOS Client build process requires enum names to be unique.
        /// TODO: We temporarily change the name for the iOS build.  The wire format is unaffected.
        case requestedGroupMembershipState = 1

        /// User was invited to the group by another member.
        case invited = 2

        /// User is a member. Their invitation was approved or they were added directly.
        case active = 3

        /// Membership was rejected or the user was removed from the group.
        case rejected = 4

        /// Member left the group.
        case unjoined = 5
        public func toString() -> String {
            switch self {
            case .`none`: return "NONE"
            case .requestedGroupMembershipState: return "REQUESTED_GROUP_MEMBERSHIP_STATE"
            case .invited: return "INVITED"
            case .active: return "ACTIVE"
            case .rejected: return "REJECTED"
            case .unjoined: return "UNJOINED"
            }
        }
        public static func fromString(str:String) throws -> Present.GroupMembershipState {
            switch str {
            case "NONE":    return .`none`
            case "REQUESTED_GROUP_MEMBERSHIP_STATE":    return .requestedGroupMembershipState
            case "INVITED":    return .invited
            case "ACTIVE":    return .active
            case "REJECTED":    return .rejected
            case "UNJOINED":    return .unjoined
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .`none`: return ".`none`"
            case .requestedGroupMembershipState: return ".requestedGroupMembershipState"
            case .invited: return ".invited"
            case .active: return ".active"
            case .rejected: return ".rejected"
            case .unjoined: return ".unjoined"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:GroupMembershipState, rhs:GroupMembershipState) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum FlagReason:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        case custom = 1
        case spam = 2
        case inappropriate = 3
        public func toString() -> String {
            switch self {
            case .custom: return "CUSTOM"
            case .spam: return "SPAM"
            case .inappropriate: return "INAPPROPRIATE"
            }
        }
        public static func fromString(str:String) throws -> Present.FlagReason {
            switch str {
            case "CUSTOM":    return .custom
            case "SPAM":    return .spam
            case "INAPPROPRIATE":    return .inappropriate
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .custom: return ".custom"
            case .spam: return ".spam"
            case .inappropriate: return ".inappropriate"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:FlagReason, rhs:FlagReason) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    ///UNKNOWN = 0;
    public enum GroupMemberPreapproval:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
        /// TODO: The iOS Client build process requires enum names to be unique.
        /// TODO: We temporarily change the name for the iOS build.  The wire format is unaffected.
        case unknownGroupMemberPreapproval = 0
        case anyone = 1
        case friendsOfMembers = 2
        case friends = 3
        case inviteOnly = 4
        public func toString() -> String {
            switch self {
            case .unknownGroupMemberPreapproval: return "UNKNOWN_GROUP_MEMBER_PREAPPROVAL"
            case .anyone: return "ANYONE"
            case .friendsOfMembers: return "FRIENDS_OF_MEMBERS"
            case .friends: return "FRIENDS"
            case .inviteOnly: return "INVITE_ONLY"
            }
        }
        public static func fromString(str:String) throws -> Present.GroupMemberPreapproval {
            switch str {
            case "UNKNOWN_GROUP_MEMBER_PREAPPROVAL":    return .unknownGroupMemberPreapproval
            case "ANYONE":    return .anyone
            case "FRIENDS_OF_MEMBERS":    return .friendsOfMembers
            case "FRIENDS":    return .friends
            case "INVITE_ONLY":    return .inviteOnly
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .unknownGroupMemberPreapproval: return ".unknownGroupMemberPreapproval"
            case .anyone: return ".anyone"
            case .friendsOfMembers: return ".friendsOfMembers"
            case .friends: return ".friends"
            case .inviteOnly: return ".inviteOnly"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:GroupMemberPreapproval, rhs:GroupMemberPreapproval) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    /// A comment in a group.
    final public class CommentResponse : GeneratedMessage {

        public static func == (lhs: Present.CommentResponse, rhs: Present.CommentResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUuid == rhs.hasUuid) && (!lhs.hasUuid || lhs.uuid == rhs.uuid)
            fieldCheck = fieldCheck && (lhs.hasAuthor == rhs.hasAuthor) && (!lhs.hasAuthor || lhs.author == rhs.author)
            fieldCheck = fieldCheck && (lhs.hasCreationTime == rhs.hasCreationTime) && (!lhs.hasCreationTime || lhs.creationTime == rhs.creationTime)
            fieldCheck = fieldCheck && (lhs.hasComment == rhs.hasComment) && (!lhs.hasComment || lhs.comment == rhs.comment)
            fieldCheck = fieldCheck && (lhs.hasLikes == rhs.hasLikes) && (!lhs.hasLikes || lhs.likes == rhs.likes)
            fieldCheck = fieldCheck && (lhs.hasContent == rhs.hasContent) && (!lhs.hasContent || lhs.content == rhs.content)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasDeleted == rhs.hasDeleted) && (!lhs.hasDeleted || lhs.deleted == rhs.deleted)
            fieldCheck = fieldCheck && (lhs.hasIndex == rhs.hasIndex) && (!lhs.hasIndex || lhs.index == rhs.index)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The unique id of this comment.
        public fileprivate(set) var uuid:String = ""
        public fileprivate(set) var hasUuid:Bool = false

        /// The id of the container for this comment.
        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var author:Present.UserResponse!
        public fileprivate(set) var hasAuthor:Bool = false
        /// The epoch time of the comment.
        public fileprivate(set) var creationTime:UInt64 = UInt64(0)
        public fileprivate(set) var hasCreationTime:Bool = false

        /// The text of the comment. Can be null if content is set or if the comment is deleted.
        public fileprivate(set) var comment:String = ""
        public fileprivate(set) var hasComment:Bool = false

        /// The number of likes for the comment.
        public fileprivate(set) var likes:UInt32 = UInt32(0)
        public fileprivate(set) var hasLikes:Bool = false

        public fileprivate(set) var content:Present.ContentResponse!
        public fileprivate(set) var hasContent:Bool = false
        /// Whether or not this comment was deleted.
        public fileprivate(set) var deleted:Bool = false
        public fileprivate(set) var hasDeleted:Bool = false

        /// The 0-based index of this comment within its group. Used to track how much of a group is read.
        /// Note: The indexes of subsequent comments may not appear contiguous if comments are deleted
        /// or blocked.
        public fileprivate(set) var index:UInt32 = UInt32(0)
        public fileprivate(set) var hasIndex:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUuid {
                return false
            }
            if !hasGroupId {
                return false
            }
            if !hasAuthor {
                return false
            }
            if !hasCreationTime {
                return false
            }
            if !hasLikes {
                return false
            }
            if !hasDeleted {
                return false
            }
            if !hasIndex {
                return false
            }
            if !author.isInitialized() {
                return false
            }
            if hasContent {
                if !content.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUuid {
                try codedOutputStream.writeString(fieldNumber: 1, value:uuid)
            }
            if hasAuthor {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:author)
            }
            if hasCreationTime {
                try codedOutputStream.writeUInt64(fieldNumber: 3, value:creationTime)
            }
            if hasComment {
                try codedOutputStream.writeString(fieldNumber: 5, value:comment)
            }
            if hasLikes {
                try codedOutputStream.writeUInt32(fieldNumber: 6, value:likes)
            }
            if hasContent {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:content)
            }
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 8, value:groupId)
            }
            if hasDeleted {
                try codedOutputStream.writeBool(fieldNumber: 9, value:deleted)
            }
            if hasIndex {
                try codedOutputStream.writeUInt32(fieldNumber: 10, value:index)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUuid {
                serialize_size += uuid.computeStringSize(fieldNumber: 1)
            }
            if hasAuthor {
                if let varSizeauthor = author?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeauthor
                }
            }
            if hasCreationTime {
                serialize_size += creationTime.computeUInt64Size(fieldNumber: 3)
            }
            if hasComment {
                serialize_size += comment.computeStringSize(fieldNumber: 5)
            }
            if hasLikes {
                serialize_size += likes.computeUInt32Size(fieldNumber: 6)
            }
            if hasContent {
                if let varSizecontent = content?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizecontent
                }
            }
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 8)
            }
            if hasDeleted {
                serialize_size += deleted.computeBoolSize(fieldNumber: 9)
            }
            if hasIndex {
                serialize_size += index.computeUInt32Size(fieldNumber: 10)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.CommentResponse.Builder {
            return Present.CommentResponse.classBuilder() as! Present.CommentResponse.Builder
        }
        public func getBuilder() -> Present.CommentResponse.Builder {
            return classBuilder() as! Present.CommentResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CommentResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CommentResponse.Builder()
        }
        public func toBuilder() throws -> Present.CommentResponse.Builder {
            return try Present.CommentResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.CommentResponse) throws -> Present.CommentResponse.Builder {
            return try Present.CommentResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUuid {
                jsonMap["uuid"] = uuid
            }
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if hasAuthor {
                jsonMap["author"] = try author.encode()
            }
            if hasCreationTime {
                jsonMap["creationTime"] = "\(creationTime)"
            }
            if hasComment {
                jsonMap["comment"] = comment
            }
            if hasLikes {
                jsonMap["likes"] = UInt(likes)
            }
            if hasContent {
                jsonMap["content"] = try content.encode()
            }
            if hasDeleted {
                jsonMap["deleted"] = deleted
            }
            if hasIndex {
                jsonMap["index"] = UInt(index)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.CommentResponse {
            return try Present.CommentResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.CommentResponse {
            return try Present.CommentResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUuid {
                output += "\(indent) uuid: \(uuid) \n"
            }
            if hasAuthor {
                output += "\(indent) author {\n"
                if let outDescAuthor = author {
                    output += try outDescAuthor.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCreationTime {
                output += "\(indent) creationTime: \(creationTime) \n"
            }
            if hasComment {
                output += "\(indent) comment: \(comment) \n"
            }
            if hasLikes {
                output += "\(indent) likes: \(likes) \n"
            }
            if hasContent {
                output += "\(indent) content {\n"
                if let outDescContent = content {
                    output += try outDescContent.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasDeleted {
                output += "\(indent) deleted: \(deleted) \n"
            }
            if hasIndex {
                output += "\(indent) index: \(index) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUuid {
                    hashCode = (hashCode &* 31) &+ uuid.hashValue
                }
                if hasAuthor {
                    if let hashValueauthor = author?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueauthor
                    }
                }
                if hasCreationTime {
                    hashCode = (hashCode &* 31) &+ creationTime.hashValue
                }
                if hasComment {
                    hashCode = (hashCode &* 31) &+ comment.hashValue
                }
                if hasLikes {
                    hashCode = (hashCode &* 31) &+ likes.hashValue
                }
                if hasContent {
                    if let hashValuecontent = content?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecontent
                    }
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasDeleted {
                    hashCode = (hashCode &* 31) &+ deleted.hashValue
                }
                if hasIndex {
                    hashCode = (hashCode &* 31) &+ index.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.CommentResponse"
        }
        override public func className() -> String {
            return "Present.CommentResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.CommentResponse = Present.CommentResponse()
            public func getMessage() -> Present.CommentResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The unique id of this comment.
            public var uuid:String {
                get {
                    return builderResult.uuid
                }
                set (value) {
                    builderResult.hasUuid = true
                    builderResult.uuid = value
                }
            }
            public var hasUuid:Bool {
                get {
                    return builderResult.hasUuid
                }
            }
            @discardableResult
            public func setUuid(_ value:String) -> Present.CommentResponse.Builder {
                self.uuid = value
                return self
            }
            @discardableResult
            public func clearUuid() -> Present.CommentResponse.Builder{
                builderResult.hasUuid = false
                builderResult.uuid = ""
                return self
            }
            /// The id of the container for this comment.
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.CommentResponse.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.CommentResponse.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            /// The user who wrote the comment.
            public var author:Present.UserResponse! {
                get {
                    if authorBuilder_ != nil {
                        builderResult.author = authorBuilder_.getMessage()
                    }
                    return builderResult.author
                }
                set (value) {
                    builderResult.hasAuthor = true
                    builderResult.author = value
                }
            }
            public var hasAuthor:Bool {
                get {
                    return builderResult.hasAuthor
                }
            }
            fileprivate var authorBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasAuthor = true
                }
            }
            public func getAuthorBuilder() -> Present.UserResponse.Builder {
                if authorBuilder_ == nil {
                    authorBuilder_ = Present.UserResponse.Builder()
                    builderResult.author = authorBuilder_.getMessage()
                    if author != nil {
                        try! authorBuilder_.mergeFrom(other: author)
                    }
                }
                return authorBuilder_
            }
            @discardableResult
            public func setAuthor(_ value:Present.UserResponse!) -> Present.CommentResponse.Builder {
                self.author = value
                return self
            }
            @discardableResult
            public func mergeAuthor(value:Present.UserResponse) throws -> Present.CommentResponse.Builder {
                if builderResult.hasAuthor {
                    builderResult.author = try Present.UserResponse.builderWithPrototype(prototype:builderResult.author).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.author = value
                }
                builderResult.hasAuthor = true
                return self
            }
            @discardableResult
            public func clearAuthor() -> Present.CommentResponse.Builder {
                authorBuilder_ = nil
                builderResult.hasAuthor = false
                builderResult.author = nil
                return self
            }
            /// The epoch time of the comment.
            public var creationTime:UInt64 {
                get {
                    return builderResult.creationTime
                }
                set (value) {
                    builderResult.hasCreationTime = true
                    builderResult.creationTime = value
                }
            }
            public var hasCreationTime:Bool {
                get {
                    return builderResult.hasCreationTime
                }
            }
            @discardableResult
            public func setCreationTime(_ value:UInt64) -> Present.CommentResponse.Builder {
                self.creationTime = value
                return self
            }
            @discardableResult
            public func clearCreationTime() -> Present.CommentResponse.Builder{
                builderResult.hasCreationTime = false
                builderResult.creationTime = UInt64(0)
                return self
            }
            /// The text of the comment. Can be null if content is set or if the comment is deleted.
            public var comment:String {
                get {
                    return builderResult.comment
                }
                set (value) {
                    builderResult.hasComment = true
                    builderResult.comment = value
                }
            }
            public var hasComment:Bool {
                get {
                    return builderResult.hasComment
                }
            }
            @discardableResult
            public func setComment(_ value:String) -> Present.CommentResponse.Builder {
                self.comment = value
                return self
            }
            @discardableResult
            public func clearComment() -> Present.CommentResponse.Builder{
                builderResult.hasComment = false
                builderResult.comment = ""
                return self
            }
            /// The number of likes for the comment.
            public var likes:UInt32 {
                get {
                    return builderResult.likes
                }
                set (value) {
                    builderResult.hasLikes = true
                    builderResult.likes = value
                }
            }
            public var hasLikes:Bool {
                get {
                    return builderResult.hasLikes
                }
            }
            @discardableResult
            public func setLikes(_ value:UInt32) -> Present.CommentResponse.Builder {
                self.likes = value
                return self
            }
            @discardableResult
            public func clearLikes() -> Present.CommentResponse.Builder{
                builderResult.hasLikes = false
                builderResult.likes = UInt32(0)
                return self
            }
            /// Optional content such as an image of video.
            public var content:Present.ContentResponse! {
                get {
                    if contentBuilder_ != nil {
                        builderResult.content = contentBuilder_.getMessage()
                    }
                    return builderResult.content
                }
                set (value) {
                    builderResult.hasContent = true
                    builderResult.content = value
                }
            }
            public var hasContent:Bool {
                get {
                    return builderResult.hasContent
                }
            }
            fileprivate var contentBuilder_:Present.ContentResponse.Builder! {
                didSet {
                    builderResult.hasContent = true
                }
            }
            public func getContentBuilder() -> Present.ContentResponse.Builder {
                if contentBuilder_ == nil {
                    contentBuilder_ = Present.ContentResponse.Builder()
                    builderResult.content = contentBuilder_.getMessage()
                    if content != nil {
                        try! contentBuilder_.mergeFrom(other: content)
                    }
                }
                return contentBuilder_
            }
            @discardableResult
            public func setContent(_ value:Present.ContentResponse!) -> Present.CommentResponse.Builder {
                self.content = value
                return self
            }
            @discardableResult
            public func mergeContent(value:Present.ContentResponse) throws -> Present.CommentResponse.Builder {
                if builderResult.hasContent {
                    builderResult.content = try Present.ContentResponse.builderWithPrototype(prototype:builderResult.content).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.content = value
                }
                builderResult.hasContent = true
                return self
            }
            @discardableResult
            public func clearContent() -> Present.CommentResponse.Builder {
                contentBuilder_ = nil
                builderResult.hasContent = false
                builderResult.content = nil
                return self
            }
            /// Whether or not this comment was deleted.
            public var deleted:Bool {
                get {
                    return builderResult.deleted
                }
                set (value) {
                    builderResult.hasDeleted = true
                    builderResult.deleted = value
                }
            }
            public var hasDeleted:Bool {
                get {
                    return builderResult.hasDeleted
                }
            }
            @discardableResult
            public func setDeleted(_ value:Bool) -> Present.CommentResponse.Builder {
                self.deleted = value
                return self
            }
            @discardableResult
            public func clearDeleted() -> Present.CommentResponse.Builder{
                builderResult.hasDeleted = false
                builderResult.deleted = false
                return self
            }
            /// The 0-based index of this comment within its group. Used to track how much of a group is read.
            /// Note: The indexes of subsequent comments may not appear contiguous if comments are deleted
            /// or blocked.
            public var index:UInt32 {
                get {
                    return builderResult.index
                }
                set (value) {
                    builderResult.hasIndex = true
                    builderResult.index = value
                }
            }
            public var hasIndex:Bool {
                get {
                    return builderResult.hasIndex
                }
            }
            @discardableResult
            public func setIndex(_ value:UInt32) -> Present.CommentResponse.Builder {
                self.index = value
                return self
            }
            @discardableResult
            public func clearIndex() -> Present.CommentResponse.Builder{
                builderResult.hasIndex = false
                builderResult.index = UInt32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.CommentResponse.Builder {
                builderResult = Present.CommentResponse()
                return self
            }
            override public func clone() throws -> Present.CommentResponse.Builder {
                return try Present.CommentResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.CommentResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.CommentResponse {
                let returnMe:Present.CommentResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.CommentResponse) throws -> Present.CommentResponse.Builder {
                if other == Present.CommentResponse() {
                    return self
                }
                if other.hasUuid {
                    uuid = other.uuid
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if (other.hasAuthor) {
                    try mergeAuthor(value: other.author)
                }
                if other.hasCreationTime {
                    creationTime = other.creationTime
                }
                if other.hasComment {
                    comment = other.comment
                }
                if other.hasLikes {
                    likes = other.likes
                }
                if (other.hasContent) {
                    try mergeContent(value: other.content)
                }
                if other.hasDeleted {
                    deleted = other.deleted
                }
                if other.hasIndex {
                    index = other.index
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.CommentResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CommentResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        uuid = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasAuthor {
                            try subBuilder.mergeFrom(other: author)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        author = subBuilder.buildPartial()

                    case 24:
                        creationTime = try codedInputStream.readUInt64()

                    case 42:
                        comment = try codedInputStream.readString()

                    case 48:
                        likes = try codedInputStream.readUInt32()

                    case 58:
                        let subBuilder:Present.ContentResponse.Builder = Present.ContentResponse.Builder()
                        if hasContent {
                            try subBuilder.mergeFrom(other: content)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        content = subBuilder.buildPartial()

                    case 66:
                        groupId = try codedInputStream.readString()

                    case 72:
                        deleted = try codedInputStream.readBool()

                    case 80:
                        index = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.CommentResponse.Builder {
                let resultDecodedBuilder = Present.CommentResponse.Builder()
                if let jsonValueUuid = jsonMap["uuid"] as? String {
                    resultDecodedBuilder.uuid = jsonValueUuid
                }
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueAuthor = jsonMap["author"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.author = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueAuthor).build()

                }
                if let jsonValueCreationTime = jsonMap["creationTime"] as? String {
                    resultDecodedBuilder.creationTime = UInt64(jsonValueCreationTime)!
                } else if let jsonValueCreationTime = jsonMap["creationTime"] as? UInt {
                    resultDecodedBuilder.creationTime = UInt64(jsonValueCreationTime)
                }
                if let jsonValueComment = jsonMap["comment"] as? String {
                    resultDecodedBuilder.comment = jsonValueComment
                }
                if let jsonValueLikes = jsonMap["likes"] as? UInt {
                    resultDecodedBuilder.likes = UInt32(jsonValueLikes)
                } else if let jsonValueLikes = jsonMap["likes"] as? String {
                    resultDecodedBuilder.likes = UInt32(jsonValueLikes)!
                }
                if let jsonValueContent = jsonMap["content"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.content = try Present.ContentResponse.Builder.decodeToBuilder(jsonMap:jsonValueContent).build()

                }
                if let jsonValueDeleted = jsonMap["deleted"] as? Bool {
                    resultDecodedBuilder.deleted = jsonValueDeleted
                }
                if let jsonValueIndex = jsonMap["index"] as? UInt {
                    resultDecodedBuilder.index = UInt32(jsonValueIndex)
                } else if let jsonValueIndex = jsonMap["index"] as? String {
                    resultDecodedBuilder.index = UInt32(jsonValueIndex)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.CommentResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.CommentResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A group.
    final public class GroupResponse : GeneratedMessage {

        public static func == (lhs: Present.GroupResponse, rhs: Present.GroupResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUuid == rhs.hasUuid) && (!lhs.hasUuid || lhs.uuid == rhs.uuid)
            fieldCheck = fieldCheck && (lhs.hasLocation == rhs.hasLocation) && (!lhs.hasLocation || lhs.location == rhs.location)
            fieldCheck = fieldCheck && (lhs.hasRadius == rhs.hasRadius) && (!lhs.hasRadius || lhs.radius == rhs.radius)
            fieldCheck = fieldCheck && (lhs.hasOwner == rhs.hasOwner) && (!lhs.hasOwner || lhs.owner == rhs.owner)
            fieldCheck = fieldCheck && (lhs.hasCreationTime == rhs.hasCreationTime) && (!lhs.hasCreationTime || lhs.creationTime == rhs.creationTime)
            fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
            fieldCheck = fieldCheck && (lhs.hasMemberCount == rhs.hasMemberCount) && (!lhs.hasMemberCount || lhs.memberCount == rhs.memberCount)
            fieldCheck = fieldCheck && (lhs.hasCommentCount == rhs.hasCommentCount) && (!lhs.hasCommentCount || lhs.commentCount == rhs.commentCount)
            fieldCheck = fieldCheck && (lhs.hasLastCommentTime == rhs.hasLastCommentTime) && (!lhs.hasLastCommentTime || lhs.lastCommentTime == rhs.lastCommentTime)
            fieldCheck = fieldCheck && (lhs.hasLocationName == rhs.hasLocationName) && (!lhs.hasLocationName || lhs.locationName == rhs.locationName)
            fieldCheck = fieldCheck && (lhs.hasCover == rhs.hasCover) && (!lhs.hasCover || lhs.cover == rhs.cover)
            fieldCheck = fieldCheck && (lhs.categories == rhs.categories)
            fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
            fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasUnread == rhs.hasUnread) && (!lhs.hasUnread || lhs.unread == rhs.unread)
            fieldCheck = fieldCheck && (lhs.hasLastRead == rhs.hasLastRead) && (!lhs.hasLastRead || lhs.lastRead == rhs.lastRead)
            fieldCheck = fieldCheck && (lhs.hasMuted == rhs.hasMuted) && (!lhs.hasMuted || lhs.muted == rhs.muted)
            fieldCheck = fieldCheck && (lhs.hasSaved == rhs.hasSaved) && (!lhs.hasSaved || lhs.saved == rhs.saved)
            fieldCheck = fieldCheck && (lhs.hasSchedule == rhs.hasSchedule) && (!lhs.hasSchedule || lhs.schedule == rhs.schedule)
            fieldCheck = fieldCheck && (lhs.hasSpace == rhs.hasSpace) && (!lhs.hasSpace || lhs.space == rhs.space)
            fieldCheck = fieldCheck && (lhs.hasNewlyCreated == rhs.hasNewlyCreated) && (!lhs.hasNewlyCreated || lhs.newlyCreated == rhs.newlyCreated)
            fieldCheck = fieldCheck && (lhs.hasMembershipState == rhs.hasMembershipState) && (!lhs.hasMembershipState || lhs.membershipState == rhs.membershipState)
            fieldCheck = fieldCheck && (lhs.hasPreapprove == rhs.hasPreapprove) && (!lhs.hasPreapprove || lhs.preapprove == rhs.preapprove)
            fieldCheck = fieldCheck && (lhs.hasDiscoverable == rhs.hasDiscoverable) && (!lhs.hasDiscoverable || lhs.discoverable == rhs.discoverable)
            fieldCheck = fieldCheck && (lhs.hasDeleted == rhs.hasDeleted) && (!lhs.hasDeleted || lhs.deleted == rhs.deleted)
            fieldCheck = fieldCheck && (lhs.hasJoinRequests == rhs.hasJoinRequests) && (!lhs.hasJoinRequests || lhs.joinRequests == rhs.joinRequests)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum ProtoType:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case circle = 1
                case direct = 2
                public func toString() -> String {
                    switch self {
                    case .circle: return "CIRCLE"
                    case .direct: return "DIRECT"
                    }
                }
                public static func fromString(str:String) throws -> Present.GroupResponse.ProtoType {
                    switch str {
                    case "CIRCLE":    return .circle
                    case "DIRECT":    return .direct
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .circle: return ".circle"
                    case .direct: return ".direct"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:ProtoType, rhs:ProtoType) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// The uuid of this group
        public fileprivate(set) var uuid:String = ""
        public fileprivate(set) var hasUuid:Bool = false

        public fileprivate(set) var type:Present.GroupResponse.ProtoType = Present.GroupResponse.ProtoType.circle
        public fileprivate(set) var hasType:Bool = false
        public fileprivate(set) var space:Present.SpaceResponse!
        public fileprivate(set) var hasSpace:Bool = false
        /// Epoch time when this group was created.
        public fileprivate(set) var creationTime:UInt64 = UInt64(0)
        public fileprivate(set) var hasCreationTime:Bool = false

        /// Number of members in this group.
        public fileprivate(set) var memberCount:UInt32 = UInt32(0)
        public fileprivate(set) var hasMemberCount:Bool = false

        /// Deprecated: Total number of comments (including blocked and deleted) in this group.
        public fileprivate(set) var commentCount:UInt32 = UInt32(0)
        public fileprivate(set) var hasCommentCount:Bool = false

        /// Epoch time of last comment. -1 if this group contains no comments.
        public fileprivate(set) var lastCommentTime:UInt64 = UInt64(0)
        public fileprivate(set) var hasLastCommentTime:Bool = false

        /// For sharing. May contain referral information for the current user.
        public fileprivate(set) var url:String = ""
        public fileprivate(set) var hasUrl:Bool = false

        /// Title of this circle. Required.
        public fileprivate(set) var title:String = ""
        public fileprivate(set) var hasTitle:Bool = false

        public fileprivate(set) var owner:Present.UserResponse!
        public fileprivate(set) var hasOwner:Bool = false
        public fileprivate(set) var location:Present.Coordinates!
        public fileprivate(set) var hasLocation:Bool = false
        public fileprivate(set) var locationName:String = ""
        public fileprivate(set) var hasLocationName:Bool = false

        public fileprivate(set) var radius:Double = Double(0)
        public fileprivate(set) var hasRadius:Bool = false

        public fileprivate(set) var cover:Present.ContentResponse!
        public fileprivate(set) var hasCover:Bool = false
        /// Categories that can be used in search. Optional.
        public fileprivate(set) var categories:Array<String> = Array<String>()
        /// Describes this circle. Optional.
        public fileprivate(set) var description_:String = ""
        public fileprivate(set) var hasDescription:Bool = false

        public fileprivate(set) var schedule:Present.Schedule!
        public fileprivate(set) var hasSchedule:Bool = false
        /// Number of open join requests.
        public fileprivate(set) var joinRequests:UInt32 = UInt32(0)
        public fileprivate(set) var hasJoinRequests:Bool = false

        /// True if this group is joined and it contains unread comments.
        public fileprivate(set) var unread:Bool = false
        public fileprivate(set) var hasUnread:Bool = false

        /// Index of the last comment read, from CommentResponse.index. To scroll to the member's furthest
        /// known position in the chat, find the last comment where CommentResponse.index <= lastRead.
        /// A value of -1 is returned if no messages have been read.
        public fileprivate(set) var lastRead:Int32 = Int32(0)
        public fileprivate(set) var hasLastRead:Bool = false

        /// True if the user muted this group. When a group is muted, we mark the group as unread
        /// but we don't send notifications.
        public fileprivate(set) var muted:Bool = false
        public fileprivate(set) var hasMuted:Bool = false

        /// TODO: Rename to "joined". Update web at the same time.
        /// True if the user saved this group.
        public fileprivate(set) var saved:Bool = false
        public fileprivate(set) var hasSaved:Bool = false

        public fileprivate(set) var membershipState:Present.GroupMembershipState = Present.GroupMembershipState.`none`
        public fileprivate(set) var hasMembershipState:Bool = false
        /// Was the group created since the user's last session?
        public fileprivate(set) var newlyCreated:Bool = false
        public fileprivate(set) var hasNewlyCreated:Bool = false

        public fileprivate(set) var preapprove:Present.GroupMemberPreapproval = Present.GroupMemberPreapproval.unknownGroupMemberPreapproval
        public fileprivate(set) var hasPreapprove:Bool = false
        /// Whether or not this circle is discoverable by friends and people nearby
        public fileprivate(set) var discoverable:Bool = false
        public fileprivate(set) var hasDiscoverable:Bool = false

        /// True if this group was deleted.
        public fileprivate(set) var deleted:Bool = false
        public fileprivate(set) var hasDeleted:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUuid {
                return false
            }
            if !hasType {
                return false
            }
            if !hasCreationTime {
                return false
            }
            if !hasMemberCount {
                return false
            }
            if !hasCommentCount {
                return false
            }
            if !hasLastCommentTime {
                return false
            }
            if !hasUrl {
                return false
            }
            if !hasRadius {
                return false
            }
            if !hasJoinRequests {
                return false
            }
            if !hasPreapprove {
                return false
            }
            if !hasDiscoverable {
                return false
            }
            if !hasDeleted {
                return false
            }
            if hasSpace {
                if !space.isInitialized() {
                    return false
                }
            }
            if hasOwner {
                if !owner.isInitialized() {
                    return false
                }
            }
            if hasLocation {
                if !location.isInitialized() {
                    return false
                }
            }
            if hasCover {
                if !cover.isInitialized() {
                    return false
                }
            }
            if hasSchedule {
                if !schedule.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUuid {
                try codedOutputStream.writeString(fieldNumber: 1, value:uuid)
            }
            if hasLocation {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:location)
            }
            if hasRadius {
                try codedOutputStream.writeDouble(fieldNumber: 3, value:radius)
            }
            if hasOwner {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:owner)
            }
            if hasCreationTime {
                try codedOutputStream.writeUInt64(fieldNumber: 5, value:creationTime)
            }
            if hasTitle {
                try codedOutputStream.writeString(fieldNumber: 6, value:title)
            }
            if hasMemberCount {
                try codedOutputStream.writeUInt32(fieldNumber: 7, value:memberCount)
            }
            if hasCommentCount {
                try codedOutputStream.writeUInt32(fieldNumber: 8, value:commentCount)
            }
            if hasLastCommentTime {
                try codedOutputStream.writeUInt64(fieldNumber: 9, value:lastCommentTime)
            }
            if hasLocationName {
                try codedOutputStream.writeString(fieldNumber: 10, value:locationName)
            }
            if hasCover {
                try codedOutputStream.writeMessage(fieldNumber: 11, value:cover)
            }
            if !categories.isEmpty {
                for oneValuecategories in categories {
                    try codedOutputStream.writeString(fieldNumber: 12, value:oneValuecategories)
                }
            }
            if hasDescription {
                try codedOutputStream.writeString(fieldNumber: 13, value:description_)
            }
            if hasUrl {
                try codedOutputStream.writeString(fieldNumber: 14, value:url)
            }
            if hasType {
                try codedOutputStream.writeEnum(fieldNumber: 15, value:type.rawValue)
            }
            if hasUnread {
                try codedOutputStream.writeBool(fieldNumber: 16, value:unread)
            }
            if hasLastRead {
                try codedOutputStream.writeInt32(fieldNumber: 17, value:lastRead)
            }
            if hasMuted {
                try codedOutputStream.writeBool(fieldNumber: 18, value:muted)
            }
            if hasSaved {
                try codedOutputStream.writeBool(fieldNumber: 19, value:saved)
            }
            if hasSchedule {
                try codedOutputStream.writeMessage(fieldNumber: 20, value:schedule)
            }
            if hasSpace {
                try codedOutputStream.writeMessage(fieldNumber: 21, value:space)
            }
            if hasNewlyCreated {
                try codedOutputStream.writeBool(fieldNumber: 22, value:newlyCreated)
            }
            if hasMembershipState {
                try codedOutputStream.writeEnum(fieldNumber: 24, value:membershipState.rawValue)
            }
            if hasPreapprove {
                try codedOutputStream.writeEnum(fieldNumber: 25, value:preapprove.rawValue)
            }
            if hasDiscoverable {
                try codedOutputStream.writeBool(fieldNumber: 26, value:discoverable)
            }
            if hasDeleted {
                try codedOutputStream.writeBool(fieldNumber: 27, value:deleted)
            }
            if hasJoinRequests {
                try codedOutputStream.writeUInt32(fieldNumber: 28, value:joinRequests)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUuid {
                serialize_size += uuid.computeStringSize(fieldNumber: 1)
            }
            if hasLocation {
                if let varSizelocation = location?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizelocation
                }
            }
            if hasRadius {
                serialize_size += radius.computeDoubleSize(fieldNumber: 3)
            }
            if hasOwner {
                if let varSizeowner = owner?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeowner
                }
            }
            if hasCreationTime {
                serialize_size += creationTime.computeUInt64Size(fieldNumber: 5)
            }
            if hasTitle {
                serialize_size += title.computeStringSize(fieldNumber: 6)
            }
            if hasMemberCount {
                serialize_size += memberCount.computeUInt32Size(fieldNumber: 7)
            }
            if hasCommentCount {
                serialize_size += commentCount.computeUInt32Size(fieldNumber: 8)
            }
            if hasLastCommentTime {
                serialize_size += lastCommentTime.computeUInt64Size(fieldNumber: 9)
            }
            if hasLocationName {
                serialize_size += locationName.computeStringSize(fieldNumber: 10)
            }
            if hasCover {
                if let varSizecover = cover?.computeMessageSize(fieldNumber: 11) {
                    serialize_size += varSizecover
                }
            }
            var dataSizeCategories:Int32 = 0
            for oneValuecategories in categories {
                dataSizeCategories += oneValuecategories.computeStringSizeNoTag()
            }
            serialize_size += dataSizeCategories
            serialize_size += 1 * Int32(categories.count)
            if hasDescription {
                serialize_size += description_.computeStringSize(fieldNumber: 13)
            }
            if hasUrl {
                serialize_size += url.computeStringSize(fieldNumber: 14)
            }
            if (hasType) {
                serialize_size += type.rawValue.computeEnumSize(fieldNumber: 15)
            }
            if hasUnread {
                serialize_size += unread.computeBoolSize(fieldNumber: 16)
            }
            if hasLastRead {
                serialize_size += lastRead.computeInt32Size(fieldNumber: 17)
            }
            if hasMuted {
                serialize_size += muted.computeBoolSize(fieldNumber: 18)
            }
            if hasSaved {
                serialize_size += saved.computeBoolSize(fieldNumber: 19)
            }
            if hasSchedule {
                if let varSizeschedule = schedule?.computeMessageSize(fieldNumber: 20) {
                    serialize_size += varSizeschedule
                }
            }
            if hasSpace {
                if let varSizespace = space?.computeMessageSize(fieldNumber: 21) {
                    serialize_size += varSizespace
                }
            }
            if hasNewlyCreated {
                serialize_size += newlyCreated.computeBoolSize(fieldNumber: 22)
            }
            if (hasMembershipState) {
                serialize_size += membershipState.rawValue.computeEnumSize(fieldNumber: 24)
            }
            if (hasPreapprove) {
                serialize_size += preapprove.rawValue.computeEnumSize(fieldNumber: 25)
            }
            if hasDiscoverable {
                serialize_size += discoverable.computeBoolSize(fieldNumber: 26)
            }
            if hasDeleted {
                serialize_size += deleted.computeBoolSize(fieldNumber: 27)
            }
            if hasJoinRequests {
                serialize_size += joinRequests.computeUInt32Size(fieldNumber: 28)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.GroupResponse.Builder {
            return Present.GroupResponse.classBuilder() as! Present.GroupResponse.Builder
        }
        public func getBuilder() -> Present.GroupResponse.Builder {
            return classBuilder() as! Present.GroupResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupResponse.Builder()
        }
        public func toBuilder() throws -> Present.GroupResponse.Builder {
            return try Present.GroupResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.GroupResponse) throws -> Present.GroupResponse.Builder {
            return try Present.GroupResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUuid {
                jsonMap["uuid"] = uuid
            }
            if hasType {
                jsonMap["type"] = type.toString()
            }
            if hasSpace {
                jsonMap["space"] = try space.encode()
            }
            if hasCreationTime {
                jsonMap["creationTime"] = "\(creationTime)"
            }
            if hasMemberCount {
                jsonMap["memberCount"] = UInt(memberCount)
            }
            if hasCommentCount {
                jsonMap["commentCount"] = UInt(commentCount)
            }
            if hasLastCommentTime {
                jsonMap["lastCommentTime"] = "\(lastCommentTime)"
            }
            if hasUrl {
                jsonMap["url"] = url
            }
            if hasTitle {
                jsonMap["title"] = title
            }
            if hasOwner {
                jsonMap["owner"] = try owner.encode()
            }
            if hasLocation {
                jsonMap["location"] = try location.encode()
            }
            if hasLocationName {
                jsonMap["locationName"] = locationName
            }
            if hasRadius {
                jsonMap["radius"] = Double(radius)
            }
            if hasCover {
                jsonMap["cover"] = try cover.encode()
            }
            if !categories.isEmpty {
                var jsonArrayCategories:Array<String> = []
                for oneValueCategories in categories {
                    jsonArrayCategories.append(oneValueCategories)
                }
                jsonMap["categories"] = jsonArrayCategories
            }
            if hasDescription {
                jsonMap["description"] = description_
            }
            if hasSchedule {
                jsonMap["schedule"] = try schedule.encode()
            }
            if hasJoinRequests {
                jsonMap["joinRequests"] = UInt(joinRequests)
            }
            if hasUnread {
                jsonMap["unread"] = unread
            }
            if hasLastRead {
                jsonMap["lastRead"] = Int(lastRead)
            }
            if hasMuted {
                jsonMap["muted"] = muted
            }
            if hasSaved {
                jsonMap["saved"] = saved
            }
            if hasMembershipState {
                jsonMap["membershipState"] = membershipState.toString()
            }
            if hasNewlyCreated {
                jsonMap["newlyCreated"] = newlyCreated
            }
            if hasPreapprove {
                jsonMap["preapprove"] = preapprove.toString()
            }
            if hasDiscoverable {
                jsonMap["discoverable"] = discoverable
            }
            if hasDeleted {
                jsonMap["deleted"] = deleted
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.GroupResponse {
            return try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.GroupResponse {
            return try Present.GroupResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUuid {
                output += "\(indent) uuid: \(uuid) \n"
            }
            if hasLocation {
                output += "\(indent) location {\n"
                if let outDescLocation = location {
                    output += try outDescLocation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasRadius {
                output += "\(indent) radius: \(radius) \n"
            }
            if hasOwner {
                output += "\(indent) owner {\n"
                if let outDescOwner = owner {
                    output += try outDescOwner.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCreationTime {
                output += "\(indent) creationTime: \(creationTime) \n"
            }
            if hasTitle {
                output += "\(indent) title: \(title) \n"
            }
            if hasMemberCount {
                output += "\(indent) memberCount: \(memberCount) \n"
            }
            if hasCommentCount {
                output += "\(indent) commentCount: \(commentCount) \n"
            }
            if hasLastCommentTime {
                output += "\(indent) lastCommentTime: \(lastCommentTime) \n"
            }
            if hasLocationName {
                output += "\(indent) locationName: \(locationName) \n"
            }
            if hasCover {
                output += "\(indent) cover {\n"
                if let outDescCover = cover {
                    output += try outDescCover.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var categoriesElementIndex:Int = 0
            for oneValueCategories in categories  {
                output += "\(indent) categories[\(categoriesElementIndex)]: \(oneValueCategories)\n"
                categoriesElementIndex += 1
            }
            if hasDescription {
                output += "\(indent) description: \(description_) \n"
            }
            if hasUrl {
                output += "\(indent) url: \(url) \n"
            }
            if (hasType) {
                output += "\(indent) type: \(type.description)\n"
            }
            if hasUnread {
                output += "\(indent) unread: \(unread) \n"
            }
            if hasLastRead {
                output += "\(indent) lastRead: \(lastRead) \n"
            }
            if hasMuted {
                output += "\(indent) muted: \(muted) \n"
            }
            if hasSaved {
                output += "\(indent) saved: \(saved) \n"
            }
            if hasSchedule {
                output += "\(indent) schedule {\n"
                if let outDescSchedule = schedule {
                    output += try outDescSchedule.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSpace {
                output += "\(indent) space {\n"
                if let outDescSpace = space {
                    output += try outDescSpace.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasNewlyCreated {
                output += "\(indent) newlyCreated: \(newlyCreated) \n"
            }
            if (hasMembershipState) {
                output += "\(indent) membershipState: \(membershipState.description)\n"
            }
            if (hasPreapprove) {
                output += "\(indent) preapprove: \(preapprove.description)\n"
            }
            if hasDiscoverable {
                output += "\(indent) discoverable: \(discoverable) \n"
            }
            if hasDeleted {
                output += "\(indent) deleted: \(deleted) \n"
            }
            if hasJoinRequests {
                output += "\(indent) joinRequests: \(joinRequests) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUuid {
                    hashCode = (hashCode &* 31) &+ uuid.hashValue
                }
                if hasLocation {
                    if let hashValuelocation = location?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelocation
                    }
                }
                if hasRadius {
                    hashCode = (hashCode &* 31) &+ radius.hashValue
                }
                if hasOwner {
                    if let hashValueowner = owner?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueowner
                    }
                }
                if hasCreationTime {
                    hashCode = (hashCode &* 31) &+ creationTime.hashValue
                }
                if hasTitle {
                    hashCode = (hashCode &* 31) &+ title.hashValue
                }
                if hasMemberCount {
                    hashCode = (hashCode &* 31) &+ memberCount.hashValue
                }
                if hasCommentCount {
                    hashCode = (hashCode &* 31) &+ commentCount.hashValue
                }
                if hasLastCommentTime {
                    hashCode = (hashCode &* 31) &+ lastCommentTime.hashValue
                }
                if hasLocationName {
                    hashCode = (hashCode &* 31) &+ locationName.hashValue
                }
                if hasCover {
                    if let hashValuecover = cover?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecover
                    }
                }
                for oneValueCategories in categories {
                    hashCode = (hashCode &* 31) &+ oneValueCategories.hashValue
                }
                if hasDescription {
                    hashCode = (hashCode &* 31) &+ description_.hashValue
                }
                if hasUrl {
                    hashCode = (hashCode &* 31) &+ url.hashValue
                }
                if hasType {
                     hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasUnread {
                    hashCode = (hashCode &* 31) &+ unread.hashValue
                }
                if hasLastRead {
                    hashCode = (hashCode &* 31) &+ lastRead.hashValue
                }
                if hasMuted {
                    hashCode = (hashCode &* 31) &+ muted.hashValue
                }
                if hasSaved {
                    hashCode = (hashCode &* 31) &+ saved.hashValue
                }
                if hasSchedule {
                    if let hashValueschedule = schedule?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueschedule
                    }
                }
                if hasSpace {
                    if let hashValuespace = space?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuespace
                    }
                }
                if hasNewlyCreated {
                    hashCode = (hashCode &* 31) &+ newlyCreated.hashValue
                }
                if hasMembershipState {
                     hashCode = (hashCode &* 31) &+ membershipState.hashValue
                }
                if hasPreapprove {
                     hashCode = (hashCode &* 31) &+ preapprove.hashValue
                }
                if hasDiscoverable {
                    hashCode = (hashCode &* 31) &+ discoverable.hashValue
                }
                if hasDeleted {
                    hashCode = (hashCode &* 31) &+ deleted.hashValue
                }
                if hasJoinRequests {
                    hashCode = (hashCode &* 31) &+ joinRequests.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.GroupResponse"
        }
        override public func className() -> String {
            return "Present.GroupResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.GroupResponse = Present.GroupResponse()
            public func getMessage() -> Present.GroupResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The uuid of this group
            public var uuid:String {
                get {
                    return builderResult.uuid
                }
                set (value) {
                    builderResult.hasUuid = true
                    builderResult.uuid = value
                }
            }
            public var hasUuid:Bool {
                get {
                    return builderResult.hasUuid
                }
            }
            @discardableResult
            public func setUuid(_ value:String) -> Present.GroupResponse.Builder {
                self.uuid = value
                return self
            }
            @discardableResult
            public func clearUuid() -> Present.GroupResponse.Builder{
                builderResult.hasUuid = false
                builderResult.uuid = ""
                return self
            }
            /// The type of this group (circle or direct).
                public var type:Present.GroupResponse.ProtoType {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool{
                    get {
                        return builderResult.hasType
                    }
                }
            @discardableResult
                public func setType(_ value:Present.GroupResponse.ProtoType) -> Present.GroupResponse.Builder {
                  self.type = value
                  return self
                }
            @discardableResult
                public func clearType() -> Present.GroupResponse.Builder {
                   builderResult.hasType = false
                   builderResult.type = .circle
                   return self
                }
            /// Space this circle belongs to. Null for direct groups.
            public var space:Present.SpaceResponse! {
                get {
                    if spaceBuilder_ != nil {
                        builderResult.space = spaceBuilder_.getMessage()
                    }
                    return builderResult.space
                }
                set (value) {
                    builderResult.hasSpace = true
                    builderResult.space = value
                }
            }
            public var hasSpace:Bool {
                get {
                    return builderResult.hasSpace
                }
            }
            fileprivate var spaceBuilder_:Present.SpaceResponse.Builder! {
                didSet {
                    builderResult.hasSpace = true
                }
            }
            public func getSpaceBuilder() -> Present.SpaceResponse.Builder {
                if spaceBuilder_ == nil {
                    spaceBuilder_ = Present.SpaceResponse.Builder()
                    builderResult.space = spaceBuilder_.getMessage()
                    if space != nil {
                        try! spaceBuilder_.mergeFrom(other: space)
                    }
                }
                return spaceBuilder_
            }
            @discardableResult
            public func setSpace(_ value:Present.SpaceResponse!) -> Present.GroupResponse.Builder {
                self.space = value
                return self
            }
            @discardableResult
            public func mergeSpace(value:Present.SpaceResponse) throws -> Present.GroupResponse.Builder {
                if builderResult.hasSpace {
                    builderResult.space = try Present.SpaceResponse.builderWithPrototype(prototype:builderResult.space).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.space = value
                }
                builderResult.hasSpace = true
                return self
            }
            @discardableResult
            public func clearSpace() -> Present.GroupResponse.Builder {
                spaceBuilder_ = nil
                builderResult.hasSpace = false
                builderResult.space = nil
                return self
            }
            /// Epoch time when this group was created.
            public var creationTime:UInt64 {
                get {
                    return builderResult.creationTime
                }
                set (value) {
                    builderResult.hasCreationTime = true
                    builderResult.creationTime = value
                }
            }
            public var hasCreationTime:Bool {
                get {
                    return builderResult.hasCreationTime
                }
            }
            @discardableResult
            public func setCreationTime(_ value:UInt64) -> Present.GroupResponse.Builder {
                self.creationTime = value
                return self
            }
            @discardableResult
            public func clearCreationTime() -> Present.GroupResponse.Builder{
                builderResult.hasCreationTime = false
                builderResult.creationTime = UInt64(0)
                return self
            }
            /// Number of members in this group.
            public var memberCount:UInt32 {
                get {
                    return builderResult.memberCount
                }
                set (value) {
                    builderResult.hasMemberCount = true
                    builderResult.memberCount = value
                }
            }
            public var hasMemberCount:Bool {
                get {
                    return builderResult.hasMemberCount
                }
            }
            @discardableResult
            public func setMemberCount(_ value:UInt32) -> Present.GroupResponse.Builder {
                self.memberCount = value
                return self
            }
            @discardableResult
            public func clearMemberCount() -> Present.GroupResponse.Builder{
                builderResult.hasMemberCount = false
                builderResult.memberCount = UInt32(0)
                return self
            }
            /// Deprecated: Total number of comments (including blocked and deleted) in this group.
            public var commentCount:UInt32 {
                get {
                    return builderResult.commentCount
                }
                set (value) {
                    builderResult.hasCommentCount = true
                    builderResult.commentCount = value
                }
            }
            public var hasCommentCount:Bool {
                get {
                    return builderResult.hasCommentCount
                }
            }
            @discardableResult
            public func setCommentCount(_ value:UInt32) -> Present.GroupResponse.Builder {
                self.commentCount = value
                return self
            }
            @discardableResult
            public func clearCommentCount() -> Present.GroupResponse.Builder{
                builderResult.hasCommentCount = false
                builderResult.commentCount = UInt32(0)
                return self
            }
            /// Epoch time of last comment. -1 if this group contains no comments.
            public var lastCommentTime:UInt64 {
                get {
                    return builderResult.lastCommentTime
                }
                set (value) {
                    builderResult.hasLastCommentTime = true
                    builderResult.lastCommentTime = value
                }
            }
            public var hasLastCommentTime:Bool {
                get {
                    return builderResult.hasLastCommentTime
                }
            }
            @discardableResult
            public func setLastCommentTime(_ value:UInt64) -> Present.GroupResponse.Builder {
                self.lastCommentTime = value
                return self
            }
            @discardableResult
            public func clearLastCommentTime() -> Present.GroupResponse.Builder{
                builderResult.hasLastCommentTime = false
                builderResult.lastCommentTime = UInt64(0)
                return self
            }
            /// For sharing. May contain referral information for the current user.
            public var url:String {
                get {
                    return builderResult.url
                }
                set (value) {
                    builderResult.hasUrl = true
                    builderResult.url = value
                }
            }
            public var hasUrl:Bool {
                get {
                    return builderResult.hasUrl
                }
            }
            @discardableResult
            public func setUrl(_ value:String) -> Present.GroupResponse.Builder {
                self.url = value
                return self
            }
            @discardableResult
            public func clearUrl() -> Present.GroupResponse.Builder{
                builderResult.hasUrl = false
                builderResult.url = ""
                return self
            }
            /// Title of this circle. Required.
            public var title:String {
                get {
                    return builderResult.title
                }
                set (value) {
                    builderResult.hasTitle = true
                    builderResult.title = value
                }
            }
            public var hasTitle:Bool {
                get {
                    return builderResult.hasTitle
                }
            }
            @discardableResult
            public func setTitle(_ value:String) -> Present.GroupResponse.Builder {
                self.title = value
                return self
            }
            @discardableResult
            public func clearTitle() -> Present.GroupResponse.Builder{
                builderResult.hasTitle = false
                builderResult.title = ""
                return self
            }
            /// Owner of this circle. Required.
            public var owner:Present.UserResponse! {
                get {
                    if ownerBuilder_ != nil {
                        builderResult.owner = ownerBuilder_.getMessage()
                    }
                    return builderResult.owner
                }
                set (value) {
                    builderResult.hasOwner = true
                    builderResult.owner = value
                }
            }
            public var hasOwner:Bool {
                get {
                    return builderResult.hasOwner
                }
            }
            fileprivate var ownerBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasOwner = true
                }
            }
            public func getOwnerBuilder() -> Present.UserResponse.Builder {
                if ownerBuilder_ == nil {
                    ownerBuilder_ = Present.UserResponse.Builder()
                    builderResult.owner = ownerBuilder_.getMessage()
                    if owner != nil {
                        try! ownerBuilder_.mergeFrom(other: owner)
                    }
                }
                return ownerBuilder_
            }
            @discardableResult
            public func setOwner(_ value:Present.UserResponse!) -> Present.GroupResponse.Builder {
                self.owner = value
                return self
            }
            @discardableResult
            public func mergeOwner(value:Present.UserResponse) throws -> Present.GroupResponse.Builder {
                if builderResult.hasOwner {
                    builderResult.owner = try Present.UserResponse.builderWithPrototype(prototype:builderResult.owner).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.owner = value
                }
                builderResult.hasOwner = true
                return self
            }
            @discardableResult
            public func clearOwner() -> Present.GroupResponse.Builder {
                ownerBuilder_ = nil
                builderResult.hasOwner = false
                builderResult.owner = nil
                return self
            }
            /// The coordinates and name of this circle's location. Required.
            public var location:Present.Coordinates! {
                get {
                    if locationBuilder_ != nil {
                        builderResult.location = locationBuilder_.getMessage()
                    }
                    return builderResult.location
                }
                set (value) {
                    builderResult.hasLocation = true
                    builderResult.location = value
                }
            }
            public var hasLocation:Bool {
                get {
                    return builderResult.hasLocation
                }
            }
            fileprivate var locationBuilder_:Present.Coordinates.Builder! {
                didSet {
                    builderResult.hasLocation = true
                }
            }
            public func getLocationBuilder() -> Present.Coordinates.Builder {
                if locationBuilder_ == nil {
                    locationBuilder_ = Present.Coordinates.Builder()
                    builderResult.location = locationBuilder_.getMessage()
                    if location != nil {
                        try! locationBuilder_.mergeFrom(other: location)
                    }
                }
                return locationBuilder_
            }
            @discardableResult
            public func setLocation(_ value:Present.Coordinates!) -> Present.GroupResponse.Builder {
                self.location = value
                return self
            }
            @discardableResult
            public func mergeLocation(value:Present.Coordinates) throws -> Present.GroupResponse.Builder {
                if builderResult.hasLocation {
                    builderResult.location = try Present.Coordinates.builderWithPrototype(prototype:builderResult.location).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.location = value
                }
                builderResult.hasLocation = true
                return self
            }
            @discardableResult
            public func clearLocation() -> Present.GroupResponse.Builder {
                locationBuilder_ = nil
                builderResult.hasLocation = false
                builderResult.location = nil
                return self
            }
            public var locationName:String {
                get {
                    return builderResult.locationName
                }
                set (value) {
                    builderResult.hasLocationName = true
                    builderResult.locationName = value
                }
            }
            public var hasLocationName:Bool {
                get {
                    return builderResult.hasLocationName
                }
            }
            @discardableResult
            public func setLocationName(_ value:String) -> Present.GroupResponse.Builder {
                self.locationName = value
                return self
            }
            @discardableResult
            public func clearLocationName() -> Present.GroupResponse.Builder{
                builderResult.hasLocationName = false
                builderResult.locationName = ""
                return self
            }
            public var radius:Double {
                get {
                    return builderResult.radius
                }
                set (value) {
                    builderResult.hasRadius = true
                    builderResult.radius = value
                }
            }
            public var hasRadius:Bool {
                get {
                    return builderResult.hasRadius
                }
            }
            @discardableResult
            public func setRadius(_ value:Double) -> Present.GroupResponse.Builder {
                self.radius = value
                return self
            }
            @discardableResult
            public func clearRadius() -> Present.GroupResponse.Builder{
                builderResult.hasRadius = false
                builderResult.radius = Double(0)
                return self
            }
            /// Cover photo with 16:9 aspect ratio.
            public var cover:Present.ContentResponse! {
                get {
                    if coverBuilder_ != nil {
                        builderResult.cover = coverBuilder_.getMessage()
                    }
                    return builderResult.cover
                }
                set (value) {
                    builderResult.hasCover = true
                    builderResult.cover = value
                }
            }
            public var hasCover:Bool {
                get {
                    return builderResult.hasCover
                }
            }
            fileprivate var coverBuilder_:Present.ContentResponse.Builder! {
                didSet {
                    builderResult.hasCover = true
                }
            }
            public func getCoverBuilder() -> Present.ContentResponse.Builder {
                if coverBuilder_ == nil {
                    coverBuilder_ = Present.ContentResponse.Builder()
                    builderResult.cover = coverBuilder_.getMessage()
                    if cover != nil {
                        try! coverBuilder_.mergeFrom(other: cover)
                    }
                }
                return coverBuilder_
            }
            @discardableResult
            public func setCover(_ value:Present.ContentResponse!) -> Present.GroupResponse.Builder {
                self.cover = value
                return self
            }
            @discardableResult
            public func mergeCover(value:Present.ContentResponse) throws -> Present.GroupResponse.Builder {
                if builderResult.hasCover {
                    builderResult.cover = try Present.ContentResponse.builderWithPrototype(prototype:builderResult.cover).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.cover = value
                }
                builderResult.hasCover = true
                return self
            }
            @discardableResult
            public func clearCover() -> Present.GroupResponse.Builder {
                coverBuilder_ = nil
                builderResult.hasCover = false
                builderResult.cover = nil
                return self
            }
            /// Categories that can be used in search. Optional.
            public var categories:Array<String> {
                get {
                    return builderResult.categories
                }
                set (array) {
                    builderResult.categories = array
                }
            }
            @discardableResult
            public func setCategories(_ value:Array<String>) -> Present.GroupResponse.Builder {
                self.categories = value
                return self
            }
            @discardableResult
            public func clearCategories() -> Present.GroupResponse.Builder {
                builderResult.categories.removeAll(keepingCapacity: false)
                return self
            }
            /// Describes this circle. Optional.
            public var description_:String {
                get {
                    return builderResult.description_
                }
                set (value) {
                    builderResult.hasDescription = true
                    builderResult.description_ = value
                }
            }
            public var hasDescription:Bool {
                get {
                    return builderResult.hasDescription
                }
            }
            @discardableResult
            public func setDescription(_ value:String) -> Present.GroupResponse.Builder {
                self.description_ = value
                return self
            }
            @discardableResult
            public func clearDescription() -> Present.GroupResponse.Builder{
                builderResult.hasDescription = false
                builderResult.description_ = ""
                return self
            }
            /// Stores an optional time and duration for a scheduled event in this circle.
            public var schedule:Present.Schedule! {
                get {
                    if scheduleBuilder_ != nil {
                        builderResult.schedule = scheduleBuilder_.getMessage()
                    }
                    return builderResult.schedule
                }
                set (value) {
                    builderResult.hasSchedule = true
                    builderResult.schedule = value
                }
            }
            public var hasSchedule:Bool {
                get {
                    return builderResult.hasSchedule
                }
            }
            fileprivate var scheduleBuilder_:Present.Schedule.Builder! {
                didSet {
                    builderResult.hasSchedule = true
                }
            }
            public func getScheduleBuilder() -> Present.Schedule.Builder {
                if scheduleBuilder_ == nil {
                    scheduleBuilder_ = Present.Schedule.Builder()
                    builderResult.schedule = scheduleBuilder_.getMessage()
                    if schedule != nil {
                        try! scheduleBuilder_.mergeFrom(other: schedule)
                    }
                }
                return scheduleBuilder_
            }
            @discardableResult
            public func setSchedule(_ value:Present.Schedule!) -> Present.GroupResponse.Builder {
                self.schedule = value
                return self
            }
            @discardableResult
            public func mergeSchedule(value:Present.Schedule) throws -> Present.GroupResponse.Builder {
                if builderResult.hasSchedule {
                    builderResult.schedule = try Present.Schedule.builderWithPrototype(prototype:builderResult.schedule).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.schedule = value
                }
                builderResult.hasSchedule = true
                return self
            }
            @discardableResult
            public func clearSchedule() -> Present.GroupResponse.Builder {
                scheduleBuilder_ = nil
                builderResult.hasSchedule = false
                builderResult.schedule = nil
                return self
            }
            /// Number of open join requests.
            public var joinRequests:UInt32 {
                get {
                    return builderResult.joinRequests
                }
                set (value) {
                    builderResult.hasJoinRequests = true
                    builderResult.joinRequests = value
                }
            }
            public var hasJoinRequests:Bool {
                get {
                    return builderResult.hasJoinRequests
                }
            }
            @discardableResult
            public func setJoinRequests(_ value:UInt32) -> Present.GroupResponse.Builder {
                self.joinRequests = value
                return self
            }
            @discardableResult
            public func clearJoinRequests() -> Present.GroupResponse.Builder{
                builderResult.hasJoinRequests = false
                builderResult.joinRequests = UInt32(0)
                return self
            }
            /// True if this group is joined and it contains unread comments.
            public var unread:Bool {
                get {
                    return builderResult.unread
                }
                set (value) {
                    builderResult.hasUnread = true
                    builderResult.unread = value
                }
            }
            public var hasUnread:Bool {
                get {
                    return builderResult.hasUnread
                }
            }
            @discardableResult
            public func setUnread(_ value:Bool) -> Present.GroupResponse.Builder {
                self.unread = value
                return self
            }
            @discardableResult
            public func clearUnread() -> Present.GroupResponse.Builder{
                builderResult.hasUnread = false
                builderResult.unread = false
                return self
            }
            /// Index of the last comment read, from CommentResponse.index. To scroll to the member's furthest
            /// known position in the chat, find the last comment where CommentResponse.index <= lastRead.
            /// A value of -1 is returned if no messages have been read.
            public var lastRead:Int32 {
                get {
                    return builderResult.lastRead
                }
                set (value) {
                    builderResult.hasLastRead = true
                    builderResult.lastRead = value
                }
            }
            public var hasLastRead:Bool {
                get {
                    return builderResult.hasLastRead
                }
            }
            @discardableResult
            public func setLastRead(_ value:Int32) -> Present.GroupResponse.Builder {
                self.lastRead = value
                return self
            }
            @discardableResult
            public func clearLastRead() -> Present.GroupResponse.Builder{
                builderResult.hasLastRead = false
                builderResult.lastRead = Int32(0)
                return self
            }
            /// True if the user muted this group. When a group is muted, we mark the group as unread
            /// but we don't send notifications.
            public var muted:Bool {
                get {
                    return builderResult.muted
                }
                set (value) {
                    builderResult.hasMuted = true
                    builderResult.muted = value
                }
            }
            public var hasMuted:Bool {
                get {
                    return builderResult.hasMuted
                }
            }
            @discardableResult
            public func setMuted(_ value:Bool) -> Present.GroupResponse.Builder {
                self.muted = value
                return self
            }
            @discardableResult
            public func clearMuted() -> Present.GroupResponse.Builder{
                builderResult.hasMuted = false
                builderResult.muted = false
                return self
            }
            /// TODO: Rename to "joined". Update web at the same time.
            /// True if the user saved this group.
            public var saved:Bool {
                get {
                    return builderResult.saved
                }
                set (value) {
                    builderResult.hasSaved = true
                    builderResult.saved = value
                }
            }
            public var hasSaved:Bool {
                get {
                    return builderResult.hasSaved
                }
            }
            @discardableResult
            public func setSaved(_ value:Bool) -> Present.GroupResponse.Builder {
                self.saved = value
                return self
            }
            @discardableResult
            public func clearSaved() -> Present.GroupResponse.Builder{
                builderResult.hasSaved = false
                builderResult.saved = false
                return self
            }
            /// The user's current membership status.
                public var membershipState:Present.GroupMembershipState {
                    get {
                        return builderResult.membershipState
                    }
                    set (value) {
                        builderResult.hasMembershipState = true
                        builderResult.membershipState = value
                    }
                }
                public var hasMembershipState:Bool{
                    get {
                        return builderResult.hasMembershipState
                    }
                }
            @discardableResult
                public func setMembershipState(_ value:Present.GroupMembershipState) -> Present.GroupResponse.Builder {
                  self.membershipState = value
                  return self
                }
            @discardableResult
                public func clearMembershipState() -> Present.GroupResponse.Builder {
                   builderResult.hasMembershipState = false
                   builderResult.membershipState = .`none`
                   return self
                }
            /// Was the group created since the user's last session?
            public var newlyCreated:Bool {
                get {
                    return builderResult.newlyCreated
                }
                set (value) {
                    builderResult.hasNewlyCreated = true
                    builderResult.newlyCreated = value
                }
            }
            public var hasNewlyCreated:Bool {
                get {
                    return builderResult.hasNewlyCreated
                }
            }
            @discardableResult
            public func setNewlyCreated(_ value:Bool) -> Present.GroupResponse.Builder {
                self.newlyCreated = value
                return self
            }
            @discardableResult
            public func clearNewlyCreated() -> Present.GroupResponse.Builder{
                builderResult.hasNewlyCreated = false
                builderResult.newlyCreated = false
                return self
            }
            /// Who is pre-approved for membership?
                public var preapprove:Present.GroupMemberPreapproval {
                    get {
                        return builderResult.preapprove
                    }
                    set (value) {
                        builderResult.hasPreapprove = true
                        builderResult.preapprove = value
                    }
                }
                public var hasPreapprove:Bool{
                    get {
                        return builderResult.hasPreapprove
                    }
                }
            @discardableResult
                public func setPreapprove(_ value:Present.GroupMemberPreapproval) -> Present.GroupResponse.Builder {
                  self.preapprove = value
                  return self
                }
            @discardableResult
                public func clearPreapprove() -> Present.GroupResponse.Builder {
                   builderResult.hasPreapprove = false
                   builderResult.preapprove = .unknownGroupMemberPreapproval
                   return self
                }
            /// Whether or not this circle is discoverable by friends and people nearby
            public var discoverable:Bool {
                get {
                    return builderResult.discoverable
                }
                set (value) {
                    builderResult.hasDiscoverable = true
                    builderResult.discoverable = value
                }
            }
            public var hasDiscoverable:Bool {
                get {
                    return builderResult.hasDiscoverable
                }
            }
            @discardableResult
            public func setDiscoverable(_ value:Bool) -> Present.GroupResponse.Builder {
                self.discoverable = value
                return self
            }
            @discardableResult
            public func clearDiscoverable() -> Present.GroupResponse.Builder{
                builderResult.hasDiscoverable = false
                builderResult.discoverable = false
                return self
            }
            /// True if this group was deleted.
            public var deleted:Bool {
                get {
                    return builderResult.deleted
                }
                set (value) {
                    builderResult.hasDeleted = true
                    builderResult.deleted = value
                }
            }
            public var hasDeleted:Bool {
                get {
                    return builderResult.hasDeleted
                }
            }
            @discardableResult
            public func setDeleted(_ value:Bool) -> Present.GroupResponse.Builder {
                self.deleted = value
                return self
            }
            @discardableResult
            public func clearDeleted() -> Present.GroupResponse.Builder{
                builderResult.hasDeleted = false
                builderResult.deleted = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.GroupResponse.Builder {
                builderResult = Present.GroupResponse()
                return self
            }
            override public func clone() throws -> Present.GroupResponse.Builder {
                return try Present.GroupResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.GroupResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.GroupResponse {
                let returnMe:Present.GroupResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.GroupResponse) throws -> Present.GroupResponse.Builder {
                if other == Present.GroupResponse() {
                    return self
                }
                if other.hasUuid {
                    uuid = other.uuid
                }
                if other.hasType {
                    type = other.type
                }
                if (other.hasSpace) {
                    try mergeSpace(value: other.space)
                }
                if other.hasCreationTime {
                    creationTime = other.creationTime
                }
                if other.hasMemberCount {
                    memberCount = other.memberCount
                }
                if other.hasCommentCount {
                    commentCount = other.commentCount
                }
                if other.hasLastCommentTime {
                    lastCommentTime = other.lastCommentTime
                }
                if other.hasUrl {
                    url = other.url
                }
                if other.hasTitle {
                    title = other.title
                }
                if (other.hasOwner) {
                    try mergeOwner(value: other.owner)
                }
                if (other.hasLocation) {
                    try mergeLocation(value: other.location)
                }
                if other.hasLocationName {
                    locationName = other.locationName
                }
                if other.hasRadius {
                    radius = other.radius
                }
                if (other.hasCover) {
                    try mergeCover(value: other.cover)
                }
                if !other.categories.isEmpty {
                    builderResult.categories += other.categories
                }
                if other.hasDescription {
                    description_ = other.description_
                }
                if (other.hasSchedule) {
                    try mergeSchedule(value: other.schedule)
                }
                if other.hasJoinRequests {
                    joinRequests = other.joinRequests
                }
                if other.hasUnread {
                    unread = other.unread
                }
                if other.hasLastRead {
                    lastRead = other.lastRead
                }
                if other.hasMuted {
                    muted = other.muted
                }
                if other.hasSaved {
                    saved = other.saved
                }
                if other.hasMembershipState {
                    membershipState = other.membershipState
                }
                if other.hasNewlyCreated {
                    newlyCreated = other.newlyCreated
                }
                if other.hasPreapprove {
                    preapprove = other.preapprove
                }
                if other.hasDiscoverable {
                    discoverable = other.discoverable
                }
                if other.hasDeleted {
                    deleted = other.deleted
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.GroupResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        uuid = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Present.Coordinates.Builder = Present.Coordinates.Builder()
                        if hasLocation {
                            try subBuilder.mergeFrom(other: location)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        location = subBuilder.buildPartial()

                    case 25:
                        radius = try codedInputStream.readDouble()

                    case 34:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasOwner {
                            try subBuilder.mergeFrom(other: owner)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        owner = subBuilder.buildPartial()

                    case 40:
                        creationTime = try codedInputStream.readUInt64()

                    case 50:
                        title = try codedInputStream.readString()

                    case 56:
                        memberCount = try codedInputStream.readUInt32()

                    case 64:
                        commentCount = try codedInputStream.readUInt32()

                    case 72:
                        lastCommentTime = try codedInputStream.readUInt64()

                    case 82:
                        locationName = try codedInputStream.readString()

                    case 90:
                        let subBuilder:Present.ContentResponse.Builder = Present.ContentResponse.Builder()
                        if hasCover {
                            try subBuilder.mergeFrom(other: cover)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        cover = subBuilder.buildPartial()

                    case 98:
                        categories += [try codedInputStream.readString()]

                    case 106:
                        description_ = try codedInputStream.readString()

                    case 114:
                        url = try codedInputStream.readString()

                    case 120:
                        let valueInttype = try codedInputStream.readEnum()
                        if let enumstype = Present.GroupResponse.ProtoType(rawValue:valueInttype){
                            type = enumstype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 15, value:Int64(valueInttype))
                        }

                    case 128:
                        unread = try codedInputStream.readBool()

                    case 136:
                        lastRead = try codedInputStream.readInt32()

                    case 144:
                        muted = try codedInputStream.readBool()

                    case 152:
                        saved = try codedInputStream.readBool()

                    case 162:
                        let subBuilder:Present.Schedule.Builder = Present.Schedule.Builder()
                        if hasSchedule {
                            try subBuilder.mergeFrom(other: schedule)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        schedule = subBuilder.buildPartial()

                    case 170:
                        let subBuilder:Present.SpaceResponse.Builder = Present.SpaceResponse.Builder()
                        if hasSpace {
                            try subBuilder.mergeFrom(other: space)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        space = subBuilder.buildPartial()

                    case 176:
                        newlyCreated = try codedInputStream.readBool()

                    case 192:
                        let valueIntmembershipState = try codedInputStream.readEnum()
                        if let enumsmembershipState = Present.GroupMembershipState(rawValue:valueIntmembershipState){
                            membershipState = enumsmembershipState
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 24, value:Int64(valueIntmembershipState))
                        }

                    case 200:
                        let valueIntpreapprove = try codedInputStream.readEnum()
                        if let enumspreapprove = Present.GroupMemberPreapproval(rawValue:valueIntpreapprove){
                            preapprove = enumspreapprove
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 25, value:Int64(valueIntpreapprove))
                        }

                    case 208:
                        discoverable = try codedInputStream.readBool()

                    case 216:
                        deleted = try codedInputStream.readBool()

                    case 224:
                        joinRequests = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.GroupResponse.Builder {
                let resultDecodedBuilder = Present.GroupResponse.Builder()
                if let jsonValueUuid = jsonMap["uuid"] as? String {
                    resultDecodedBuilder.uuid = jsonValueUuid
                }
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = try Present.GroupResponse.ProtoType.fromString(str: jsonValueType)
                }
                if let jsonValueSpace = jsonMap["space"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.space = try Present.SpaceResponse.Builder.decodeToBuilder(jsonMap:jsonValueSpace).build()

                }
                if let jsonValueCreationTime = jsonMap["creationTime"] as? String {
                    resultDecodedBuilder.creationTime = UInt64(jsonValueCreationTime)!
                } else if let jsonValueCreationTime = jsonMap["creationTime"] as? UInt {
                    resultDecodedBuilder.creationTime = UInt64(jsonValueCreationTime)
                }
                if let jsonValueMemberCount = jsonMap["memberCount"] as? UInt {
                    resultDecodedBuilder.memberCount = UInt32(jsonValueMemberCount)
                } else if let jsonValueMemberCount = jsonMap["memberCount"] as? String {
                    resultDecodedBuilder.memberCount = UInt32(jsonValueMemberCount)!
                }
                if let jsonValueCommentCount = jsonMap["commentCount"] as? UInt {
                    resultDecodedBuilder.commentCount = UInt32(jsonValueCommentCount)
                } else if let jsonValueCommentCount = jsonMap["commentCount"] as? String {
                    resultDecodedBuilder.commentCount = UInt32(jsonValueCommentCount)!
                }
                if let jsonValueLastCommentTime = jsonMap["lastCommentTime"] as? String {
                    resultDecodedBuilder.lastCommentTime = UInt64(jsonValueLastCommentTime)!
                } else if let jsonValueLastCommentTime = jsonMap["lastCommentTime"] as? UInt {
                    resultDecodedBuilder.lastCommentTime = UInt64(jsonValueLastCommentTime)
                }
                if let jsonValueUrl = jsonMap["url"] as? String {
                    resultDecodedBuilder.url = jsonValueUrl
                }
                if let jsonValueTitle = jsonMap["title"] as? String {
                    resultDecodedBuilder.title = jsonValueTitle
                }
                if let jsonValueOwner = jsonMap["owner"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.owner = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueOwner).build()

                }
                if let jsonValueLocation = jsonMap["location"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.location = try Present.Coordinates.Builder.decodeToBuilder(jsonMap:jsonValueLocation).build()

                }
                if let jsonValueLocationName = jsonMap["locationName"] as? String {
                    resultDecodedBuilder.locationName = jsonValueLocationName
                }
                if let jsonValueRadius = jsonMap["radius"] as? Double {
                    resultDecodedBuilder.radius = Double(jsonValueRadius)
                } else if let jsonValueRadius = jsonMap["radius"] as? String {
                    resultDecodedBuilder.radius = Double(jsonValueRadius)!
                }
                if let jsonValueCover = jsonMap["cover"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.cover = try Present.ContentResponse.Builder.decodeToBuilder(jsonMap:jsonValueCover).build()

                }
                if let jsonValueCategories = jsonMap["categories"] as? Array<String> {
                    var jsonArrayCategories:Array<String> = []
                    for oneValueCategories in jsonValueCategories {
                        jsonArrayCategories.append(oneValueCategories)
                    }
                    resultDecodedBuilder.categories = jsonArrayCategories
                }
                if let jsonValueDescription = jsonMap["description"] as? String {
                    resultDecodedBuilder.description_ = jsonValueDescription
                }
                if let jsonValueSchedule = jsonMap["schedule"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.schedule = try Present.Schedule.Builder.decodeToBuilder(jsonMap:jsonValueSchedule).build()

                }
                if let jsonValueJoinRequests = jsonMap["joinRequests"] as? UInt {
                    resultDecodedBuilder.joinRequests = UInt32(jsonValueJoinRequests)
                } else if let jsonValueJoinRequests = jsonMap["joinRequests"] as? String {
                    resultDecodedBuilder.joinRequests = UInt32(jsonValueJoinRequests)!
                }
                if let jsonValueUnread = jsonMap["unread"] as? Bool {
                    resultDecodedBuilder.unread = jsonValueUnread
                }
                if let jsonValueLastRead = jsonMap["lastRead"] as? Int {
                    resultDecodedBuilder.lastRead = Int32(jsonValueLastRead)
                } else if let jsonValueLastRead = jsonMap["lastRead"] as? String {
                    resultDecodedBuilder.lastRead = Int32(jsonValueLastRead)!
                }
                if let jsonValueMuted = jsonMap["muted"] as? Bool {
                    resultDecodedBuilder.muted = jsonValueMuted
                }
                if let jsonValueSaved = jsonMap["saved"] as? Bool {
                    resultDecodedBuilder.saved = jsonValueSaved
                }
                if let jsonValueMembershipState = jsonMap["membershipState"] as? String {
                    resultDecodedBuilder.membershipState = try Present.GroupMembershipState.fromString(str: jsonValueMembershipState)
                }
                if let jsonValueNewlyCreated = jsonMap["newlyCreated"] as? Bool {
                    resultDecodedBuilder.newlyCreated = jsonValueNewlyCreated
                }
                if let jsonValuePreapprove = jsonMap["preapprove"] as? String {
                    resultDecodedBuilder.preapprove = try Present.GroupMemberPreapproval.fromString(str: jsonValuePreapprove)
                }
                if let jsonValueDiscoverable = jsonMap["discoverable"] as? Bool {
                    resultDecodedBuilder.discoverable = jsonValueDiscoverable
                }
                if let jsonValueDeleted = jsonMap["deleted"] as? Bool {
                    resultDecodedBuilder.deleted = jsonValueDeleted
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.GroupResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GroupRequest : GeneratedMessage {

        public static func == (lhs: Present.GroupRequest, rhs: Present.GroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.GroupRequest.Builder {
            return Present.GroupRequest.classBuilder() as! Present.GroupRequest.Builder
        }
        public func getBuilder() -> Present.GroupRequest.Builder {
            return classBuilder() as! Present.GroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.GroupRequest.Builder {
            return try Present.GroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.GroupRequest) throws -> Present.GroupRequest.Builder {
            return try Present.GroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.GroupRequest {
            return try Present.GroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.GroupRequest {
            return try Present.GroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.GroupRequest"
        }
        override public func className() -> String {
            return "Present.GroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.GroupRequest = Present.GroupRequest()
            public func getMessage() -> Present.GroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.GroupRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.GroupRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.GroupRequest.Builder {
                builderResult = Present.GroupRequest()
                return self
            }
            override public func clone() throws -> Present.GroupRequest.Builder {
                return try Present.GroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.GroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.GroupRequest {
                let returnMe:Present.GroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.GroupRequest) throws -> Present.GroupRequest.Builder {
                if other == Present.GroupRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.GroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.GroupRequest.Builder {
                let resultDecodedBuilder = Present.GroupRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.GroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.GroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NearbyGroupsRequest : GeneratedMessage {

        public static func == (lhs: Present.NearbyGroupsRequest, rhs: Present.NearbyGroupsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLocation == rhs.hasLocation) && (!lhs.hasLocation || lhs.location == rhs.location)
            fieldCheck = fieldCheck && (lhs.hasSpaceId == rhs.hasSpaceId) && (!lhs.hasSpaceId || lhs.spaceId == rhs.spaceId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var location:Present.Coordinates!
        public fileprivate(set) var hasLocation:Bool = false
        public fileprivate(set) var spaceId:String = ""
        public fileprivate(set) var hasSpaceId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if hasLocation {
                if !location.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLocation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:location)
            }
            if hasSpaceId {
                try codedOutputStream.writeString(fieldNumber: 2, value:spaceId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLocation {
                if let varSizelocation = location?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizelocation
                }
            }
            if hasSpaceId {
                serialize_size += spaceId.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.NearbyGroupsRequest.Builder {
            return Present.NearbyGroupsRequest.classBuilder() as! Present.NearbyGroupsRequest.Builder
        }
        public func getBuilder() -> Present.NearbyGroupsRequest.Builder {
            return classBuilder() as! Present.NearbyGroupsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.NearbyGroupsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.NearbyGroupsRequest.Builder()
        }
        public func toBuilder() throws -> Present.NearbyGroupsRequest.Builder {
            return try Present.NearbyGroupsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.NearbyGroupsRequest) throws -> Present.NearbyGroupsRequest.Builder {
            return try Present.NearbyGroupsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLocation {
                jsonMap["location"] = try location.encode()
            }
            if hasSpaceId {
                jsonMap["spaceId"] = spaceId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.NearbyGroupsRequest {
            return try Present.NearbyGroupsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.NearbyGroupsRequest {
            return try Present.NearbyGroupsRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLocation {
                output += "\(indent) location {\n"
                if let outDescLocation = location {
                    output += try outDescLocation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSpaceId {
                output += "\(indent) spaceId: \(spaceId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLocation {
                    if let hashValuelocation = location?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelocation
                    }
                }
                if hasSpaceId {
                    hashCode = (hashCode &* 31) &+ spaceId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.NearbyGroupsRequest"
        }
        override public func className() -> String {
            return "Present.NearbyGroupsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.NearbyGroupsRequest = Present.NearbyGroupsRequest()
            public func getMessage() -> Present.NearbyGroupsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Deprecated
            public var location:Present.Coordinates! {
                get {
                    if locationBuilder_ != nil {
                        builderResult.location = locationBuilder_.getMessage()
                    }
                    return builderResult.location
                }
                set (value) {
                    builderResult.hasLocation = true
                    builderResult.location = value
                }
            }
            public var hasLocation:Bool {
                get {
                    return builderResult.hasLocation
                }
            }
            fileprivate var locationBuilder_:Present.Coordinates.Builder! {
                didSet {
                    builderResult.hasLocation = true
                }
            }
            public func getLocationBuilder() -> Present.Coordinates.Builder {
                if locationBuilder_ == nil {
                    locationBuilder_ = Present.Coordinates.Builder()
                    builderResult.location = locationBuilder_.getMessage()
                    if location != nil {
                        try! locationBuilder_.mergeFrom(other: location)
                    }
                }
                return locationBuilder_
            }
            @discardableResult
            public func setLocation(_ value:Present.Coordinates!) -> Present.NearbyGroupsRequest.Builder {
                self.location = value
                return self
            }
            @discardableResult
            public func mergeLocation(value:Present.Coordinates) throws -> Present.NearbyGroupsRequest.Builder {
                if builderResult.hasLocation {
                    builderResult.location = try Present.Coordinates.builderWithPrototype(prototype:builderResult.location).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.location = value
                }
                builderResult.hasLocation = true
                return self
            }
            @discardableResult
            public func clearLocation() -> Present.NearbyGroupsRequest.Builder {
                locationBuilder_ = nil
                builderResult.hasLocation = false
                builderResult.location = nil
                return self
            }
            public var spaceId:String {
                get {
                    return builderResult.spaceId
                }
                set (value) {
                    builderResult.hasSpaceId = true
                    builderResult.spaceId = value
                }
            }
            public var hasSpaceId:Bool {
                get {
                    return builderResult.hasSpaceId
                }
            }
            @discardableResult
            public func setSpaceId(_ value:String) -> Present.NearbyGroupsRequest.Builder {
                self.spaceId = value
                return self
            }
            @discardableResult
            public func clearSpaceId() -> Present.NearbyGroupsRequest.Builder{
                builderResult.hasSpaceId = false
                builderResult.spaceId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.NearbyGroupsRequest.Builder {
                builderResult = Present.NearbyGroupsRequest()
                return self
            }
            override public func clone() throws -> Present.NearbyGroupsRequest.Builder {
                return try Present.NearbyGroupsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.NearbyGroupsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.NearbyGroupsRequest {
                let returnMe:Present.NearbyGroupsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.NearbyGroupsRequest) throws -> Present.NearbyGroupsRequest.Builder {
                if other == Present.NearbyGroupsRequest() {
                    return self
                }
                if (other.hasLocation) {
                    try mergeLocation(value: other.location)
                }
                if other.hasSpaceId {
                    spaceId = other.spaceId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.NearbyGroupsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.NearbyGroupsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.Coordinates.Builder = Present.Coordinates.Builder()
                        if hasLocation {
                            try subBuilder.mergeFrom(other: location)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        location = subBuilder.buildPartial()

                    case 18:
                        spaceId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.NearbyGroupsRequest.Builder {
                let resultDecodedBuilder = Present.NearbyGroupsRequest.Builder()
                if let jsonValueLocation = jsonMap["location"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.location = try Present.Coordinates.Builder.decodeToBuilder(jsonMap:jsonValueLocation).build()

                }
                if let jsonValueSpaceId = jsonMap["spaceId"] as? String {
                    resultDecodedBuilder.spaceId = jsonValueSpaceId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.NearbyGroupsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.NearbyGroupsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NearbyGroupsResponse : GeneratedMessage {

        public static func == (lhs: Present.NearbyGroupsResponse, rhs: Present.NearbyGroupsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.nearbyGroups == rhs.nearbyGroups)
            fieldCheck = fieldCheck && (lhs.hasMutedGroups == rhs.hasMutedGroups) && (!lhs.hasMutedGroups || lhs.mutedGroups == rhs.mutedGroups)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var nearbyGroups:Array<Present.GroupResponse>  = Array<Present.GroupResponse>()
        public fileprivate(set) var mutedGroups:Present.MutedGroupsResponse!
        public fileprivate(set) var hasMutedGroups:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitNearbyGroups:Bool = true
            for oneElementNearbyGroups in nearbyGroups {
                if !oneElementNearbyGroups.isInitialized() {
                    isInitNearbyGroups = false
                    break 
                }
            }
            if !isInitNearbyGroups {
                return isInitNearbyGroups
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementNearbyGroups in nearbyGroups {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementNearbyGroups)
            }
            if hasMutedGroups {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:mutedGroups)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementNearbyGroups in nearbyGroups {
                serialize_size += oneElementNearbyGroups.computeMessageSize(fieldNumber: 1)
            }
            if hasMutedGroups {
                if let varSizemutedGroups = mutedGroups?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizemutedGroups
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.NearbyGroupsResponse.Builder {
            return Present.NearbyGroupsResponse.classBuilder() as! Present.NearbyGroupsResponse.Builder
        }
        public func getBuilder() -> Present.NearbyGroupsResponse.Builder {
            return classBuilder() as! Present.NearbyGroupsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.NearbyGroupsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.NearbyGroupsResponse.Builder()
        }
        public func toBuilder() throws -> Present.NearbyGroupsResponse.Builder {
            return try Present.NearbyGroupsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.NearbyGroupsResponse) throws -> Present.NearbyGroupsResponse.Builder {
            return try Present.NearbyGroupsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !nearbyGroups.isEmpty {
                var jsonArrayNearbyGroups:Array<Dictionary<String,Any>> = []
                for oneValueNearbyGroups in nearbyGroups {
                    let ecodedMessageNearbyGroups = try oneValueNearbyGroups.encode()
                    jsonArrayNearbyGroups.append(ecodedMessageNearbyGroups)
                }
                jsonMap["nearbyGroups"] = jsonArrayNearbyGroups
            }
            if hasMutedGroups {
                jsonMap["mutedGroups"] = try mutedGroups.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.NearbyGroupsResponse {
            return try Present.NearbyGroupsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.NearbyGroupsResponse {
            return try Present.NearbyGroupsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var nearbyGroupsElementIndex:Int = 0
            for oneElementNearbyGroups in nearbyGroups {
                output += "\(indent) nearbyGroups[\(nearbyGroupsElementIndex)] {\n"
                output += try oneElementNearbyGroups.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nearbyGroupsElementIndex += 1
            }
            if hasMutedGroups {
                output += "\(indent) mutedGroups {\n"
                if let outDescMutedGroups = mutedGroups {
                    output += try outDescMutedGroups.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementNearbyGroups in nearbyGroups {
                    hashCode = (hashCode &* 31) &+ oneElementNearbyGroups.hashValue
                }
                if hasMutedGroups {
                    if let hashValuemutedGroups = mutedGroups?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemutedGroups
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.NearbyGroupsResponse"
        }
        override public func className() -> String {
            return "Present.NearbyGroupsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.NearbyGroupsResponse = Present.NearbyGroupsResponse()
            public func getMessage() -> Present.NearbyGroupsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var nearbyGroups:Array<Present.GroupResponse> {
                get {
                    return builderResult.nearbyGroups
                }
                set (value) {
                    builderResult.nearbyGroups = value
                }
            }
            @discardableResult
            public func setNearbyGroups(_ value:Array<Present.GroupResponse>) -> Present.NearbyGroupsResponse.Builder {
                self.nearbyGroups = value
                return self
            }
            @discardableResult
            public func clearNearbyGroups() -> Present.NearbyGroupsResponse.Builder {
                builderResult.nearbyGroups.removeAll(keepingCapacity: false)
                return self
            }
            /// Deprecated. Use GroupResponse.muted instead.
            public var mutedGroups:Present.MutedGroupsResponse! {
                get {
                    if mutedGroupsBuilder_ != nil {
                        builderResult.mutedGroups = mutedGroupsBuilder_.getMessage()
                    }
                    return builderResult.mutedGroups
                }
                set (value) {
                    builderResult.hasMutedGroups = true
                    builderResult.mutedGroups = value
                }
            }
            public var hasMutedGroups:Bool {
                get {
                    return builderResult.hasMutedGroups
                }
            }
            fileprivate var mutedGroupsBuilder_:Present.MutedGroupsResponse.Builder! {
                didSet {
                    builderResult.hasMutedGroups = true
                }
            }
            public func getMutedGroupsBuilder() -> Present.MutedGroupsResponse.Builder {
                if mutedGroupsBuilder_ == nil {
                    mutedGroupsBuilder_ = Present.MutedGroupsResponse.Builder()
                    builderResult.mutedGroups = mutedGroupsBuilder_.getMessage()
                    if mutedGroups != nil {
                        try! mutedGroupsBuilder_.mergeFrom(other: mutedGroups)
                    }
                }
                return mutedGroupsBuilder_
            }
            @discardableResult
            public func setMutedGroups(_ value:Present.MutedGroupsResponse!) -> Present.NearbyGroupsResponse.Builder {
                self.mutedGroups = value
                return self
            }
            @discardableResult
            public func mergeMutedGroups(value:Present.MutedGroupsResponse) throws -> Present.NearbyGroupsResponse.Builder {
                if builderResult.hasMutedGroups {
                    builderResult.mutedGroups = try Present.MutedGroupsResponse.builderWithPrototype(prototype:builderResult.mutedGroups).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.mutedGroups = value
                }
                builderResult.hasMutedGroups = true
                return self
            }
            @discardableResult
            public func clearMutedGroups() -> Present.NearbyGroupsResponse.Builder {
                mutedGroupsBuilder_ = nil
                builderResult.hasMutedGroups = false
                builderResult.mutedGroups = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.NearbyGroupsResponse.Builder {
                builderResult = Present.NearbyGroupsResponse()
                return self
            }
            override public func clone() throws -> Present.NearbyGroupsResponse.Builder {
                return try Present.NearbyGroupsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.NearbyGroupsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.NearbyGroupsResponse {
                let returnMe:Present.NearbyGroupsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.NearbyGroupsResponse) throws -> Present.NearbyGroupsResponse.Builder {
                if other == Present.NearbyGroupsResponse() {
                    return self
                }
                if !other.nearbyGroups.isEmpty  {
                     builderResult.nearbyGroups += other.nearbyGroups
                }
                if (other.hasMutedGroups) {
                    try mergeMutedGroups(value: other.mutedGroups)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.NearbyGroupsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.NearbyGroupsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.GroupResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        nearbyGroups.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder:Present.MutedGroupsResponse.Builder = Present.MutedGroupsResponse.Builder()
                        if hasMutedGroups {
                            try subBuilder.mergeFrom(other: mutedGroups)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        mutedGroups = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.NearbyGroupsResponse.Builder {
                let resultDecodedBuilder = Present.NearbyGroupsResponse.Builder()
                if let jsonValueNearbyGroups = jsonMap["nearbyGroups"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNearbyGroups:Array<Present.GroupResponse> = []
                    for oneValueNearbyGroups in jsonValueNearbyGroups {
                        let messageFromStringNearbyGroups = try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:oneValueNearbyGroups).build()

                        jsonArrayNearbyGroups.append(messageFromStringNearbyGroups)
                    }
                    resultDecodedBuilder.nearbyGroups = jsonArrayNearbyGroups
                }
                if let jsonValueMutedGroups = jsonMap["mutedGroups"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.mutedGroups = try Present.MutedGroupsResponse.Builder.decodeToBuilder(jsonMap:jsonValueMutedGroups).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.NearbyGroupsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.NearbyGroupsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DirectGroupRequest : GeneratedMessage {

        public static func == (lhs: Present.DirectGroupRequest, rhs: Present.DirectGroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.recipients == rhs.recipients)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Recipient user IDs.
        public fileprivate(set) var recipients:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !recipients.isEmpty {
                for oneValuerecipients in recipients {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuerecipients)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeRecipients:Int32 = 0
            for oneValuerecipients in recipients {
                dataSizeRecipients += oneValuerecipients.computeStringSizeNoTag()
            }
            serialize_size += dataSizeRecipients
            serialize_size += 1 * Int32(recipients.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.DirectGroupRequest.Builder {
            return Present.DirectGroupRequest.classBuilder() as! Present.DirectGroupRequest.Builder
        }
        public func getBuilder() -> Present.DirectGroupRequest.Builder {
            return classBuilder() as! Present.DirectGroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.DirectGroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.DirectGroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.DirectGroupRequest.Builder {
            return try Present.DirectGroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.DirectGroupRequest) throws -> Present.DirectGroupRequest.Builder {
            return try Present.DirectGroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !recipients.isEmpty {
                var jsonArrayRecipients:Array<String> = []
                for oneValueRecipients in recipients {
                    jsonArrayRecipients.append(oneValueRecipients)
                }
                jsonMap["recipients"] = jsonArrayRecipients
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.DirectGroupRequest {
            return try Present.DirectGroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.DirectGroupRequest {
            return try Present.DirectGroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var recipientsElementIndex:Int = 0
            for oneValueRecipients in recipients  {
                output += "\(indent) recipients[\(recipientsElementIndex)]: \(oneValueRecipients)\n"
                recipientsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueRecipients in recipients {
                    hashCode = (hashCode &* 31) &+ oneValueRecipients.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.DirectGroupRequest"
        }
        override public func className() -> String {
            return "Present.DirectGroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.DirectGroupRequest = Present.DirectGroupRequest()
            public func getMessage() -> Present.DirectGroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Recipient user IDs.
            public var recipients:Array<String> {
                get {
                    return builderResult.recipients
                }
                set (array) {
                    builderResult.recipients = array
                }
            }
            @discardableResult
            public func setRecipients(_ value:Array<String>) -> Present.DirectGroupRequest.Builder {
                self.recipients = value
                return self
            }
            @discardableResult
            public func clearRecipients() -> Present.DirectGroupRequest.Builder {
                builderResult.recipients.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.DirectGroupRequest.Builder {
                builderResult = Present.DirectGroupRequest()
                return self
            }
            override public func clone() throws -> Present.DirectGroupRequest.Builder {
                return try Present.DirectGroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.DirectGroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.DirectGroupRequest {
                let returnMe:Present.DirectGroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.DirectGroupRequest) throws -> Present.DirectGroupRequest.Builder {
                if other == Present.DirectGroupRequest() {
                    return self
                }
                if !other.recipients.isEmpty {
                    builderResult.recipients += other.recipients
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.DirectGroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DirectGroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        recipients += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.DirectGroupRequest.Builder {
                let resultDecodedBuilder = Present.DirectGroupRequest.Builder()
                if let jsonValueRecipients = jsonMap["recipients"] as? Array<String> {
                    var jsonArrayRecipients:Array<String> = []
                    for oneValueRecipients in jsonValueRecipients {
                        jsonArrayRecipients.append(oneValueRecipients)
                    }
                    resultDecodedBuilder.recipients = jsonArrayRecipients
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.DirectGroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.DirectGroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DirectGroupsResponse : GeneratedMessage {

        public static func == (lhs: Present.DirectGroupsResponse, rhs: Present.DirectGroupsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.groups == rhs.groups)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groups:Array<Present.GroupResponse>  = Array<Present.GroupResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitGroups:Bool = true
            for oneElementGroups in groups {
                if !oneElementGroups.isInitialized() {
                    isInitGroups = false
                    break 
                }
            }
            if !isInitGroups {
                return isInitGroups
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementGroups in groups {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementGroups)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementGroups in groups {
                serialize_size += oneElementGroups.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.DirectGroupsResponse.Builder {
            return Present.DirectGroupsResponse.classBuilder() as! Present.DirectGroupsResponse.Builder
        }
        public func getBuilder() -> Present.DirectGroupsResponse.Builder {
            return classBuilder() as! Present.DirectGroupsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.DirectGroupsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.DirectGroupsResponse.Builder()
        }
        public func toBuilder() throws -> Present.DirectGroupsResponse.Builder {
            return try Present.DirectGroupsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.DirectGroupsResponse) throws -> Present.DirectGroupsResponse.Builder {
            return try Present.DirectGroupsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !groups.isEmpty {
                var jsonArrayGroups:Array<Dictionary<String,Any>> = []
                for oneValueGroups in groups {
                    let ecodedMessageGroups = try oneValueGroups.encode()
                    jsonArrayGroups.append(ecodedMessageGroups)
                }
                jsonMap["groups"] = jsonArrayGroups
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.DirectGroupsResponse {
            return try Present.DirectGroupsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.DirectGroupsResponse {
            return try Present.DirectGroupsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var groupsElementIndex:Int = 0
            for oneElementGroups in groups {
                output += "\(indent) groups[\(groupsElementIndex)] {\n"
                output += try oneElementGroups.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                groupsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementGroups in groups {
                    hashCode = (hashCode &* 31) &+ oneElementGroups.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.DirectGroupsResponse"
        }
        override public func className() -> String {
            return "Present.DirectGroupsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.DirectGroupsResponse = Present.DirectGroupsResponse()
            public func getMessage() -> Present.DirectGroupsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groups:Array<Present.GroupResponse> {
                get {
                    return builderResult.groups
                }
                set (value) {
                    builderResult.groups = value
                }
            }
            @discardableResult
            public func setGroups(_ value:Array<Present.GroupResponse>) -> Present.DirectGroupsResponse.Builder {
                self.groups = value
                return self
            }
            @discardableResult
            public func clearGroups() -> Present.DirectGroupsResponse.Builder {
                builderResult.groups.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.DirectGroupsResponse.Builder {
                builderResult = Present.DirectGroupsResponse()
                return self
            }
            override public func clone() throws -> Present.DirectGroupsResponse.Builder {
                return try Present.DirectGroupsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.DirectGroupsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.DirectGroupsResponse {
                let returnMe:Present.DirectGroupsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.DirectGroupsResponse) throws -> Present.DirectGroupsResponse.Builder {
                if other == Present.DirectGroupsResponse() {
                    return self
                }
                if !other.groups.isEmpty  {
                     builderResult.groups += other.groups
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.DirectGroupsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DirectGroupsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.GroupResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        groups.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.DirectGroupsResponse.Builder {
                let resultDecodedBuilder = Present.DirectGroupsResponse.Builder()
                if let jsonValueGroups = jsonMap["groups"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayGroups:Array<Present.GroupResponse> = []
                    for oneValueGroups in jsonValueGroups {
                        let messageFromStringGroups = try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:oneValueGroups).build()

                        jsonArrayGroups.append(messageFromStringGroups)
                    }
                    resultDecodedBuilder.groups = jsonArrayGroups
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.DirectGroupsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.DirectGroupsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class JoinedGroupsRequest : GeneratedMessage {

        public static func == (lhs: Present.JoinedGroupsRequest, rhs: Present.JoinedGroupsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// userId has ID number 2 to avoid conflict with old clients who still pass a location.
        public fileprivate(set) var userId:String = ""
        public fileprivate(set) var hasUserId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeString(fieldNumber: 2, value:userId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.JoinedGroupsRequest.Builder {
            return Present.JoinedGroupsRequest.classBuilder() as! Present.JoinedGroupsRequest.Builder
        }
        public func getBuilder() -> Present.JoinedGroupsRequest.Builder {
            return classBuilder() as! Present.JoinedGroupsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.JoinedGroupsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.JoinedGroupsRequest.Builder()
        }
        public func toBuilder() throws -> Present.JoinedGroupsRequest.Builder {
            return try Present.JoinedGroupsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.JoinedGroupsRequest) throws -> Present.JoinedGroupsRequest.Builder {
            return try Present.JoinedGroupsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = userId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.JoinedGroupsRequest {
            return try Present.JoinedGroupsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.JoinedGroupsRequest {
            return try Present.JoinedGroupsRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.JoinedGroupsRequest"
        }
        override public func className() -> String {
            return "Present.JoinedGroupsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.JoinedGroupsRequest = Present.JoinedGroupsRequest()
            public func getMessage() -> Present.JoinedGroupsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// userId has ID number 2 to avoid conflict with old clients who still pass a location.
            public var userId:String {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:String) -> Present.JoinedGroupsRequest.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Present.JoinedGroupsRequest.Builder{
                builderResult.hasUserId = false
                builderResult.userId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.JoinedGroupsRequest.Builder {
                builderResult = Present.JoinedGroupsRequest()
                return self
            }
            override public func clone() throws -> Present.JoinedGroupsRequest.Builder {
                return try Present.JoinedGroupsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.JoinedGroupsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.JoinedGroupsRequest {
                let returnMe:Present.JoinedGroupsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.JoinedGroupsRequest) throws -> Present.JoinedGroupsRequest.Builder {
                if other == Present.JoinedGroupsRequest() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.JoinedGroupsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinedGroupsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        userId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.JoinedGroupsRequest.Builder {
                let resultDecodedBuilder = Present.JoinedGroupsRequest.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = jsonValueUserId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.JoinedGroupsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.JoinedGroupsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class JoinedGroupsResponse : GeneratedMessage {

        public static func == (lhs: Present.JoinedGroupsResponse, rhs: Present.JoinedGroupsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.groups == rhs.groups)
            fieldCheck = fieldCheck && (lhs.hasMutedGroups == rhs.hasMutedGroups) && (!lhs.hasMutedGroups || lhs.mutedGroups == rhs.mutedGroups)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groups:Array<Present.GroupResponse>  = Array<Present.GroupResponse>()
        public fileprivate(set) var mutedGroups:Present.MutedGroupsResponse!
        public fileprivate(set) var hasMutedGroups:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitGroups:Bool = true
            for oneElementGroups in groups {
                if !oneElementGroups.isInitialized() {
                    isInitGroups = false
                    break 
                }
            }
            if !isInitGroups {
                return isInitGroups
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementGroups in groups {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementGroups)
            }
            if hasMutedGroups {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:mutedGroups)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementGroups in groups {
                serialize_size += oneElementGroups.computeMessageSize(fieldNumber: 1)
            }
            if hasMutedGroups {
                if let varSizemutedGroups = mutedGroups?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizemutedGroups
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.JoinedGroupsResponse.Builder {
            return Present.JoinedGroupsResponse.classBuilder() as! Present.JoinedGroupsResponse.Builder
        }
        public func getBuilder() -> Present.JoinedGroupsResponse.Builder {
            return classBuilder() as! Present.JoinedGroupsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.JoinedGroupsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.JoinedGroupsResponse.Builder()
        }
        public func toBuilder() throws -> Present.JoinedGroupsResponse.Builder {
            return try Present.JoinedGroupsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.JoinedGroupsResponse) throws -> Present.JoinedGroupsResponse.Builder {
            return try Present.JoinedGroupsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !groups.isEmpty {
                var jsonArrayGroups:Array<Dictionary<String,Any>> = []
                for oneValueGroups in groups {
                    let ecodedMessageGroups = try oneValueGroups.encode()
                    jsonArrayGroups.append(ecodedMessageGroups)
                }
                jsonMap["groups"] = jsonArrayGroups
            }
            if hasMutedGroups {
                jsonMap["mutedGroups"] = try mutedGroups.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.JoinedGroupsResponse {
            return try Present.JoinedGroupsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.JoinedGroupsResponse {
            return try Present.JoinedGroupsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var groupsElementIndex:Int = 0
            for oneElementGroups in groups {
                output += "\(indent) groups[\(groupsElementIndex)] {\n"
                output += try oneElementGroups.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                groupsElementIndex += 1
            }
            if hasMutedGroups {
                output += "\(indent) mutedGroups {\n"
                if let outDescMutedGroups = mutedGroups {
                    output += try outDescMutedGroups.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementGroups in groups {
                    hashCode = (hashCode &* 31) &+ oneElementGroups.hashValue
                }
                if hasMutedGroups {
                    if let hashValuemutedGroups = mutedGroups?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemutedGroups
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.JoinedGroupsResponse"
        }
        override public func className() -> String {
            return "Present.JoinedGroupsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.JoinedGroupsResponse = Present.JoinedGroupsResponse()
            public func getMessage() -> Present.JoinedGroupsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groups:Array<Present.GroupResponse> {
                get {
                    return builderResult.groups
                }
                set (value) {
                    builderResult.groups = value
                }
            }
            @discardableResult
            public func setGroups(_ value:Array<Present.GroupResponse>) -> Present.JoinedGroupsResponse.Builder {
                self.groups = value
                return self
            }
            @discardableResult
            public func clearGroups() -> Present.JoinedGroupsResponse.Builder {
                builderResult.groups.removeAll(keepingCapacity: false)
                return self
            }
            /// Deprecated. Use GroupResponse.muted instead.
            public var mutedGroups:Present.MutedGroupsResponse! {
                get {
                    if mutedGroupsBuilder_ != nil {
                        builderResult.mutedGroups = mutedGroupsBuilder_.getMessage()
                    }
                    return builderResult.mutedGroups
                }
                set (value) {
                    builderResult.hasMutedGroups = true
                    builderResult.mutedGroups = value
                }
            }
            public var hasMutedGroups:Bool {
                get {
                    return builderResult.hasMutedGroups
                }
            }
            fileprivate var mutedGroupsBuilder_:Present.MutedGroupsResponse.Builder! {
                didSet {
                    builderResult.hasMutedGroups = true
                }
            }
            public func getMutedGroupsBuilder() -> Present.MutedGroupsResponse.Builder {
                if mutedGroupsBuilder_ == nil {
                    mutedGroupsBuilder_ = Present.MutedGroupsResponse.Builder()
                    builderResult.mutedGroups = mutedGroupsBuilder_.getMessage()
                    if mutedGroups != nil {
                        try! mutedGroupsBuilder_.mergeFrom(other: mutedGroups)
                    }
                }
                return mutedGroupsBuilder_
            }
            @discardableResult
            public func setMutedGroups(_ value:Present.MutedGroupsResponse!) -> Present.JoinedGroupsResponse.Builder {
                self.mutedGroups = value
                return self
            }
            @discardableResult
            public func mergeMutedGroups(value:Present.MutedGroupsResponse) throws -> Present.JoinedGroupsResponse.Builder {
                if builderResult.hasMutedGroups {
                    builderResult.mutedGroups = try Present.MutedGroupsResponse.builderWithPrototype(prototype:builderResult.mutedGroups).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.mutedGroups = value
                }
                builderResult.hasMutedGroups = true
                return self
            }
            @discardableResult
            public func clearMutedGroups() -> Present.JoinedGroupsResponse.Builder {
                mutedGroupsBuilder_ = nil
                builderResult.hasMutedGroups = false
                builderResult.mutedGroups = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.JoinedGroupsResponse.Builder {
                builderResult = Present.JoinedGroupsResponse()
                return self
            }
            override public func clone() throws -> Present.JoinedGroupsResponse.Builder {
                return try Present.JoinedGroupsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.JoinedGroupsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.JoinedGroupsResponse {
                let returnMe:Present.JoinedGroupsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.JoinedGroupsResponse) throws -> Present.JoinedGroupsResponse.Builder {
                if other == Present.JoinedGroupsResponse() {
                    return self
                }
                if !other.groups.isEmpty  {
                     builderResult.groups += other.groups
                }
                if (other.hasMutedGroups) {
                    try mergeMutedGroups(value: other.mutedGroups)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.JoinedGroupsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinedGroupsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.GroupResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        groups.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder:Present.MutedGroupsResponse.Builder = Present.MutedGroupsResponse.Builder()
                        if hasMutedGroups {
                            try subBuilder.mergeFrom(other: mutedGroups)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        mutedGroups = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.JoinedGroupsResponse.Builder {
                let resultDecodedBuilder = Present.JoinedGroupsResponse.Builder()
                if let jsonValueGroups = jsonMap["groups"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayGroups:Array<Present.GroupResponse> = []
                    for oneValueGroups in jsonValueGroups {
                        let messageFromStringGroups = try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:oneValueGroups).build()

                        jsonArrayGroups.append(messageFromStringGroups)
                    }
                    resultDecodedBuilder.groups = jsonArrayGroups
                }
                if let jsonValueMutedGroups = jsonMap["mutedGroups"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.mutedGroups = try Present.MutedGroupsResponse.Builder.decodeToBuilder(jsonMap:jsonValueMutedGroups).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.JoinedGroupsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.JoinedGroupsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SuggestedLocation : GeneratedMessage {

        public static func == (lhs: Present.SuggestedLocation, rhs: Present.SuggestedLocation) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLocation == rhs.hasLocation) && (!lhs.hasLocation || lhs.location == rhs.location)
            fieldCheck = fieldCheck && (lhs.hasRadius == rhs.hasRadius) && (!lhs.hasRadius || lhs.radius == rhs.radius)
            fieldCheck = fieldCheck && (lhs.hasSource == rhs.hasSource) && (!lhs.hasSource || lhs.source == rhs.source)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum Source:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case appleGeocoder = 1
                case appleLocalSearch = 2
                case googleCurrentPlace = 3
                public func toString() -> String {
                    switch self {
                    case .appleGeocoder: return "APPLE_GEOCODER"
                    case .appleLocalSearch: return "APPLE_LOCAL_SEARCH"
                    case .googleCurrentPlace: return "GOOGLE_CURRENT_PLACE"
                    }
                }
                public static func fromString(str:String) throws -> Present.SuggestedLocation.Source {
                    switch str {
                    case "APPLE_GEOCODER":    return .appleGeocoder
                    case "APPLE_LOCAL_SEARCH":    return .appleLocalSearch
                    case "GOOGLE_CURRENT_PLACE":    return .googleCurrentPlace
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .appleGeocoder: return ".appleGeocoder"
                    case .appleLocalSearch: return ".appleLocalSearch"
                    case .googleCurrentPlace: return ".googleCurrentPlace"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:Source, rhs:Source) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var location:Present.Coordinates!
        public fileprivate(set) var hasLocation:Bool = false
        /// Radius of the location.
        public fileprivate(set) var radius:Double = Double(0)
        public fileprivate(set) var hasRadius:Bool = false

        public fileprivate(set) var source:Present.SuggestedLocation.Source = Present.SuggestedLocation.Source.appleGeocoder
        public fileprivate(set) var hasSource:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasLocation {
                return false
            }
            if !hasSource {
                return false
            }
            if !location.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLocation {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:location)
            }
            if hasRadius {
                try codedOutputStream.writeDouble(fieldNumber: 2, value:radius)
            }
            if hasSource {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:source.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLocation {
                if let varSizelocation = location?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizelocation
                }
            }
            if hasRadius {
                serialize_size += radius.computeDoubleSize(fieldNumber: 2)
            }
            if (hasSource) {
                serialize_size += source.rawValue.computeEnumSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.SuggestedLocation.Builder {
            return Present.SuggestedLocation.classBuilder() as! Present.SuggestedLocation.Builder
        }
        public func getBuilder() -> Present.SuggestedLocation.Builder {
            return classBuilder() as! Present.SuggestedLocation.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SuggestedLocation.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.SuggestedLocation.Builder()
        }
        public func toBuilder() throws -> Present.SuggestedLocation.Builder {
            return try Present.SuggestedLocation.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.SuggestedLocation) throws -> Present.SuggestedLocation.Builder {
            return try Present.SuggestedLocation.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLocation {
                jsonMap["location"] = try location.encode()
            }
            if hasRadius {
                jsonMap["radius"] = Double(radius)
            }
            if hasSource {
                jsonMap["source"] = source.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.SuggestedLocation {
            return try Present.SuggestedLocation.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.SuggestedLocation {
            return try Present.SuggestedLocation.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLocation {
                output += "\(indent) location {\n"
                if let outDescLocation = location {
                    output += try outDescLocation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasRadius {
                output += "\(indent) radius: \(radius) \n"
            }
            if (hasSource) {
                output += "\(indent) source: \(source.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLocation {
                    if let hashValuelocation = location?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelocation
                    }
                }
                if hasRadius {
                    hashCode = (hashCode &* 31) &+ radius.hashValue
                }
                if hasSource {
                     hashCode = (hashCode &* 31) &+ source.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.SuggestedLocation"
        }
        override public func className() -> String {
            return "Present.SuggestedLocation"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.SuggestedLocation = Present.SuggestedLocation()
            public func getMessage() -> Present.SuggestedLocation {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Center of the location.
            public var location:Present.Coordinates! {
                get {
                    if locationBuilder_ != nil {
                        builderResult.location = locationBuilder_.getMessage()
                    }
                    return builderResult.location
                }
                set (value) {
                    builderResult.hasLocation = true
                    builderResult.location = value
                }
            }
            public var hasLocation:Bool {
                get {
                    return builderResult.hasLocation
                }
            }
            fileprivate var locationBuilder_:Present.Coordinates.Builder! {
                didSet {
                    builderResult.hasLocation = true
                }
            }
            public func getLocationBuilder() -> Present.Coordinates.Builder {
                if locationBuilder_ == nil {
                    locationBuilder_ = Present.Coordinates.Builder()
                    builderResult.location = locationBuilder_.getMessage()
                    if location != nil {
                        try! locationBuilder_.mergeFrom(other: location)
                    }
                }
                return locationBuilder_
            }
            @discardableResult
            public func setLocation(_ value:Present.Coordinates!) -> Present.SuggestedLocation.Builder {
                self.location = value
                return self
            }
            @discardableResult
            public func mergeLocation(value:Present.Coordinates) throws -> Present.SuggestedLocation.Builder {
                if builderResult.hasLocation {
                    builderResult.location = try Present.Coordinates.builderWithPrototype(prototype:builderResult.location).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.location = value
                }
                builderResult.hasLocation = true
                return self
            }
            @discardableResult
            public func clearLocation() -> Present.SuggestedLocation.Builder {
                locationBuilder_ = nil
                builderResult.hasLocation = false
                builderResult.location = nil
                return self
            }
            /// Radius of the location.
            public var radius:Double {
                get {
                    return builderResult.radius
                }
                set (value) {
                    builderResult.hasRadius = true
                    builderResult.radius = value
                }
            }
            public var hasRadius:Bool {
                get {
                    return builderResult.hasRadius
                }
            }
            @discardableResult
            public func setRadius(_ value:Double) -> Present.SuggestedLocation.Builder {
                self.radius = value
                return self
            }
            @discardableResult
            public func clearRadius() -> Present.SuggestedLocation.Builder{
                builderResult.hasRadius = false
                builderResult.radius = Double(0)
                return self
            }
            /// How we found the location.
                public var source:Present.SuggestedLocation.Source {
                    get {
                        return builderResult.source
                    }
                    set (value) {
                        builderResult.hasSource = true
                        builderResult.source = value
                    }
                }
                public var hasSource:Bool{
                    get {
                        return builderResult.hasSource
                    }
                }
            @discardableResult
                public func setSource(_ value:Present.SuggestedLocation.Source) -> Present.SuggestedLocation.Builder {
                  self.source = value
                  return self
                }
            @discardableResult
                public func clearSource() -> Present.SuggestedLocation.Builder {
                   builderResult.hasSource = false
                   builderResult.source = .appleGeocoder
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.SuggestedLocation.Builder {
                builderResult = Present.SuggestedLocation()
                return self
            }
            override public func clone() throws -> Present.SuggestedLocation.Builder {
                return try Present.SuggestedLocation.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.SuggestedLocation {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.SuggestedLocation {
                let returnMe:Present.SuggestedLocation = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.SuggestedLocation) throws -> Present.SuggestedLocation.Builder {
                if other == Present.SuggestedLocation() {
                    return self
                }
                if (other.hasLocation) {
                    try mergeLocation(value: other.location)
                }
                if other.hasRadius {
                    radius = other.radius
                }
                if other.hasSource {
                    source = other.source
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.SuggestedLocation.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SuggestedLocation.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.Coordinates.Builder = Present.Coordinates.Builder()
                        if hasLocation {
                            try subBuilder.mergeFrom(other: location)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        location = subBuilder.buildPartial()

                    case 17:
                        radius = try codedInputStream.readDouble()

                    case 24:
                        let valueIntsource = try codedInputStream.readEnum()
                        if let enumssource = Present.SuggestedLocation.Source(rawValue:valueIntsource){
                            source = enumssource
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntsource))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.SuggestedLocation.Builder {
                let resultDecodedBuilder = Present.SuggestedLocation.Builder()
                if let jsonValueLocation = jsonMap["location"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.location = try Present.Coordinates.Builder.decodeToBuilder(jsonMap:jsonValueLocation).build()

                }
                if let jsonValueRadius = jsonMap["radius"] as? Double {
                    resultDecodedBuilder.radius = Double(jsonValueRadius)
                } else if let jsonValueRadius = jsonMap["radius"] as? String {
                    resultDecodedBuilder.radius = Double(jsonValueRadius)!
                }
                if let jsonValueSource = jsonMap["source"] as? String {
                    resultDecodedBuilder.source = try Present.SuggestedLocation.Source.fromString(str: jsonValueSource)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.SuggestedLocation.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.SuggestedLocation.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Schedule : GeneratedMessage {

        public static func == (lhs: Present.Schedule, rhs: Present.Schedule) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
            fieldCheck = fieldCheck && (lhs.hasEndTime == rhs.hasEndTime) && (!lhs.hasEndTime || lhs.endTime == rhs.endTime)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// UTC timestamp of event start
        public fileprivate(set) var startTime:UInt64 = UInt64(0)
        public fileprivate(set) var hasStartTime:Bool = false

        /// Optional end time of the event.
        public fileprivate(set) var endTime:UInt64 = UInt64(0)
        public fileprivate(set) var hasEndTime:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasStartTime {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStartTime {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:startTime)
            }
            if hasEndTime {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:endTime)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStartTime {
                serialize_size += startTime.computeUInt64Size(fieldNumber: 1)
            }
            if hasEndTime {
                serialize_size += endTime.computeUInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.Schedule.Builder {
            return Present.Schedule.classBuilder() as! Present.Schedule.Builder
        }
        public func getBuilder() -> Present.Schedule.Builder {
            return classBuilder() as! Present.Schedule.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Schedule.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.Schedule.Builder()
        }
        public func toBuilder() throws -> Present.Schedule.Builder {
            return try Present.Schedule.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.Schedule) throws -> Present.Schedule.Builder {
            return try Present.Schedule.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStartTime {
                jsonMap["startTime"] = "\(startTime)"
            }
            if hasEndTime {
                jsonMap["endTime"] = "\(endTime)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.Schedule {
            return try Present.Schedule.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.Schedule {
            return try Present.Schedule.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStartTime {
                output += "\(indent) startTime: \(startTime) \n"
            }
            if hasEndTime {
                output += "\(indent) endTime: \(endTime) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStartTime {
                    hashCode = (hashCode &* 31) &+ startTime.hashValue
                }
                if hasEndTime {
                    hashCode = (hashCode &* 31) &+ endTime.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.Schedule"
        }
        override public func className() -> String {
            return "Present.Schedule"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.Schedule = Present.Schedule()
            public func getMessage() -> Present.Schedule {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// UTC timestamp of event start
            public var startTime:UInt64 {
                get {
                    return builderResult.startTime
                }
                set (value) {
                    builderResult.hasStartTime = true
                    builderResult.startTime = value
                }
            }
            public var hasStartTime:Bool {
                get {
                    return builderResult.hasStartTime
                }
            }
            @discardableResult
            public func setStartTime(_ value:UInt64) -> Present.Schedule.Builder {
                self.startTime = value
                return self
            }
            @discardableResult
            public func clearStartTime() -> Present.Schedule.Builder{
                builderResult.hasStartTime = false
                builderResult.startTime = UInt64(0)
                return self
            }
            /// Optional end time of the event.
            public var endTime:UInt64 {
                get {
                    return builderResult.endTime
                }
                set (value) {
                    builderResult.hasEndTime = true
                    builderResult.endTime = value
                }
            }
            public var hasEndTime:Bool {
                get {
                    return builderResult.hasEndTime
                }
            }
            @discardableResult
            public func setEndTime(_ value:UInt64) -> Present.Schedule.Builder {
                self.endTime = value
                return self
            }
            @discardableResult
            public func clearEndTime() -> Present.Schedule.Builder{
                builderResult.hasEndTime = false
                builderResult.endTime = UInt64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.Schedule.Builder {
                builderResult = Present.Schedule()
                return self
            }
            override public func clone() throws -> Present.Schedule.Builder {
                return try Present.Schedule.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.Schedule {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.Schedule {
                let returnMe:Present.Schedule = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.Schedule) throws -> Present.Schedule.Builder {
                if other == Present.Schedule() {
                    return self
                }
                if other.hasStartTime {
                    startTime = other.startTime
                }
                if other.hasEndTime {
                    endTime = other.endTime
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.Schedule.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Schedule.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        startTime = try codedInputStream.readUInt64()

                    case 16:
                        endTime = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.Schedule.Builder {
                let resultDecodedBuilder = Present.Schedule.Builder()
                if let jsonValueStartTime = jsonMap["startTime"] as? String {
                    resultDecodedBuilder.startTime = UInt64(jsonValueStartTime)!
                } else if let jsonValueStartTime = jsonMap["startTime"] as? UInt {
                    resultDecodedBuilder.startTime = UInt64(jsonValueStartTime)
                }
                if let jsonValueEndTime = jsonMap["endTime"] as? String {
                    resultDecodedBuilder.endTime = UInt64(jsonValueEndTime)!
                } else if let jsonValueEndTime = jsonMap["endTime"] as? UInt {
                    resultDecodedBuilder.endTime = UInt64(jsonValueEndTime)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.Schedule.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.Schedule.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PutGroupRequest : GeneratedMessage {

        public static func == (lhs: Present.PutGroupRequest, rhs: Present.PutGroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUuid == rhs.hasUuid) && (!lhs.hasUuid || lhs.uuid == rhs.uuid)
            fieldCheck = fieldCheck && (lhs.hasLocation == rhs.hasLocation) && (!lhs.hasLocation || lhs.location == rhs.location)
            fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
            fieldCheck = fieldCheck && (lhs.hasCreatedFrom == rhs.hasCreatedFrom) && (!lhs.hasCreatedFrom || lhs.createdFrom == rhs.createdFrom)
            fieldCheck = fieldCheck && (lhs.hasLocationName == rhs.hasLocationName) && (!lhs.hasLocationName || lhs.locationName == rhs.locationName)
            fieldCheck = fieldCheck && (lhs.hasSuggestedLocation == rhs.hasSuggestedLocation) && (!lhs.hasSuggestedLocation || lhs.suggestedLocation == rhs.suggestedLocation)
            fieldCheck = fieldCheck && (lhs.hasCover == rhs.hasCover) && (!lhs.hasCover || lhs.cover == rhs.cover)
            fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
            fieldCheck = fieldCheck && (lhs.categories == rhs.categories)
            fieldCheck = fieldCheck && (lhs.hasSchedule == rhs.hasSchedule) && (!lhs.hasSchedule || lhs.schedule == rhs.schedule)
            fieldCheck = fieldCheck && (lhs.hasSpaceId == rhs.hasSpaceId) && (!lhs.hasSpaceId || lhs.spaceId == rhs.spaceId)
            fieldCheck = fieldCheck && (lhs.hasPreapprove == rhs.hasPreapprove) && (!lhs.hasPreapprove || lhs.preapprove == rhs.preapprove)
            fieldCheck = fieldCheck && (lhs.hasDiscoverable == rhs.hasDiscoverable) && (!lhs.hasDiscoverable || lhs.discoverable == rhs.discoverable)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The client-supplied uuid to be associated with the circle.
        public fileprivate(set) var uuid:String = ""
        public fileprivate(set) var hasUuid:Bool = false

        /// Space to put this group in. Can be null coming from old clients.
        public fileprivate(set) var spaceId:String = ""
        public fileprivate(set) var hasSpaceId:Bool = false

        public fileprivate(set) var location:Present.Coordinates!
        public fileprivate(set) var hasLocation:Bool = false
        public fileprivate(set) var locationName:String = ""
        public fileprivate(set) var hasLocationName:Bool = false

        /// The circle's title.
        public fileprivate(set) var title:String = ""
        public fileprivate(set) var hasTitle:Bool = false

        public fileprivate(set) var createdFrom:Present.Coordinates!
        public fileprivate(set) var hasCreatedFrom:Bool = false
        public fileprivate(set) var suggestedLocation:Present.SuggestedLocation!
        public fileprivate(set) var hasSuggestedLocation:Bool = false
        public fileprivate(set) var cover:Present.ContentReferenceRequest!
        public fileprivate(set) var hasCover:Bool = false
        /// Description of the circle.
        public fileprivate(set) var description_:String = ""
        public fileprivate(set) var hasDescription:Bool = false

        /// Optional categories that can be used in search.
        public fileprivate(set) var categories:Array<String> = Array<String>()
        public fileprivate(set) var schedule:Present.Schedule!
        public fileprivate(set) var hasSchedule:Bool = false
        public fileprivate(set) var preapprove:Present.GroupMemberPreapproval = Present.GroupMemberPreapproval.unknownGroupMemberPreapproval
        public fileprivate(set) var hasPreapprove:Bool = false
        /// Whether or not the circle is discoverable by friends and people nearby.
        public fileprivate(set) var discoverable:Bool = false
        public fileprivate(set) var hasDiscoverable:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUuid {
                return false
            }
            if !hasLocation {
                return false
            }
            if !hasLocationName {
                return false
            }
            if !hasTitle {
                return false
            }
            if !hasCreatedFrom {
                return false
            }
            if !location.isInitialized() {
                return false
            }
            if !createdFrom.isInitialized() {
                return false
            }
            if hasSuggestedLocation {
                if !suggestedLocation.isInitialized() {
                    return false
                }
            }
            if hasCover {
                if !cover.isInitialized() {
                    return false
                }
            }
            if hasSchedule {
                if !schedule.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUuid {
                try codedOutputStream.writeString(fieldNumber: 1, value:uuid)
            }
            if hasLocation {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:location)
            }
            if hasTitle {
                try codedOutputStream.writeString(fieldNumber: 4, value:title)
            }
            if hasCreatedFrom {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:createdFrom)
            }
            if hasLocationName {
                try codedOutputStream.writeString(fieldNumber: 6, value:locationName)
            }
            if hasSuggestedLocation {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:suggestedLocation)
            }
            if hasCover {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:cover)
            }
            if hasDescription {
                try codedOutputStream.writeString(fieldNumber: 9, value:description_)
            }
            if !categories.isEmpty {
                for oneValuecategories in categories {
                    try codedOutputStream.writeString(fieldNumber: 10, value:oneValuecategories)
                }
            }
            if hasSchedule {
                try codedOutputStream.writeMessage(fieldNumber: 11, value:schedule)
            }
            if hasSpaceId {
                try codedOutputStream.writeString(fieldNumber: 12, value:spaceId)
            }
            if hasPreapprove {
                try codedOutputStream.writeEnum(fieldNumber: 13, value:preapprove.rawValue)
            }
            if hasDiscoverable {
                try codedOutputStream.writeBool(fieldNumber: 14, value:discoverable)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUuid {
                serialize_size += uuid.computeStringSize(fieldNumber: 1)
            }
            if hasLocation {
                if let varSizelocation = location?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizelocation
                }
            }
            if hasTitle {
                serialize_size += title.computeStringSize(fieldNumber: 4)
            }
            if hasCreatedFrom {
                if let varSizecreatedFrom = createdFrom?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizecreatedFrom
                }
            }
            if hasLocationName {
                serialize_size += locationName.computeStringSize(fieldNumber: 6)
            }
            if hasSuggestedLocation {
                if let varSizesuggestedLocation = suggestedLocation?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizesuggestedLocation
                }
            }
            if hasCover {
                if let varSizecover = cover?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizecover
                }
            }
            if hasDescription {
                serialize_size += description_.computeStringSize(fieldNumber: 9)
            }
            var dataSizeCategories:Int32 = 0
            for oneValuecategories in categories {
                dataSizeCategories += oneValuecategories.computeStringSizeNoTag()
            }
            serialize_size += dataSizeCategories
            serialize_size += 1 * Int32(categories.count)
            if hasSchedule {
                if let varSizeschedule = schedule?.computeMessageSize(fieldNumber: 11) {
                    serialize_size += varSizeschedule
                }
            }
            if hasSpaceId {
                serialize_size += spaceId.computeStringSize(fieldNumber: 12)
            }
            if (hasPreapprove) {
                serialize_size += preapprove.rawValue.computeEnumSize(fieldNumber: 13)
            }
            if hasDiscoverable {
                serialize_size += discoverable.computeBoolSize(fieldNumber: 14)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PutGroupRequest.Builder {
            return Present.PutGroupRequest.classBuilder() as! Present.PutGroupRequest.Builder
        }
        public func getBuilder() -> Present.PutGroupRequest.Builder {
            return classBuilder() as! Present.PutGroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutGroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutGroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.PutGroupRequest.Builder {
            return try Present.PutGroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PutGroupRequest) throws -> Present.PutGroupRequest.Builder {
            return try Present.PutGroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUuid {
                jsonMap["uuid"] = uuid
            }
            if hasSpaceId {
                jsonMap["spaceId"] = spaceId
            }
            if hasLocation {
                jsonMap["location"] = try location.encode()
            }
            if hasLocationName {
                jsonMap["locationName"] = locationName
            }
            if hasTitle {
                jsonMap["title"] = title
            }
            if hasCreatedFrom {
                jsonMap["createdFrom"] = try createdFrom.encode()
            }
            if hasSuggestedLocation {
                jsonMap["suggestedLocation"] = try suggestedLocation.encode()
            }
            if hasCover {
                jsonMap["cover"] = try cover.encode()
            }
            if hasDescription {
                jsonMap["description"] = description_
            }
            if !categories.isEmpty {
                var jsonArrayCategories:Array<String> = []
                for oneValueCategories in categories {
                    jsonArrayCategories.append(oneValueCategories)
                }
                jsonMap["categories"] = jsonArrayCategories
            }
            if hasSchedule {
                jsonMap["schedule"] = try schedule.encode()
            }
            if hasPreapprove {
                jsonMap["preapprove"] = preapprove.toString()
            }
            if hasDiscoverable {
                jsonMap["discoverable"] = discoverable
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PutGroupRequest {
            return try Present.PutGroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PutGroupRequest {
            return try Present.PutGroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUuid {
                output += "\(indent) uuid: \(uuid) \n"
            }
            if hasLocation {
                output += "\(indent) location {\n"
                if let outDescLocation = location {
                    output += try outDescLocation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTitle {
                output += "\(indent) title: \(title) \n"
            }
            if hasCreatedFrom {
                output += "\(indent) createdFrom {\n"
                if let outDescCreatedFrom = createdFrom {
                    output += try outDescCreatedFrom.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasLocationName {
                output += "\(indent) locationName: \(locationName) \n"
            }
            if hasSuggestedLocation {
                output += "\(indent) suggestedLocation {\n"
                if let outDescSuggestedLocation = suggestedLocation {
                    output += try outDescSuggestedLocation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCover {
                output += "\(indent) cover {\n"
                if let outDescCover = cover {
                    output += try outDescCover.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDescription {
                output += "\(indent) description: \(description_) \n"
            }
            var categoriesElementIndex:Int = 0
            for oneValueCategories in categories  {
                output += "\(indent) categories[\(categoriesElementIndex)]: \(oneValueCategories)\n"
                categoriesElementIndex += 1
            }
            if hasSchedule {
                output += "\(indent) schedule {\n"
                if let outDescSchedule = schedule {
                    output += try outDescSchedule.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasSpaceId {
                output += "\(indent) spaceId: \(spaceId) \n"
            }
            if (hasPreapprove) {
                output += "\(indent) preapprove: \(preapprove.description)\n"
            }
            if hasDiscoverable {
                output += "\(indent) discoverable: \(discoverable) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUuid {
                    hashCode = (hashCode &* 31) &+ uuid.hashValue
                }
                if hasLocation {
                    if let hashValuelocation = location?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelocation
                    }
                }
                if hasTitle {
                    hashCode = (hashCode &* 31) &+ title.hashValue
                }
                if hasCreatedFrom {
                    if let hashValuecreatedFrom = createdFrom?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecreatedFrom
                    }
                }
                if hasLocationName {
                    hashCode = (hashCode &* 31) &+ locationName.hashValue
                }
                if hasSuggestedLocation {
                    if let hashValuesuggestedLocation = suggestedLocation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuesuggestedLocation
                    }
                }
                if hasCover {
                    if let hashValuecover = cover?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecover
                    }
                }
                if hasDescription {
                    hashCode = (hashCode &* 31) &+ description_.hashValue
                }
                for oneValueCategories in categories {
                    hashCode = (hashCode &* 31) &+ oneValueCategories.hashValue
                }
                if hasSchedule {
                    if let hashValueschedule = schedule?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueschedule
                    }
                }
                if hasSpaceId {
                    hashCode = (hashCode &* 31) &+ spaceId.hashValue
                }
                if hasPreapprove {
                     hashCode = (hashCode &* 31) &+ preapprove.hashValue
                }
                if hasDiscoverable {
                    hashCode = (hashCode &* 31) &+ discoverable.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PutGroupRequest"
        }
        override public func className() -> String {
            return "Present.PutGroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PutGroupRequest = Present.PutGroupRequest()
            public func getMessage() -> Present.PutGroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The client-supplied uuid to be associated with the circle.
            public var uuid:String {
                get {
                    return builderResult.uuid
                }
                set (value) {
                    builderResult.hasUuid = true
                    builderResult.uuid = value
                }
            }
            public var hasUuid:Bool {
                get {
                    return builderResult.hasUuid
                }
            }
            @discardableResult
            public func setUuid(_ value:String) -> Present.PutGroupRequest.Builder {
                self.uuid = value
                return self
            }
            @discardableResult
            public func clearUuid() -> Present.PutGroupRequest.Builder{
                builderResult.hasUuid = false
                builderResult.uuid = ""
                return self
            }
            /// Space to put this group in. Can be null coming from old clients.
            public var spaceId:String {
                get {
                    return builderResult.spaceId
                }
                set (value) {
                    builderResult.hasSpaceId = true
                    builderResult.spaceId = value
                }
            }
            public var hasSpaceId:Bool {
                get {
                    return builderResult.hasSpaceId
                }
            }
            @discardableResult
            public func setSpaceId(_ value:String) -> Present.PutGroupRequest.Builder {
                self.spaceId = value
                return self
            }
            @discardableResult
            public func clearSpaceId() -> Present.PutGroupRequest.Builder{
                builderResult.hasSpaceId = false
                builderResult.spaceId = ""
                return self
            }
            /// Coordinates and name of the circle's location.
            public var location:Present.Coordinates! {
                get {
                    if locationBuilder_ != nil {
                        builderResult.location = locationBuilder_.getMessage()
                    }
                    return builderResult.location
                }
                set (value) {
                    builderResult.hasLocation = true
                    builderResult.location = value
                }
            }
            public var hasLocation:Bool {
                get {
                    return builderResult.hasLocation
                }
            }
            fileprivate var locationBuilder_:Present.Coordinates.Builder! {
                didSet {
                    builderResult.hasLocation = true
                }
            }
            public func getLocationBuilder() -> Present.Coordinates.Builder {
                if locationBuilder_ == nil {
                    locationBuilder_ = Present.Coordinates.Builder()
                    builderResult.location = locationBuilder_.getMessage()
                    if location != nil {
                        try! locationBuilder_.mergeFrom(other: location)
                    }
                }
                return locationBuilder_
            }
            @discardableResult
            public func setLocation(_ value:Present.Coordinates!) -> Present.PutGroupRequest.Builder {
                self.location = value
                return self
            }
            @discardableResult
            public func mergeLocation(value:Present.Coordinates) throws -> Present.PutGroupRequest.Builder {
                if builderResult.hasLocation {
                    builderResult.location = try Present.Coordinates.builderWithPrototype(prototype:builderResult.location).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.location = value
                }
                builderResult.hasLocation = true
                return self
            }
            @discardableResult
            public func clearLocation() -> Present.PutGroupRequest.Builder {
                locationBuilder_ = nil
                builderResult.hasLocation = false
                builderResult.location = nil
                return self
            }
            public var locationName:String {
                get {
                    return builderResult.locationName
                }
                set (value) {
                    builderResult.hasLocationName = true
                    builderResult.locationName = value
                }
            }
            public var hasLocationName:Bool {
                get {
                    return builderResult.hasLocationName
                }
            }
            @discardableResult
            public func setLocationName(_ value:String) -> Present.PutGroupRequest.Builder {
                self.locationName = value
                return self
            }
            @discardableResult
            public func clearLocationName() -> Present.PutGroupRequest.Builder{
                builderResult.hasLocationName = false
                builderResult.locationName = ""
                return self
            }
            /// The circle's title.
            public var title:String {
                get {
                    return builderResult.title
                }
                set (value) {
                    builderResult.hasTitle = true
                    builderResult.title = value
                }
            }
            public var hasTitle:Bool {
                get {
                    return builderResult.hasTitle
                }
            }
            @discardableResult
            public func setTitle(_ value:String) -> Present.PutGroupRequest.Builder {
                self.title = value
                return self
            }
            @discardableResult
            public func clearTitle() -> Present.PutGroupRequest.Builder{
                builderResult.hasTitle = false
                builderResult.title = ""
                return self
            }
            /// The user's location when they created the circle.
            public var createdFrom:Present.Coordinates! {
                get {
                    if createdFromBuilder_ != nil {
                        builderResult.createdFrom = createdFromBuilder_.getMessage()
                    }
                    return builderResult.createdFrom
                }
                set (value) {
                    builderResult.hasCreatedFrom = true
                    builderResult.createdFrom = value
                }
            }
            public var hasCreatedFrom:Bool {
                get {
                    return builderResult.hasCreatedFrom
                }
            }
            fileprivate var createdFromBuilder_:Present.Coordinates.Builder! {
                didSet {
                    builderResult.hasCreatedFrom = true
                }
            }
            public func getCreatedFromBuilder() -> Present.Coordinates.Builder {
                if createdFromBuilder_ == nil {
                    createdFromBuilder_ = Present.Coordinates.Builder()
                    builderResult.createdFrom = createdFromBuilder_.getMessage()
                    if createdFrom != nil {
                        try! createdFromBuilder_.mergeFrom(other: createdFrom)
                    }
                }
                return createdFromBuilder_
            }
            @discardableResult
            public func setCreatedFrom(_ value:Present.Coordinates!) -> Present.PutGroupRequest.Builder {
                self.createdFrom = value
                return self
            }
            @discardableResult
            public func mergeCreatedFrom(value:Present.Coordinates) throws -> Present.PutGroupRequest.Builder {
                if builderResult.hasCreatedFrom {
                    builderResult.createdFrom = try Present.Coordinates.builderWithPrototype(prototype:builderResult.createdFrom).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.createdFrom = value
                }
                builderResult.hasCreatedFrom = true
                return self
            }
            @discardableResult
            public func clearCreatedFrom() -> Present.PutGroupRequest.Builder {
                createdFromBuilder_ = nil
                builderResult.hasCreatedFrom = false
                builderResult.createdFrom = nil
                return self
            }
            /// Location returned via search. Null if the location is custom.
            public var suggestedLocation:Present.SuggestedLocation! {
                get {
                    if suggestedLocationBuilder_ != nil {
                        builderResult.suggestedLocation = suggestedLocationBuilder_.getMessage()
                    }
                    return builderResult.suggestedLocation
                }
                set (value) {
                    builderResult.hasSuggestedLocation = true
                    builderResult.suggestedLocation = value
                }
            }
            public var hasSuggestedLocation:Bool {
                get {
                    return builderResult.hasSuggestedLocation
                }
            }
            fileprivate var suggestedLocationBuilder_:Present.SuggestedLocation.Builder! {
                didSet {
                    builderResult.hasSuggestedLocation = true
                }
            }
            public func getSuggestedLocationBuilder() -> Present.SuggestedLocation.Builder {
                if suggestedLocationBuilder_ == nil {
                    suggestedLocationBuilder_ = Present.SuggestedLocation.Builder()
                    builderResult.suggestedLocation = suggestedLocationBuilder_.getMessage()
                    if suggestedLocation != nil {
                        try! suggestedLocationBuilder_.mergeFrom(other: suggestedLocation)
                    }
                }
                return suggestedLocationBuilder_
            }
            @discardableResult
            public func setSuggestedLocation(_ value:Present.SuggestedLocation!) -> Present.PutGroupRequest.Builder {
                self.suggestedLocation = value
                return self
            }
            @discardableResult
            public func mergeSuggestedLocation(value:Present.SuggestedLocation) throws -> Present.PutGroupRequest.Builder {
                if builderResult.hasSuggestedLocation {
                    builderResult.suggestedLocation = try Present.SuggestedLocation.builderWithPrototype(prototype:builderResult.suggestedLocation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.suggestedLocation = value
                }
                builderResult.hasSuggestedLocation = true
                return self
            }
            @discardableResult
            public func clearSuggestedLocation() -> Present.PutGroupRequest.Builder {
                suggestedLocationBuilder_ = nil
                builderResult.hasSuggestedLocation = false
                builderResult.suggestedLocation = nil
                return self
            }
            /// 16:9 cover photo for the circle.
            public var cover:Present.ContentReferenceRequest! {
                get {
                    if coverBuilder_ != nil {
                        builderResult.cover = coverBuilder_.getMessage()
                    }
                    return builderResult.cover
                }
                set (value) {
                    builderResult.hasCover = true
                    builderResult.cover = value
                }
            }
            public var hasCover:Bool {
                get {
                    return builderResult.hasCover
                }
            }
            fileprivate var coverBuilder_:Present.ContentReferenceRequest.Builder! {
                didSet {
                    builderResult.hasCover = true
                }
            }
            public func getCoverBuilder() -> Present.ContentReferenceRequest.Builder {
                if coverBuilder_ == nil {
                    coverBuilder_ = Present.ContentReferenceRequest.Builder()
                    builderResult.cover = coverBuilder_.getMessage()
                    if cover != nil {
                        try! coverBuilder_.mergeFrom(other: cover)
                    }
                }
                return coverBuilder_
            }
            @discardableResult
            public func setCover(_ value:Present.ContentReferenceRequest!) -> Present.PutGroupRequest.Builder {
                self.cover = value
                return self
            }
            @discardableResult
            public func mergeCover(value:Present.ContentReferenceRequest) throws -> Present.PutGroupRequest.Builder {
                if builderResult.hasCover {
                    builderResult.cover = try Present.ContentReferenceRequest.builderWithPrototype(prototype:builderResult.cover).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.cover = value
                }
                builderResult.hasCover = true
                return self
            }
            @discardableResult
            public func clearCover() -> Present.PutGroupRequest.Builder {
                coverBuilder_ = nil
                builderResult.hasCover = false
                builderResult.cover = nil
                return self
            }
            /// Description of the circle.
            public var description_:String {
                get {
                    return builderResult.description_
                }
                set (value) {
                    builderResult.hasDescription = true
                    builderResult.description_ = value
                }
            }
            public var hasDescription:Bool {
                get {
                    return builderResult.hasDescription
                }
            }
            @discardableResult
            public func setDescription(_ value:String) -> Present.PutGroupRequest.Builder {
                self.description_ = value
                return self
            }
            @discardableResult
            public func clearDescription() -> Present.PutGroupRequest.Builder{
                builderResult.hasDescription = false
                builderResult.description_ = ""
                return self
            }
            /// Optional categories that can be used in search.
            public var categories:Array<String> {
                get {
                    return builderResult.categories
                }
                set (array) {
                    builderResult.categories = array
                }
            }
            @discardableResult
            public func setCategories(_ value:Array<String>) -> Present.PutGroupRequest.Builder {
                self.categories = value
                return self
            }
            @discardableResult
            public func clearCategories() -> Present.PutGroupRequest.Builder {
                builderResult.categories.removeAll(keepingCapacity: false)
                return self
            }
            /// Optional duration of event
            public var schedule:Present.Schedule! {
                get {
                    if scheduleBuilder_ != nil {
                        builderResult.schedule = scheduleBuilder_.getMessage()
                    }
                    return builderResult.schedule
                }
                set (value) {
                    builderResult.hasSchedule = true
                    builderResult.schedule = value
                }
            }
            public var hasSchedule:Bool {
                get {
                    return builderResult.hasSchedule
                }
            }
            fileprivate var scheduleBuilder_:Present.Schedule.Builder! {
                didSet {
                    builderResult.hasSchedule = true
                }
            }
            public func getScheduleBuilder() -> Present.Schedule.Builder {
                if scheduleBuilder_ == nil {
                    scheduleBuilder_ = Present.Schedule.Builder()
                    builderResult.schedule = scheduleBuilder_.getMessage()
                    if schedule != nil {
                        try! scheduleBuilder_.mergeFrom(other: schedule)
                    }
                }
                return scheduleBuilder_
            }
            @discardableResult
            public func setSchedule(_ value:Present.Schedule!) -> Present.PutGroupRequest.Builder {
                self.schedule = value
                return self
            }
            @discardableResult
            public func mergeSchedule(value:Present.Schedule) throws -> Present.PutGroupRequest.Builder {
                if builderResult.hasSchedule {
                    builderResult.schedule = try Present.Schedule.builderWithPrototype(prototype:builderResult.schedule).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.schedule = value
                }
                builderResult.hasSchedule = true
                return self
            }
            @discardableResult
            public func clearSchedule() -> Present.PutGroupRequest.Builder {
                scheduleBuilder_ = nil
                builderResult.hasSchedule = false
                builderResult.schedule = nil
                return self
            }
            /// Pre-approve these members. Defaults to ANYONE (public).
                public var preapprove:Present.GroupMemberPreapproval {
                    get {
                        return builderResult.preapprove
                    }
                    set (value) {
                        builderResult.hasPreapprove = true
                        builderResult.preapprove = value
                    }
                }
                public var hasPreapprove:Bool{
                    get {
                        return builderResult.hasPreapprove
                    }
                }
            @discardableResult
                public func setPreapprove(_ value:Present.GroupMemberPreapproval) -> Present.PutGroupRequest.Builder {
                  self.preapprove = value
                  return self
                }
            @discardableResult
                public func clearPreapprove() -> Present.PutGroupRequest.Builder {
                   builderResult.hasPreapprove = false
                   builderResult.preapprove = .unknownGroupMemberPreapproval
                   return self
                }
            /// Whether or not the circle is discoverable by friends and people nearby.
            public var discoverable:Bool {
                get {
                    return builderResult.discoverable
                }
                set (value) {
                    builderResult.hasDiscoverable = true
                    builderResult.discoverable = value
                }
            }
            public var hasDiscoverable:Bool {
                get {
                    return builderResult.hasDiscoverable
                }
            }
            @discardableResult
            public func setDiscoverable(_ value:Bool) -> Present.PutGroupRequest.Builder {
                self.discoverable = value
                return self
            }
            @discardableResult
            public func clearDiscoverable() -> Present.PutGroupRequest.Builder{
                builderResult.hasDiscoverable = false
                builderResult.discoverable = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PutGroupRequest.Builder {
                builderResult = Present.PutGroupRequest()
                return self
            }
            override public func clone() throws -> Present.PutGroupRequest.Builder {
                return try Present.PutGroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PutGroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PutGroupRequest {
                let returnMe:Present.PutGroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PutGroupRequest) throws -> Present.PutGroupRequest.Builder {
                if other == Present.PutGroupRequest() {
                    return self
                }
                if other.hasUuid {
                    uuid = other.uuid
                }
                if other.hasSpaceId {
                    spaceId = other.spaceId
                }
                if (other.hasLocation) {
                    try mergeLocation(value: other.location)
                }
                if other.hasLocationName {
                    locationName = other.locationName
                }
                if other.hasTitle {
                    title = other.title
                }
                if (other.hasCreatedFrom) {
                    try mergeCreatedFrom(value: other.createdFrom)
                }
                if (other.hasSuggestedLocation) {
                    try mergeSuggestedLocation(value: other.suggestedLocation)
                }
                if (other.hasCover) {
                    try mergeCover(value: other.cover)
                }
                if other.hasDescription {
                    description_ = other.description_
                }
                if !other.categories.isEmpty {
                    builderResult.categories += other.categories
                }
                if (other.hasSchedule) {
                    try mergeSchedule(value: other.schedule)
                }
                if other.hasPreapprove {
                    preapprove = other.preapprove
                }
                if other.hasDiscoverable {
                    discoverable = other.discoverable
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PutGroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutGroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        uuid = try codedInputStream.readString()

                    case 18:
                        let subBuilder:Present.Coordinates.Builder = Present.Coordinates.Builder()
                        if hasLocation {
                            try subBuilder.mergeFrom(other: location)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        location = subBuilder.buildPartial()

                    case 34:
                        title = try codedInputStream.readString()

                    case 42:
                        let subBuilder:Present.Coordinates.Builder = Present.Coordinates.Builder()
                        if hasCreatedFrom {
                            try subBuilder.mergeFrom(other: createdFrom)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        createdFrom = subBuilder.buildPartial()

                    case 50:
                        locationName = try codedInputStream.readString()

                    case 58:
                        let subBuilder:Present.SuggestedLocation.Builder = Present.SuggestedLocation.Builder()
                        if hasSuggestedLocation {
                            try subBuilder.mergeFrom(other: suggestedLocation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        suggestedLocation = subBuilder.buildPartial()

                    case 66:
                        let subBuilder:Present.ContentReferenceRequest.Builder = Present.ContentReferenceRequest.Builder()
                        if hasCover {
                            try subBuilder.mergeFrom(other: cover)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        cover = subBuilder.buildPartial()

                    case 74:
                        description_ = try codedInputStream.readString()

                    case 82:
                        categories += [try codedInputStream.readString()]

                    case 90:
                        let subBuilder:Present.Schedule.Builder = Present.Schedule.Builder()
                        if hasSchedule {
                            try subBuilder.mergeFrom(other: schedule)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        schedule = subBuilder.buildPartial()

                    case 98:
                        spaceId = try codedInputStream.readString()

                    case 104:
                        let valueIntpreapprove = try codedInputStream.readEnum()
                        if let enumspreapprove = Present.GroupMemberPreapproval(rawValue:valueIntpreapprove){
                            preapprove = enumspreapprove
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 13, value:Int64(valueIntpreapprove))
                        }

                    case 112:
                        discoverable = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PutGroupRequest.Builder {
                let resultDecodedBuilder = Present.PutGroupRequest.Builder()
                if let jsonValueUuid = jsonMap["uuid"] as? String {
                    resultDecodedBuilder.uuid = jsonValueUuid
                }
                if let jsonValueSpaceId = jsonMap["spaceId"] as? String {
                    resultDecodedBuilder.spaceId = jsonValueSpaceId
                }
                if let jsonValueLocation = jsonMap["location"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.location = try Present.Coordinates.Builder.decodeToBuilder(jsonMap:jsonValueLocation).build()

                }
                if let jsonValueLocationName = jsonMap["locationName"] as? String {
                    resultDecodedBuilder.locationName = jsonValueLocationName
                }
                if let jsonValueTitle = jsonMap["title"] as? String {
                    resultDecodedBuilder.title = jsonValueTitle
                }
                if let jsonValueCreatedFrom = jsonMap["createdFrom"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.createdFrom = try Present.Coordinates.Builder.decodeToBuilder(jsonMap:jsonValueCreatedFrom).build()

                }
                if let jsonValueSuggestedLocation = jsonMap["suggestedLocation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.suggestedLocation = try Present.SuggestedLocation.Builder.decodeToBuilder(jsonMap:jsonValueSuggestedLocation).build()

                }
                if let jsonValueCover = jsonMap["cover"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.cover = try Present.ContentReferenceRequest.Builder.decodeToBuilder(jsonMap:jsonValueCover).build()

                }
                if let jsonValueDescription = jsonMap["description"] as? String {
                    resultDecodedBuilder.description_ = jsonValueDescription
                }
                if let jsonValueCategories = jsonMap["categories"] as? Array<String> {
                    var jsonArrayCategories:Array<String> = []
                    for oneValueCategories in jsonValueCategories {
                        jsonArrayCategories.append(oneValueCategories)
                    }
                    resultDecodedBuilder.categories = jsonArrayCategories
                }
                if let jsonValueSchedule = jsonMap["schedule"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.schedule = try Present.Schedule.Builder.decodeToBuilder(jsonMap:jsonValueSchedule).build()

                }
                if let jsonValuePreapprove = jsonMap["preapprove"] as? String {
                    resultDecodedBuilder.preapprove = try Present.GroupMemberPreapproval.fromString(str: jsonValuePreapprove)
                }
                if let jsonValueDiscoverable = jsonMap["discoverable"] as? Bool {
                    resultDecodedBuilder.discoverable = jsonValueDiscoverable
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PutGroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PutGroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PutGroupResponse : GeneratedMessage {

        public static func == (lhs: Present.PutGroupResponse, rhs: Present.PutGroupResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroup == rhs.hasGroup) && (!lhs.hasGroup || lhs.group == rhs.group)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var group:Present.GroupResponse!
        public fileprivate(set) var hasGroup:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroup {
                return false
            }
            if !group.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroup {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:group)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroup {
                if let varSizegroup = group?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizegroup
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PutGroupResponse.Builder {
            return Present.PutGroupResponse.classBuilder() as! Present.PutGroupResponse.Builder
        }
        public func getBuilder() -> Present.PutGroupResponse.Builder {
            return classBuilder() as! Present.PutGroupResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutGroupResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutGroupResponse.Builder()
        }
        public func toBuilder() throws -> Present.PutGroupResponse.Builder {
            return try Present.PutGroupResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PutGroupResponse) throws -> Present.PutGroupResponse.Builder {
            return try Present.PutGroupResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroup {
                jsonMap["group"] = try group.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PutGroupResponse {
            return try Present.PutGroupResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PutGroupResponse {
            return try Present.PutGroupResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroup {
                output += "\(indent) group {\n"
                if let outDescGroup = group {
                    output += try outDescGroup.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroup {
                    if let hashValuegroup = group?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegroup
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PutGroupResponse"
        }
        override public func className() -> String {
            return "Present.PutGroupResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PutGroupResponse = Present.PutGroupResponse()
            public func getMessage() -> Present.PutGroupResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The newly created group.
            public var group:Present.GroupResponse! {
                get {
                    if groupBuilder_ != nil {
                        builderResult.group = groupBuilder_.getMessage()
                    }
                    return builderResult.group
                }
                set (value) {
                    builderResult.hasGroup = true
                    builderResult.group = value
                }
            }
            public var hasGroup:Bool {
                get {
                    return builderResult.hasGroup
                }
            }
            fileprivate var groupBuilder_:Present.GroupResponse.Builder! {
                didSet {
                    builderResult.hasGroup = true
                }
            }
            public func getGroupBuilder() -> Present.GroupResponse.Builder {
                if groupBuilder_ == nil {
                    groupBuilder_ = Present.GroupResponse.Builder()
                    builderResult.group = groupBuilder_.getMessage()
                    if group != nil {
                        try! groupBuilder_.mergeFrom(other: group)
                    }
                }
                return groupBuilder_
            }
            @discardableResult
            public func setGroup(_ value:Present.GroupResponse!) -> Present.PutGroupResponse.Builder {
                self.group = value
                return self
            }
            @discardableResult
            public func mergeGroup(value:Present.GroupResponse) throws -> Present.PutGroupResponse.Builder {
                if builderResult.hasGroup {
                    builderResult.group = try Present.GroupResponse.builderWithPrototype(prototype:builderResult.group).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.group = value
                }
                builderResult.hasGroup = true
                return self
            }
            @discardableResult
            public func clearGroup() -> Present.PutGroupResponse.Builder {
                groupBuilder_ = nil
                builderResult.hasGroup = false
                builderResult.group = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PutGroupResponse.Builder {
                builderResult = Present.PutGroupResponse()
                return self
            }
            override public func clone() throws -> Present.PutGroupResponse.Builder {
                return try Present.PutGroupResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PutGroupResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PutGroupResponse {
                let returnMe:Present.PutGroupResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PutGroupResponse) throws -> Present.PutGroupResponse.Builder {
                if other == Present.PutGroupResponse() {
                    return self
                }
                if (other.hasGroup) {
                    try mergeGroup(value: other.group)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PutGroupResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutGroupResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.GroupResponse.Builder = Present.GroupResponse.Builder()
                        if hasGroup {
                            try subBuilder.mergeFrom(other: group)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        group = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PutGroupResponse.Builder {
                let resultDecodedBuilder = Present.PutGroupResponse.Builder()
                if let jsonValueGroup = jsonMap["group"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.group = try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:jsonValueGroup).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PutGroupResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PutGroupResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PastCommentsRequest : GeneratedMessage {

        public static func == (lhs: Present.PastCommentsRequest, rhs: Present.PastCommentsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PastCommentsRequest.Builder {
            return Present.PastCommentsRequest.classBuilder() as! Present.PastCommentsRequest.Builder
        }
        public func getBuilder() -> Present.PastCommentsRequest.Builder {
            return classBuilder() as! Present.PastCommentsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PastCommentsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PastCommentsRequest.Builder()
        }
        public func toBuilder() throws -> Present.PastCommentsRequest.Builder {
            return try Present.PastCommentsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PastCommentsRequest) throws -> Present.PastCommentsRequest.Builder {
            return try Present.PastCommentsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PastCommentsRequest {
            return try Present.PastCommentsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PastCommentsRequest {
            return try Present.PastCommentsRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PastCommentsRequest"
        }
        override public func className() -> String {
            return "Present.PastCommentsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PastCommentsRequest = Present.PastCommentsRequest()
            public func getMessage() -> Present.PastCommentsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.PastCommentsRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.PastCommentsRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PastCommentsRequest.Builder {
                builderResult = Present.PastCommentsRequest()
                return self
            }
            override public func clone() throws -> Present.PastCommentsRequest.Builder {
                return try Present.PastCommentsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PastCommentsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PastCommentsRequest {
                let returnMe:Present.PastCommentsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PastCommentsRequest) throws -> Present.PastCommentsRequest.Builder {
                if other == Present.PastCommentsRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PastCommentsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastCommentsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PastCommentsRequest.Builder {
                let resultDecodedBuilder = Present.PastCommentsRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PastCommentsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PastCommentsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PastCommentsResponse : GeneratedMessage {

        public static func == (lhs: Present.PastCommentsResponse, rhs: Present.PastCommentsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.comments == rhs.comments)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var comments:Array<Present.CommentResponse>  = Array<Present.CommentResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitComments:Bool = true
            for oneElementComments in comments {
                if !oneElementComments.isInitialized() {
                    isInitComments = false
                    break 
                }
            }
            if !isInitComments {
                return isInitComments
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementComments in comments {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementComments)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementComments in comments {
                serialize_size += oneElementComments.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PastCommentsResponse.Builder {
            return Present.PastCommentsResponse.classBuilder() as! Present.PastCommentsResponse.Builder
        }
        public func getBuilder() -> Present.PastCommentsResponse.Builder {
            return classBuilder() as! Present.PastCommentsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PastCommentsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PastCommentsResponse.Builder()
        }
        public func toBuilder() throws -> Present.PastCommentsResponse.Builder {
            return try Present.PastCommentsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PastCommentsResponse) throws -> Present.PastCommentsResponse.Builder {
            return try Present.PastCommentsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !comments.isEmpty {
                var jsonArrayComments:Array<Dictionary<String,Any>> = []
                for oneValueComments in comments {
                    let ecodedMessageComments = try oneValueComments.encode()
                    jsonArrayComments.append(ecodedMessageComments)
                }
                jsonMap["comments"] = jsonArrayComments
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PastCommentsResponse {
            return try Present.PastCommentsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PastCommentsResponse {
            return try Present.PastCommentsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var commentsElementIndex:Int = 0
            for oneElementComments in comments {
                output += "\(indent) comments[\(commentsElementIndex)] {\n"
                output += try oneElementComments.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                commentsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementComments in comments {
                    hashCode = (hashCode &* 31) &+ oneElementComments.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PastCommentsResponse"
        }
        override public func className() -> String {
            return "Present.PastCommentsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PastCommentsResponse = Present.PastCommentsResponse()
            public func getMessage() -> Present.PastCommentsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Past comments, newest first.
            public var comments:Array<Present.CommentResponse> {
                get {
                    return builderResult.comments
                }
                set (value) {
                    builderResult.comments = value
                }
            }
            @discardableResult
            public func setComments(_ value:Array<Present.CommentResponse>) -> Present.PastCommentsResponse.Builder {
                self.comments = value
                return self
            }
            @discardableResult
            public func clearComments() -> Present.PastCommentsResponse.Builder {
                builderResult.comments.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PastCommentsResponse.Builder {
                builderResult = Present.PastCommentsResponse()
                return self
            }
            override public func clone() throws -> Present.PastCommentsResponse.Builder {
                return try Present.PastCommentsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PastCommentsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PastCommentsResponse {
                let returnMe:Present.PastCommentsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PastCommentsResponse) throws -> Present.PastCommentsResponse.Builder {
                if other == Present.PastCommentsResponse() {
                    return self
                }
                if !other.comments.isEmpty  {
                     builderResult.comments += other.comments
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PastCommentsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastCommentsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.CommentResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        comments.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PastCommentsResponse.Builder {
                let resultDecodedBuilder = Present.PastCommentsResponse.Builder()
                if let jsonValueComments = jsonMap["comments"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayComments:Array<Present.CommentResponse> = []
                    for oneValueComments in jsonValueComments {
                        let messageFromStringComments = try Present.CommentResponse.Builder.decodeToBuilder(jsonMap:oneValueComments).build()

                        jsonArrayComments.append(messageFromStringComments)
                    }
                    resultDecodedBuilder.comments = jsonArrayComments
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PastCommentsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PastCommentsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CommentRequest : GeneratedMessage {

        public static func == (lhs: Present.CommentRequest, rhs: Present.CommentRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCommentId == rhs.hasCommentId) && (!lhs.hasCommentId || lhs.commentId == rhs.commentId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var commentId:String = ""
        public fileprivate(set) var hasCommentId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasCommentId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCommentId {
                try codedOutputStream.writeString(fieldNumber: 1, value:commentId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCommentId {
                serialize_size += commentId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.CommentRequest.Builder {
            return Present.CommentRequest.classBuilder() as! Present.CommentRequest.Builder
        }
        public func getBuilder() -> Present.CommentRequest.Builder {
            return classBuilder() as! Present.CommentRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CommentRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CommentRequest.Builder()
        }
        public func toBuilder() throws -> Present.CommentRequest.Builder {
            return try Present.CommentRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.CommentRequest) throws -> Present.CommentRequest.Builder {
            return try Present.CommentRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCommentId {
                jsonMap["commentId"] = commentId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.CommentRequest {
            return try Present.CommentRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.CommentRequest {
            return try Present.CommentRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCommentId {
                output += "\(indent) commentId: \(commentId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCommentId {
                    hashCode = (hashCode &* 31) &+ commentId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.CommentRequest"
        }
        override public func className() -> String {
            return "Present.CommentRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.CommentRequest = Present.CommentRequest()
            public func getMessage() -> Present.CommentRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var commentId:String {
                get {
                    return builderResult.commentId
                }
                set (value) {
                    builderResult.hasCommentId = true
                    builderResult.commentId = value
                }
            }
            public var hasCommentId:Bool {
                get {
                    return builderResult.hasCommentId
                }
            }
            @discardableResult
            public func setCommentId(_ value:String) -> Present.CommentRequest.Builder {
                self.commentId = value
                return self
            }
            @discardableResult
            public func clearCommentId() -> Present.CommentRequest.Builder{
                builderResult.hasCommentId = false
                builderResult.commentId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.CommentRequest.Builder {
                builderResult = Present.CommentRequest()
                return self
            }
            override public func clone() throws -> Present.CommentRequest.Builder {
                return try Present.CommentRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.CommentRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.CommentRequest {
                let returnMe:Present.CommentRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.CommentRequest) throws -> Present.CommentRequest.Builder {
                if other == Present.CommentRequest() {
                    return self
                }
                if other.hasCommentId {
                    commentId = other.commentId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.CommentRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CommentRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        commentId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.CommentRequest.Builder {
                let resultDecodedBuilder = Present.CommentRequest.Builder()
                if let jsonValueCommentId = jsonMap["commentId"] as? String {
                    resultDecodedBuilder.commentId = jsonValueCommentId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.CommentRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.CommentRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PutCommentRequest : GeneratedMessage {

        public static func == (lhs: Present.PutCommentRequest, rhs: Present.PutCommentRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUuid == rhs.hasUuid) && (!lhs.hasUuid || lhs.uuid == rhs.uuid)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasComment == rhs.hasComment) && (!lhs.hasComment || lhs.comment == rhs.comment)
            fieldCheck = fieldCheck && (lhs.hasContent == rhs.hasContent) && (!lhs.hasContent || lhs.content == rhs.content)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The client supplied uuid to be associated with the comment.
        public fileprivate(set) var uuid:String = ""
        public fileprivate(set) var hasUuid:Bool = false

        /// Group to post the comment to.
        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        /// Comment text. Required unless "content" is set.
        public fileprivate(set) var comment:String = ""
        public fileprivate(set) var hasComment:Bool = false

        public fileprivate(set) var content:Present.ContentReferenceRequest!
        public fileprivate(set) var hasContent:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUuid {
                return false
            }
            if !hasGroupId {
                return false
            }
            if hasContent {
                if !content.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUuid {
                try codedOutputStream.writeString(fieldNumber: 1, value:uuid)
            }
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 3, value:groupId)
            }
            if hasComment {
                try codedOutputStream.writeString(fieldNumber: 4, value:comment)
            }
            if hasContent {
                try codedOutputStream.writeMessage(fieldNumber: 6, value:content)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUuid {
                serialize_size += uuid.computeStringSize(fieldNumber: 1)
            }
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 3)
            }
            if hasComment {
                serialize_size += comment.computeStringSize(fieldNumber: 4)
            }
            if hasContent {
                if let varSizecontent = content?.computeMessageSize(fieldNumber: 6) {
                    serialize_size += varSizecontent
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.PutCommentRequest.Builder {
            return Present.PutCommentRequest.classBuilder() as! Present.PutCommentRequest.Builder
        }
        public func getBuilder() -> Present.PutCommentRequest.Builder {
            return classBuilder() as! Present.PutCommentRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutCommentRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.PutCommentRequest.Builder()
        }
        public func toBuilder() throws -> Present.PutCommentRequest.Builder {
            return try Present.PutCommentRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.PutCommentRequest) throws -> Present.PutCommentRequest.Builder {
            return try Present.PutCommentRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUuid {
                jsonMap["uuid"] = uuid
            }
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if hasComment {
                jsonMap["comment"] = comment
            }
            if hasContent {
                jsonMap["content"] = try content.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.PutCommentRequest {
            return try Present.PutCommentRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.PutCommentRequest {
            return try Present.PutCommentRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUuid {
                output += "\(indent) uuid: \(uuid) \n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasComment {
                output += "\(indent) comment: \(comment) \n"
            }
            if hasContent {
                output += "\(indent) content {\n"
                if let outDescContent = content {
                    output += try outDescContent.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUuid {
                    hashCode = (hashCode &* 31) &+ uuid.hashValue
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasComment {
                    hashCode = (hashCode &* 31) &+ comment.hashValue
                }
                if hasContent {
                    if let hashValuecontent = content?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecontent
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.PutCommentRequest"
        }
        override public func className() -> String {
            return "Present.PutCommentRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.PutCommentRequest = Present.PutCommentRequest()
            public func getMessage() -> Present.PutCommentRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The client supplied uuid to be associated with the comment.
            public var uuid:String {
                get {
                    return builderResult.uuid
                }
                set (value) {
                    builderResult.hasUuid = true
                    builderResult.uuid = value
                }
            }
            public var hasUuid:Bool {
                get {
                    return builderResult.hasUuid
                }
            }
            @discardableResult
            public func setUuid(_ value:String) -> Present.PutCommentRequest.Builder {
                self.uuid = value
                return self
            }
            @discardableResult
            public func clearUuid() -> Present.PutCommentRequest.Builder{
                builderResult.hasUuid = false
                builderResult.uuid = ""
                return self
            }
            /// Group to post the comment to.
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.PutCommentRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.PutCommentRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            /// Comment text. Required unless "content" is set.
            public var comment:String {
                get {
                    return builderResult.comment
                }
                set (value) {
                    builderResult.hasComment = true
                    builderResult.comment = value
                }
            }
            public var hasComment:Bool {
                get {
                    return builderResult.hasComment
                }
            }
            @discardableResult
            public func setComment(_ value:String) -> Present.PutCommentRequest.Builder {
                self.comment = value
                return self
            }
            @discardableResult
            public func clearComment() -> Present.PutCommentRequest.Builder{
                builderResult.hasComment = false
                builderResult.comment = ""
                return self
            }
            /// Photo or video attachment.
            public var content:Present.ContentReferenceRequest! {
                get {
                    if contentBuilder_ != nil {
                        builderResult.content = contentBuilder_.getMessage()
                    }
                    return builderResult.content
                }
                set (value) {
                    builderResult.hasContent = true
                    builderResult.content = value
                }
            }
            public var hasContent:Bool {
                get {
                    return builderResult.hasContent
                }
            }
            fileprivate var contentBuilder_:Present.ContentReferenceRequest.Builder! {
                didSet {
                    builderResult.hasContent = true
                }
            }
            public func getContentBuilder() -> Present.ContentReferenceRequest.Builder {
                if contentBuilder_ == nil {
                    contentBuilder_ = Present.ContentReferenceRequest.Builder()
                    builderResult.content = contentBuilder_.getMessage()
                    if content != nil {
                        try! contentBuilder_.mergeFrom(other: content)
                    }
                }
                return contentBuilder_
            }
            @discardableResult
            public func setContent(_ value:Present.ContentReferenceRequest!) -> Present.PutCommentRequest.Builder {
                self.content = value
                return self
            }
            @discardableResult
            public func mergeContent(value:Present.ContentReferenceRequest) throws -> Present.PutCommentRequest.Builder {
                if builderResult.hasContent {
                    builderResult.content = try Present.ContentReferenceRequest.builderWithPrototype(prototype:builderResult.content).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.content = value
                }
                builderResult.hasContent = true
                return self
            }
            @discardableResult
            public func clearContent() -> Present.PutCommentRequest.Builder {
                contentBuilder_ = nil
                builderResult.hasContent = false
                builderResult.content = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.PutCommentRequest.Builder {
                builderResult = Present.PutCommentRequest()
                return self
            }
            override public func clone() throws -> Present.PutCommentRequest.Builder {
                return try Present.PutCommentRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.PutCommentRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.PutCommentRequest {
                let returnMe:Present.PutCommentRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.PutCommentRequest) throws -> Present.PutCommentRequest.Builder {
                if other == Present.PutCommentRequest() {
                    return self
                }
                if other.hasUuid {
                    uuid = other.uuid
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasComment {
                    comment = other.comment
                }
                if (other.hasContent) {
                    try mergeContent(value: other.content)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.PutCommentRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutCommentRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        uuid = try codedInputStream.readString()

                    case 26:
                        groupId = try codedInputStream.readString()

                    case 34:
                        comment = try codedInputStream.readString()

                    case 50:
                        let subBuilder:Present.ContentReferenceRequest.Builder = Present.ContentReferenceRequest.Builder()
                        if hasContent {
                            try subBuilder.mergeFrom(other: content)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        content = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.PutCommentRequest.Builder {
                let resultDecodedBuilder = Present.PutCommentRequest.Builder()
                if let jsonValueUuid = jsonMap["uuid"] as? String {
                    resultDecodedBuilder.uuid = jsonValueUuid
                }
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueComment = jsonMap["comment"] as? String {
                    resultDecodedBuilder.comment = jsonValueComment
                }
                if let jsonValueContent = jsonMap["content"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.content = try Present.ContentReferenceRequest.Builder.decodeToBuilder(jsonMap:jsonValueContent).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.PutCommentRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.PutCommentRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FindLiveServerRequest : GeneratedMessage {

        public static func == (lhs: Present.FindLiveServerRequest, rhs: Present.FindLiveServerRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.FindLiveServerRequest.Builder {
            return Present.FindLiveServerRequest.classBuilder() as! Present.FindLiveServerRequest.Builder
        }
        public func getBuilder() -> Present.FindLiveServerRequest.Builder {
            return classBuilder() as! Present.FindLiveServerRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FindLiveServerRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FindLiveServerRequest.Builder()
        }
        public func toBuilder() throws -> Present.FindLiveServerRequest.Builder {
            return try Present.FindLiveServerRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.FindLiveServerRequest) throws -> Present.FindLiveServerRequest.Builder {
            return try Present.FindLiveServerRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.FindLiveServerRequest {
            return try Present.FindLiveServerRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.FindLiveServerRequest {
            return try Present.FindLiveServerRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.FindLiveServerRequest"
        }
        override public func className() -> String {
            return "Present.FindLiveServerRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.FindLiveServerRequest = Present.FindLiveServerRequest()
            public func getMessage() -> Present.FindLiveServerRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.FindLiveServerRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.FindLiveServerRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.FindLiveServerRequest.Builder {
                builderResult = Present.FindLiveServerRequest()
                return self
            }
            override public func clone() throws -> Present.FindLiveServerRequest.Builder {
                return try Present.FindLiveServerRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.FindLiveServerRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.FindLiveServerRequest {
                let returnMe:Present.FindLiveServerRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.FindLiveServerRequest) throws -> Present.FindLiveServerRequest.Builder {
                if other == Present.FindLiveServerRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.FindLiveServerRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FindLiveServerRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.FindLiveServerRequest.Builder {
                let resultDecodedBuilder = Present.FindLiveServerRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.FindLiveServerRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.FindLiveServerRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FindLiveServerResponse : GeneratedMessage {

        public static func == (lhs: Present.FindLiveServerResponse, rhs: Present.FindLiveServerResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHost == rhs.hasHost) && (!lhs.hasHost || lhs.host == rhs.host)
            fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var host:String = ""
        public fileprivate(set) var hasHost:Bool = false

        public fileprivate(set) var port:Int32 = Int32(0)
        public fileprivate(set) var hasPort:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasHost {
                return false
            }
            if !hasPort {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHost {
                try codedOutputStream.writeString(fieldNumber: 1, value:host)
            }
            if hasPort {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:port)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHost {
                serialize_size += host.computeStringSize(fieldNumber: 1)
            }
            if hasPort {
                serialize_size += port.computeInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.FindLiveServerResponse.Builder {
            return Present.FindLiveServerResponse.classBuilder() as! Present.FindLiveServerResponse.Builder
        }
        public func getBuilder() -> Present.FindLiveServerResponse.Builder {
            return classBuilder() as! Present.FindLiveServerResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FindLiveServerResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FindLiveServerResponse.Builder()
        }
        public func toBuilder() throws -> Present.FindLiveServerResponse.Builder {
            return try Present.FindLiveServerResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.FindLiveServerResponse) throws -> Present.FindLiveServerResponse.Builder {
            return try Present.FindLiveServerResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHost {
                jsonMap["host"] = host
            }
            if hasPort {
                jsonMap["port"] = Int(port)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.FindLiveServerResponse {
            return try Present.FindLiveServerResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.FindLiveServerResponse {
            return try Present.FindLiveServerResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHost {
                output += "\(indent) host: \(host) \n"
            }
            if hasPort {
                output += "\(indent) port: \(port) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHost {
                    hashCode = (hashCode &* 31) &+ host.hashValue
                }
                if hasPort {
                    hashCode = (hashCode &* 31) &+ port.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.FindLiveServerResponse"
        }
        override public func className() -> String {
            return "Present.FindLiveServerResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.FindLiveServerResponse = Present.FindLiveServerResponse()
            public func getMessage() -> Present.FindLiveServerResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var host:String {
                get {
                    return builderResult.host
                }
                set (value) {
                    builderResult.hasHost = true
                    builderResult.host = value
                }
            }
            public var hasHost:Bool {
                get {
                    return builderResult.hasHost
                }
            }
            @discardableResult
            public func setHost(_ value:String) -> Present.FindLiveServerResponse.Builder {
                self.host = value
                return self
            }
            @discardableResult
            public func clearHost() -> Present.FindLiveServerResponse.Builder{
                builderResult.hasHost = false
                builderResult.host = ""
                return self
            }
            public var port:Int32 {
                get {
                    return builderResult.port
                }
                set (value) {
                    builderResult.hasPort = true
                    builderResult.port = value
                }
            }
            public var hasPort:Bool {
                get {
                    return builderResult.hasPort
                }
            }
            @discardableResult
            public func setPort(_ value:Int32) -> Present.FindLiveServerResponse.Builder {
                self.port = value
                return self
            }
            @discardableResult
            public func clearPort() -> Present.FindLiveServerResponse.Builder{
                builderResult.hasPort = false
                builderResult.port = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.FindLiveServerResponse.Builder {
                builderResult = Present.FindLiveServerResponse()
                return self
            }
            override public func clone() throws -> Present.FindLiveServerResponse.Builder {
                return try Present.FindLiveServerResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.FindLiveServerResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.FindLiveServerResponse {
                let returnMe:Present.FindLiveServerResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.FindLiveServerResponse) throws -> Present.FindLiveServerResponse.Builder {
                if other == Present.FindLiveServerResponse() {
                    return self
                }
                if other.hasHost {
                    host = other.host
                }
                if other.hasPort {
                    port = other.port
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.FindLiveServerResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FindLiveServerResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        host = try codedInputStream.readString()

                    case 16:
                        port = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.FindLiveServerResponse.Builder {
                let resultDecodedBuilder = Present.FindLiveServerResponse.Builder()
                if let jsonValueHost = jsonMap["host"] as? String {
                    resultDecodedBuilder.host = jsonValueHost
                }
                if let jsonValuePort = jsonMap["port"] as? Int {
                    resultDecodedBuilder.port = Int32(jsonValuePort)
                } else if let jsonValuePort = jsonMap["port"] as? String {
                    resultDecodedBuilder.port = Int32(jsonValuePort)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.FindLiveServerResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.FindLiveServerResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class JoinGroupRequest : GeneratedMessage {

        public static func == (lhs: Present.JoinGroupRequest, rhs: Present.JoinGroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasIgnoreDeletions == rhs.hasIgnoreDeletions) && (!lhs.hasIgnoreDeletions || lhs.ignoreDeletions == rhs.ignoreDeletions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var ignoreDeletions:Bool = false
        public fileprivate(set) var hasIgnoreDeletions:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            if hasIgnoreDeletions {
                try codedOutputStream.writeBool(fieldNumber: 2, value:ignoreDeletions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            if hasIgnoreDeletions {
                serialize_size += ignoreDeletions.computeBoolSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.JoinGroupRequest.Builder {
            return Present.JoinGroupRequest.classBuilder() as! Present.JoinGroupRequest.Builder
        }
        public func getBuilder() -> Present.JoinGroupRequest.Builder {
            return classBuilder() as! Present.JoinGroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.JoinGroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.JoinGroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.JoinGroupRequest.Builder {
            return try Present.JoinGroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.JoinGroupRequest) throws -> Present.JoinGroupRequest.Builder {
            return try Present.JoinGroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if hasIgnoreDeletions {
                jsonMap["ignoreDeletions"] = ignoreDeletions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.JoinGroupRequest {
            return try Present.JoinGroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.JoinGroupRequest {
            return try Present.JoinGroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasIgnoreDeletions {
                output += "\(indent) ignoreDeletions: \(ignoreDeletions) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasIgnoreDeletions {
                    hashCode = (hashCode &* 31) &+ ignoreDeletions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.JoinGroupRequest"
        }
        override public func className() -> String {
            return "Present.JoinGroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.JoinGroupRequest = Present.JoinGroupRequest()
            public func getMessage() -> Present.JoinGroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.JoinGroupRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.JoinGroupRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            public var ignoreDeletions:Bool {
                get {
                    return builderResult.ignoreDeletions
                }
                set (value) {
                    builderResult.hasIgnoreDeletions = true
                    builderResult.ignoreDeletions = value
                }
            }
            public var hasIgnoreDeletions:Bool {
                get {
                    return builderResult.hasIgnoreDeletions
                }
            }
            @discardableResult
            public func setIgnoreDeletions(_ value:Bool) -> Present.JoinGroupRequest.Builder {
                self.ignoreDeletions = value
                return self
            }
            @discardableResult
            public func clearIgnoreDeletions() -> Present.JoinGroupRequest.Builder{
                builderResult.hasIgnoreDeletions = false
                builderResult.ignoreDeletions = false
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.JoinGroupRequest.Builder {
                builderResult = Present.JoinGroupRequest()
                return self
            }
            override public func clone() throws -> Present.JoinGroupRequest.Builder {
                return try Present.JoinGroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.JoinGroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.JoinGroupRequest {
                let returnMe:Present.JoinGroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.JoinGroupRequest) throws -> Present.JoinGroupRequest.Builder {
                if other == Present.JoinGroupRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasIgnoreDeletions {
                    ignoreDeletions = other.ignoreDeletions
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.JoinGroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinGroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    case 16:
                        ignoreDeletions = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.JoinGroupRequest.Builder {
                let resultDecodedBuilder = Present.JoinGroupRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueIgnoreDeletions = jsonMap["ignoreDeletions"] as? Bool {
                    resultDecodedBuilder.ignoreDeletions = jsonValueIgnoreDeletions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.JoinGroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.JoinGroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class JoinGroupResponse : GeneratedMessage {

        public static func == (lhs: Present.JoinGroupResponse, rhs: Present.JoinGroupResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var result:Present.GroupMembershipState = Present.GroupMembershipState.`none`
        public fileprivate(set) var hasResult:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasResult {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasResult {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasResult) {
                serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.JoinGroupResponse.Builder {
            return Present.JoinGroupResponse.classBuilder() as! Present.JoinGroupResponse.Builder
        }
        public func getBuilder() -> Present.JoinGroupResponse.Builder {
            return classBuilder() as! Present.JoinGroupResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.JoinGroupResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.JoinGroupResponse.Builder()
        }
        public func toBuilder() throws -> Present.JoinGroupResponse.Builder {
            return try Present.JoinGroupResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.JoinGroupResponse) throws -> Present.JoinGroupResponse.Builder {
            return try Present.JoinGroupResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasResult {
                jsonMap["result"] = result.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.JoinGroupResponse {
            return try Present.JoinGroupResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.JoinGroupResponse {
            return try Present.JoinGroupResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasResult) {
                output += "\(indent) result: \(result.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasResult {
                     hashCode = (hashCode &* 31) &+ result.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.JoinGroupResponse"
        }
        override public func className() -> String {
            return "Present.JoinGroupResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.JoinGroupResponse = Present.JoinGroupResponse()
            public func getMessage() -> Present.JoinGroupResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Can be REQUESTED, ACTIVE or REJECTED.
                public var result:Present.GroupMembershipState {
                    get {
                        return builderResult.result
                    }
                    set (value) {
                        builderResult.hasResult = true
                        builderResult.result = value
                    }
                }
                public var hasResult:Bool{
                    get {
                        return builderResult.hasResult
                    }
                }
            @discardableResult
                public func setResult(_ value:Present.GroupMembershipState) -> Present.JoinGroupResponse.Builder {
                  self.result = value
                  return self
                }
            @discardableResult
                public func clearResult() -> Present.JoinGroupResponse.Builder {
                   builderResult.hasResult = false
                   builderResult.result = .`none`
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.JoinGroupResponse.Builder {
                builderResult = Present.JoinGroupResponse()
                return self
            }
            override public func clone() throws -> Present.JoinGroupResponse.Builder {
                return try Present.JoinGroupResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.JoinGroupResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.JoinGroupResponse {
                let returnMe:Present.JoinGroupResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.JoinGroupResponse) throws -> Present.JoinGroupResponse.Builder {
                if other == Present.JoinGroupResponse() {
                    return self
                }
                if other.hasResult {
                    result = other.result
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.JoinGroupResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinGroupResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntresult = try codedInputStream.readEnum()
                        if let enumsresult = Present.GroupMembershipState(rawValue:valueIntresult){
                            result = enumsresult
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.JoinGroupResponse.Builder {
                let resultDecodedBuilder = Present.JoinGroupResponse.Builder()
                if let jsonValueResult = jsonMap["result"] as? String {
                    resultDecodedBuilder.result = try Present.GroupMembershipState.fromString(str: jsonValueResult)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.JoinGroupResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.JoinGroupResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LeaveGroupRequest : GeneratedMessage {

        public static func == (lhs: Present.LeaveGroupRequest, rhs: Present.LeaveGroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.LeaveGroupRequest.Builder {
            return Present.LeaveGroupRequest.classBuilder() as! Present.LeaveGroupRequest.Builder
        }
        public func getBuilder() -> Present.LeaveGroupRequest.Builder {
            return classBuilder() as! Present.LeaveGroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.LeaveGroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.LeaveGroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.LeaveGroupRequest.Builder {
            return try Present.LeaveGroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.LeaveGroupRequest) throws -> Present.LeaveGroupRequest.Builder {
            return try Present.LeaveGroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.LeaveGroupRequest {
            return try Present.LeaveGroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.LeaveGroupRequest {
            return try Present.LeaveGroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.LeaveGroupRequest"
        }
        override public func className() -> String {
            return "Present.LeaveGroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.LeaveGroupRequest = Present.LeaveGroupRequest()
            public func getMessage() -> Present.LeaveGroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.LeaveGroupRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.LeaveGroupRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.LeaveGroupRequest.Builder {
                builderResult = Present.LeaveGroupRequest()
                return self
            }
            override public func clone() throws -> Present.LeaveGroupRequest.Builder {
                return try Present.LeaveGroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.LeaveGroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.LeaveGroupRequest {
                let returnMe:Present.LeaveGroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.LeaveGroupRequest) throws -> Present.LeaveGroupRequest.Builder {
                if other == Present.LeaveGroupRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.LeaveGroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LeaveGroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.LeaveGroupRequest.Builder {
                let resultDecodedBuilder = Present.LeaveGroupRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.LeaveGroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.LeaveGroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FlagGroupRequest : GeneratedMessage {

        public static func == (lhs: Present.FlagGroupRequest, rhs: Present.FlagGroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasReason == rhs.hasReason) && (!lhs.hasReason || lhs.reason == rhs.reason)
            fieldCheck = fieldCheck && (lhs.hasCustomReason == rhs.hasCustomReason) && (!lhs.hasCustomReason || lhs.customReason == rhs.customReason)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var reason:Present.FlagReason = Present.FlagReason.custom
        public fileprivate(set) var hasReason:Bool = false
        public fileprivate(set) var customReason:String = ""
        public fileprivate(set) var hasCustomReason:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            if !hasReason {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            if hasReason {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:reason.rawValue)
            }
            if hasCustomReason {
                try codedOutputStream.writeString(fieldNumber: 3, value:customReason)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            if (hasReason) {
                serialize_size += reason.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasCustomReason {
                serialize_size += customReason.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.FlagGroupRequest.Builder {
            return Present.FlagGroupRequest.classBuilder() as! Present.FlagGroupRequest.Builder
        }
        public func getBuilder() -> Present.FlagGroupRequest.Builder {
            return classBuilder() as! Present.FlagGroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FlagGroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FlagGroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.FlagGroupRequest.Builder {
            return try Present.FlagGroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.FlagGroupRequest) throws -> Present.FlagGroupRequest.Builder {
            return try Present.FlagGroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if hasReason {
                jsonMap["reason"] = reason.toString()
            }
            if hasCustomReason {
                jsonMap["customReason"] = customReason
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.FlagGroupRequest {
            return try Present.FlagGroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.FlagGroupRequest {
            return try Present.FlagGroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if (hasReason) {
                output += "\(indent) reason: \(reason.description)\n"
            }
            if hasCustomReason {
                output += "\(indent) customReason: \(customReason) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasReason {
                     hashCode = (hashCode &* 31) &+ reason.hashValue
                }
                if hasCustomReason {
                    hashCode = (hashCode &* 31) &+ customReason.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.FlagGroupRequest"
        }
        override public func className() -> String {
            return "Present.FlagGroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.FlagGroupRequest = Present.FlagGroupRequest()
            public func getMessage() -> Present.FlagGroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.FlagGroupRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.FlagGroupRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
                public var reason:Present.FlagReason {
                    get {
                        return builderResult.reason
                    }
                    set (value) {
                        builderResult.hasReason = true
                        builderResult.reason = value
                    }
                }
                public var hasReason:Bool{
                    get {
                        return builderResult.hasReason
                    }
                }
            @discardableResult
                public func setReason(_ value:Present.FlagReason) -> Present.FlagGroupRequest.Builder {
                  self.reason = value
                  return self
                }
            @discardableResult
                public func clearReason() -> Present.FlagGroupRequest.Builder {
                   builderResult.hasReason = false
                   builderResult.reason = .custom
                   return self
                }
            public var customReason:String {
                get {
                    return builderResult.customReason
                }
                set (value) {
                    builderResult.hasCustomReason = true
                    builderResult.customReason = value
                }
            }
            public var hasCustomReason:Bool {
                get {
                    return builderResult.hasCustomReason
                }
            }
            @discardableResult
            public func setCustomReason(_ value:String) -> Present.FlagGroupRequest.Builder {
                self.customReason = value
                return self
            }
            @discardableResult
            public func clearCustomReason() -> Present.FlagGroupRequest.Builder{
                builderResult.hasCustomReason = false
                builderResult.customReason = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.FlagGroupRequest.Builder {
                builderResult = Present.FlagGroupRequest()
                return self
            }
            override public func clone() throws -> Present.FlagGroupRequest.Builder {
                return try Present.FlagGroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.FlagGroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.FlagGroupRequest {
                let returnMe:Present.FlagGroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.FlagGroupRequest) throws -> Present.FlagGroupRequest.Builder {
                if other == Present.FlagGroupRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasReason {
                    reason = other.reason
                }
                if other.hasCustomReason {
                    customReason = other.customReason
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.FlagGroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FlagGroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    case 16:
                        let valueIntreason = try codedInputStream.readEnum()
                        if let enumsreason = Present.FlagReason(rawValue:valueIntreason){
                            reason = enumsreason
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntreason))
                        }

                    case 26:
                        customReason = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.FlagGroupRequest.Builder {
                let resultDecodedBuilder = Present.FlagGroupRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueReason = jsonMap["reason"] as? String {
                    resultDecodedBuilder.reason = try Present.FlagReason.fromString(str: jsonValueReason)
                }
                if let jsonValueCustomReason = jsonMap["customReason"] as? String {
                    resultDecodedBuilder.customReason = jsonValueCustomReason
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.FlagGroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.FlagGroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FlagCommentRequest : GeneratedMessage {

        public static func == (lhs: Present.FlagCommentRequest, rhs: Present.FlagCommentRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCommentId == rhs.hasCommentId) && (!lhs.hasCommentId || lhs.commentId == rhs.commentId)
            fieldCheck = fieldCheck && (lhs.hasReason == rhs.hasReason) && (!lhs.hasReason || lhs.reason == rhs.reason)
            fieldCheck = fieldCheck && (lhs.hasCustomReason == rhs.hasCustomReason) && (!lhs.hasCustomReason || lhs.customReason == rhs.customReason)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var commentId:String = ""
        public fileprivate(set) var hasCommentId:Bool = false

        public fileprivate(set) var reason:Present.FlagReason = Present.FlagReason.custom
        public fileprivate(set) var hasReason:Bool = false
        public fileprivate(set) var customReason:String = ""
        public fileprivate(set) var hasCustomReason:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasCommentId {
                return false
            }
            if !hasReason {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCommentId {
                try codedOutputStream.writeString(fieldNumber: 1, value:commentId)
            }
            if hasReason {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:reason.rawValue)
            }
            if hasCustomReason {
                try codedOutputStream.writeString(fieldNumber: 3, value:customReason)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCommentId {
                serialize_size += commentId.computeStringSize(fieldNumber: 1)
            }
            if (hasReason) {
                serialize_size += reason.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasCustomReason {
                serialize_size += customReason.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.FlagCommentRequest.Builder {
            return Present.FlagCommentRequest.classBuilder() as! Present.FlagCommentRequest.Builder
        }
        public func getBuilder() -> Present.FlagCommentRequest.Builder {
            return classBuilder() as! Present.FlagCommentRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FlagCommentRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FlagCommentRequest.Builder()
        }
        public func toBuilder() throws -> Present.FlagCommentRequest.Builder {
            return try Present.FlagCommentRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.FlagCommentRequest) throws -> Present.FlagCommentRequest.Builder {
            return try Present.FlagCommentRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCommentId {
                jsonMap["commentId"] = commentId
            }
            if hasReason {
                jsonMap["reason"] = reason.toString()
            }
            if hasCustomReason {
                jsonMap["customReason"] = customReason
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.FlagCommentRequest {
            return try Present.FlagCommentRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.FlagCommentRequest {
            return try Present.FlagCommentRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCommentId {
                output += "\(indent) commentId: \(commentId) \n"
            }
            if (hasReason) {
                output += "\(indent) reason: \(reason.description)\n"
            }
            if hasCustomReason {
                output += "\(indent) customReason: \(customReason) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCommentId {
                    hashCode = (hashCode &* 31) &+ commentId.hashValue
                }
                if hasReason {
                     hashCode = (hashCode &* 31) &+ reason.hashValue
                }
                if hasCustomReason {
                    hashCode = (hashCode &* 31) &+ customReason.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.FlagCommentRequest"
        }
        override public func className() -> String {
            return "Present.FlagCommentRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.FlagCommentRequest = Present.FlagCommentRequest()
            public func getMessage() -> Present.FlagCommentRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var commentId:String {
                get {
                    return builderResult.commentId
                }
                set (value) {
                    builderResult.hasCommentId = true
                    builderResult.commentId = value
                }
            }
            public var hasCommentId:Bool {
                get {
                    return builderResult.hasCommentId
                }
            }
            @discardableResult
            public func setCommentId(_ value:String) -> Present.FlagCommentRequest.Builder {
                self.commentId = value
                return self
            }
            @discardableResult
            public func clearCommentId() -> Present.FlagCommentRequest.Builder{
                builderResult.hasCommentId = false
                builderResult.commentId = ""
                return self
            }
                public var reason:Present.FlagReason {
                    get {
                        return builderResult.reason
                    }
                    set (value) {
                        builderResult.hasReason = true
                        builderResult.reason = value
                    }
                }
                public var hasReason:Bool{
                    get {
                        return builderResult.hasReason
                    }
                }
            @discardableResult
                public func setReason(_ value:Present.FlagReason) -> Present.FlagCommentRequest.Builder {
                  self.reason = value
                  return self
                }
            @discardableResult
                public func clearReason() -> Present.FlagCommentRequest.Builder {
                   builderResult.hasReason = false
                   builderResult.reason = .custom
                   return self
                }
            public var customReason:String {
                get {
                    return builderResult.customReason
                }
                set (value) {
                    builderResult.hasCustomReason = true
                    builderResult.customReason = value
                }
            }
            public var hasCustomReason:Bool {
                get {
                    return builderResult.hasCustomReason
                }
            }
            @discardableResult
            public func setCustomReason(_ value:String) -> Present.FlagCommentRequest.Builder {
                self.customReason = value
                return self
            }
            @discardableResult
            public func clearCustomReason() -> Present.FlagCommentRequest.Builder{
                builderResult.hasCustomReason = false
                builderResult.customReason = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.FlagCommentRequest.Builder {
                builderResult = Present.FlagCommentRequest()
                return self
            }
            override public func clone() throws -> Present.FlagCommentRequest.Builder {
                return try Present.FlagCommentRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.FlagCommentRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.FlagCommentRequest {
                let returnMe:Present.FlagCommentRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.FlagCommentRequest) throws -> Present.FlagCommentRequest.Builder {
                if other == Present.FlagCommentRequest() {
                    return self
                }
                if other.hasCommentId {
                    commentId = other.commentId
                }
                if other.hasReason {
                    reason = other.reason
                }
                if other.hasCustomReason {
                    customReason = other.customReason
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.FlagCommentRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FlagCommentRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        commentId = try codedInputStream.readString()

                    case 16:
                        let valueIntreason = try codedInputStream.readEnum()
                        if let enumsreason = Present.FlagReason(rawValue:valueIntreason){
                            reason = enumsreason
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntreason))
                        }

                    case 26:
                        customReason = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.FlagCommentRequest.Builder {
                let resultDecodedBuilder = Present.FlagCommentRequest.Builder()
                if let jsonValueCommentId = jsonMap["commentId"] as? String {
                    resultDecodedBuilder.commentId = jsonValueCommentId
                }
                if let jsonValueReason = jsonMap["reason"] as? String {
                    resultDecodedBuilder.reason = try Present.FlagReason.fromString(str: jsonValueReason)
                }
                if let jsonValueCustomReason = jsonMap["customReason"] as? String {
                    resultDecodedBuilder.customReason = jsonValueCustomReason
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.FlagCommentRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.FlagCommentRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DeleteGroupRequest : GeneratedMessage {

        public static func == (lhs: Present.DeleteGroupRequest, rhs: Present.DeleteGroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.DeleteGroupRequest.Builder {
            return Present.DeleteGroupRequest.classBuilder() as! Present.DeleteGroupRequest.Builder
        }
        public func getBuilder() -> Present.DeleteGroupRequest.Builder {
            return classBuilder() as! Present.DeleteGroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.DeleteGroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.DeleteGroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.DeleteGroupRequest.Builder {
            return try Present.DeleteGroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.DeleteGroupRequest) throws -> Present.DeleteGroupRequest.Builder {
            return try Present.DeleteGroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.DeleteGroupRequest {
            return try Present.DeleteGroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.DeleteGroupRequest {
            return try Present.DeleteGroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.DeleteGroupRequest"
        }
        override public func className() -> String {
            return "Present.DeleteGroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.DeleteGroupRequest = Present.DeleteGroupRequest()
            public func getMessage() -> Present.DeleteGroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.DeleteGroupRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.DeleteGroupRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.DeleteGroupRequest.Builder {
                builderResult = Present.DeleteGroupRequest()
                return self
            }
            override public func clone() throws -> Present.DeleteGroupRequest.Builder {
                return try Present.DeleteGroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.DeleteGroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.DeleteGroupRequest {
                let returnMe:Present.DeleteGroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.DeleteGroupRequest) throws -> Present.DeleteGroupRequest.Builder {
                if other == Present.DeleteGroupRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.DeleteGroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DeleteGroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.DeleteGroupRequest.Builder {
                let resultDecodedBuilder = Present.DeleteGroupRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.DeleteGroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.DeleteGroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DeleteCommentRequest : GeneratedMessage {

        public static func == (lhs: Present.DeleteCommentRequest, rhs: Present.DeleteCommentRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCommentId == rhs.hasCommentId) && (!lhs.hasCommentId || lhs.commentId == rhs.commentId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var commentId:String = ""
        public fileprivate(set) var hasCommentId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasCommentId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCommentId {
                try codedOutputStream.writeString(fieldNumber: 1, value:commentId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCommentId {
                serialize_size += commentId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.DeleteCommentRequest.Builder {
            return Present.DeleteCommentRequest.classBuilder() as! Present.DeleteCommentRequest.Builder
        }
        public func getBuilder() -> Present.DeleteCommentRequest.Builder {
            return classBuilder() as! Present.DeleteCommentRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.DeleteCommentRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.DeleteCommentRequest.Builder()
        }
        public func toBuilder() throws -> Present.DeleteCommentRequest.Builder {
            return try Present.DeleteCommentRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.DeleteCommentRequest) throws -> Present.DeleteCommentRequest.Builder {
            return try Present.DeleteCommentRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCommentId {
                jsonMap["commentId"] = commentId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.DeleteCommentRequest {
            return try Present.DeleteCommentRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.DeleteCommentRequest {
            return try Present.DeleteCommentRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCommentId {
                output += "\(indent) commentId: \(commentId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCommentId {
                    hashCode = (hashCode &* 31) &+ commentId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.DeleteCommentRequest"
        }
        override public func className() -> String {
            return "Present.DeleteCommentRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.DeleteCommentRequest = Present.DeleteCommentRequest()
            public func getMessage() -> Present.DeleteCommentRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var commentId:String {
                get {
                    return builderResult.commentId
                }
                set (value) {
                    builderResult.hasCommentId = true
                    builderResult.commentId = value
                }
            }
            public var hasCommentId:Bool {
                get {
                    return builderResult.hasCommentId
                }
            }
            @discardableResult
            public func setCommentId(_ value:String) -> Present.DeleteCommentRequest.Builder {
                self.commentId = value
                return self
            }
            @discardableResult
            public func clearCommentId() -> Present.DeleteCommentRequest.Builder{
                builderResult.hasCommentId = false
                builderResult.commentId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.DeleteCommentRequest.Builder {
                builderResult = Present.DeleteCommentRequest()
                return self
            }
            override public func clone() throws -> Present.DeleteCommentRequest.Builder {
                return try Present.DeleteCommentRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.DeleteCommentRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.DeleteCommentRequest {
                let returnMe:Present.DeleteCommentRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.DeleteCommentRequest) throws -> Present.DeleteCommentRequest.Builder {
                if other == Present.DeleteCommentRequest() {
                    return self
                }
                if other.hasCommentId {
                    commentId = other.commentId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.DeleteCommentRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DeleteCommentRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        commentId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.DeleteCommentRequest.Builder {
                let resultDecodedBuilder = Present.DeleteCommentRequest.Builder()
                if let jsonValueCommentId = jsonMap["commentId"] as? String {
                    resultDecodedBuilder.commentId = jsonValueCommentId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.DeleteCommentRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.DeleteCommentRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MuteGroupRequest : GeneratedMessage {

        public static func == (lhs: Present.MuteGroupRequest, rhs: Present.MuteGroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.MuteGroupRequest.Builder {
            return Present.MuteGroupRequest.classBuilder() as! Present.MuteGroupRequest.Builder
        }
        public func getBuilder() -> Present.MuteGroupRequest.Builder {
            return classBuilder() as! Present.MuteGroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MuteGroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MuteGroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.MuteGroupRequest.Builder {
            return try Present.MuteGroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.MuteGroupRequest) throws -> Present.MuteGroupRequest.Builder {
            return try Present.MuteGroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.MuteGroupRequest {
            return try Present.MuteGroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.MuteGroupRequest {
            return try Present.MuteGroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.MuteGroupRequest"
        }
        override public func className() -> String {
            return "Present.MuteGroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.MuteGroupRequest = Present.MuteGroupRequest()
            public func getMessage() -> Present.MuteGroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.MuteGroupRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.MuteGroupRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.MuteGroupRequest.Builder {
                builderResult = Present.MuteGroupRequest()
                return self
            }
            override public func clone() throws -> Present.MuteGroupRequest.Builder {
                return try Present.MuteGroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.MuteGroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.MuteGroupRequest {
                let returnMe:Present.MuteGroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.MuteGroupRequest) throws -> Present.MuteGroupRequest.Builder {
                if other == Present.MuteGroupRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.MuteGroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MuteGroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.MuteGroupRequest.Builder {
                let resultDecodedBuilder = Present.MuteGroupRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.MuteGroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.MuteGroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnmuteGroupRequest : GeneratedMessage {

        public static func == (lhs: Present.UnmuteGroupRequest, rhs: Present.UnmuteGroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.UnmuteGroupRequest.Builder {
            return Present.UnmuteGroupRequest.classBuilder() as! Present.UnmuteGroupRequest.Builder
        }
        public func getBuilder() -> Present.UnmuteGroupRequest.Builder {
            return classBuilder() as! Present.UnmuteGroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UnmuteGroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.UnmuteGroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.UnmuteGroupRequest.Builder {
            return try Present.UnmuteGroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.UnmuteGroupRequest) throws -> Present.UnmuteGroupRequest.Builder {
            return try Present.UnmuteGroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.UnmuteGroupRequest {
            return try Present.UnmuteGroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.UnmuteGroupRequest {
            return try Present.UnmuteGroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.UnmuteGroupRequest"
        }
        override public func className() -> String {
            return "Present.UnmuteGroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.UnmuteGroupRequest = Present.UnmuteGroupRequest()
            public func getMessage() -> Present.UnmuteGroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.UnmuteGroupRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.UnmuteGroupRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.UnmuteGroupRequest.Builder {
                builderResult = Present.UnmuteGroupRequest()
                return self
            }
            override public func clone() throws -> Present.UnmuteGroupRequest.Builder {
                return try Present.UnmuteGroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.UnmuteGroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.UnmuteGroupRequest {
                let returnMe:Present.UnmuteGroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.UnmuteGroupRequest) throws -> Present.UnmuteGroupRequest.Builder {
                if other == Present.UnmuteGroupRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.UnmuteGroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UnmuteGroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.UnmuteGroupRequest.Builder {
                let resultDecodedBuilder = Present.UnmuteGroupRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.UnmuteGroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.UnmuteGroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GroupMembersRequest : GeneratedMessage {

        public static func == (lhs: Present.GroupMembersRequest, rhs: Present.GroupMembersRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.GroupMembersRequest.Builder {
            return Present.GroupMembersRequest.classBuilder() as! Present.GroupMembersRequest.Builder
        }
        public func getBuilder() -> Present.GroupMembersRequest.Builder {
            return classBuilder() as! Present.GroupMembersRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupMembersRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupMembersRequest.Builder()
        }
        public func toBuilder() throws -> Present.GroupMembersRequest.Builder {
            return try Present.GroupMembersRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.GroupMembersRequest) throws -> Present.GroupMembersRequest.Builder {
            return try Present.GroupMembersRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.GroupMembersRequest {
            return try Present.GroupMembersRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.GroupMembersRequest {
            return try Present.GroupMembersRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.GroupMembersRequest"
        }
        override public func className() -> String {
            return "Present.GroupMembersRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.GroupMembersRequest = Present.GroupMembersRequest()
            public func getMessage() -> Present.GroupMembersRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.GroupMembersRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.GroupMembersRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.GroupMembersRequest.Builder {
                builderResult = Present.GroupMembersRequest()
                return self
            }
            override public func clone() throws -> Present.GroupMembersRequest.Builder {
                return try Present.GroupMembersRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.GroupMembersRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.GroupMembersRequest {
                let returnMe:Present.GroupMembersRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.GroupMembersRequest) throws -> Present.GroupMembersRequest.Builder {
                if other == Present.GroupMembersRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.GroupMembersRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupMembersRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.GroupMembersRequest.Builder {
                let resultDecodedBuilder = Present.GroupMembersRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.GroupMembersRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.GroupMembersRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GroupMembersResponse : GeneratedMessage {

        public static func == (lhs: Present.GroupMembersResponse, rhs: Present.GroupMembersResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.members == rhs.members)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var members:Array<Present.UserResponse>  = Array<Present.UserResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitMembers:Bool = true
            for oneElementMembers in members {
                if !oneElementMembers.isInitialized() {
                    isInitMembers = false
                    break 
                }
            }
            if !isInitMembers {
                return isInitMembers
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementMembers in members {
                  try codedOutputStream.writeMessage(fieldNumber: 15, value:oneElementMembers)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementMembers in members {
                serialize_size += oneElementMembers.computeMessageSize(fieldNumber: 15)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.GroupMembersResponse.Builder {
            return Present.GroupMembersResponse.classBuilder() as! Present.GroupMembersResponse.Builder
        }
        public func getBuilder() -> Present.GroupMembersResponse.Builder {
            return classBuilder() as! Present.GroupMembersResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupMembersResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupMembersResponse.Builder()
        }
        public func toBuilder() throws -> Present.GroupMembersResponse.Builder {
            return try Present.GroupMembersResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.GroupMembersResponse) throws -> Present.GroupMembersResponse.Builder {
            return try Present.GroupMembersResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !members.isEmpty {
                var jsonArrayMembers:Array<Dictionary<String,Any>> = []
                for oneValueMembers in members {
                    let ecodedMessageMembers = try oneValueMembers.encode()
                    jsonArrayMembers.append(ecodedMessageMembers)
                }
                jsonMap["members"] = jsonArrayMembers
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.GroupMembersResponse {
            return try Present.GroupMembersResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.GroupMembersResponse {
            return try Present.GroupMembersResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var membersElementIndex:Int = 0
            for oneElementMembers in members {
                output += "\(indent) members[\(membersElementIndex)] {\n"
                output += try oneElementMembers.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                membersElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementMembers in members {
                    hashCode = (hashCode &* 31) &+ oneElementMembers.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.GroupMembersResponse"
        }
        override public func className() -> String {
            return "Present.GroupMembersResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.GroupMembersResponse = Present.GroupMembersResponse()
            public func getMessage() -> Present.GroupMembersResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var members:Array<Present.UserResponse> {
                get {
                    return builderResult.members
                }
                set (value) {
                    builderResult.members = value
                }
            }
            @discardableResult
            public func setMembers(_ value:Array<Present.UserResponse>) -> Present.GroupMembersResponse.Builder {
                self.members = value
                return self
            }
            @discardableResult
            public func clearMembers() -> Present.GroupMembersResponse.Builder {
                builderResult.members.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.GroupMembersResponse.Builder {
                builderResult = Present.GroupMembersResponse()
                return self
            }
            override public func clone() throws -> Present.GroupMembersResponse.Builder {
                return try Present.GroupMembersResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.GroupMembersResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.GroupMembersResponse {
                let returnMe:Present.GroupMembersResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.GroupMembersResponse) throws -> Present.GroupMembersResponse.Builder {
                if other == Present.GroupMembersResponse() {
                    return self
                }
                if !other.members.isEmpty  {
                     builderResult.members += other.members
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.GroupMembersResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupMembersResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 122:
                        let subBuilder = Present.UserResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        members.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.GroupMembersResponse.Builder {
                let resultDecodedBuilder = Present.GroupMembersResponse.Builder()
                if let jsonValueMembers = jsonMap["members"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayMembers:Array<Present.UserResponse> = []
                    for oneValueMembers in jsonValueMembers {
                        let messageFromStringMembers = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:oneValueMembers).build()

                        jsonArrayMembers.append(messageFromStringMembers)
                    }
                    resultDecodedBuilder.members = jsonArrayMembers
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.GroupMembersResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.GroupMembersResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class AddGroupMembersRequest : GeneratedMessage {

        public static func == (lhs: Present.AddGroupMembersRequest, rhs: Present.AddGroupMembersRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.userIds == rhs.userIds)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var userIds:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            if !userIds.isEmpty {
                for oneValueuserIds in userIds {
                    try codedOutputStream.writeString(fieldNumber: 2, value:oneValueuserIds)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            var dataSizeUserIds:Int32 = 0
            for oneValueuserIds in userIds {
                dataSizeUserIds += oneValueuserIds.computeStringSizeNoTag()
            }
            serialize_size += dataSizeUserIds
            serialize_size += 1 * Int32(userIds.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.AddGroupMembersRequest.Builder {
            return Present.AddGroupMembersRequest.classBuilder() as! Present.AddGroupMembersRequest.Builder
        }
        public func getBuilder() -> Present.AddGroupMembersRequest.Builder {
            return classBuilder() as! Present.AddGroupMembersRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AddGroupMembersRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.AddGroupMembersRequest.Builder()
        }
        public func toBuilder() throws -> Present.AddGroupMembersRequest.Builder {
            return try Present.AddGroupMembersRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.AddGroupMembersRequest) throws -> Present.AddGroupMembersRequest.Builder {
            return try Present.AddGroupMembersRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if !userIds.isEmpty {
                var jsonArrayUserIds:Array<String> = []
                for oneValueUserIds in userIds {
                    jsonArrayUserIds.append(oneValueUserIds)
                }
                jsonMap["userIds"] = jsonArrayUserIds
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.AddGroupMembersRequest {
            return try Present.AddGroupMembersRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.AddGroupMembersRequest {
            return try Present.AddGroupMembersRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            var userIdsElementIndex:Int = 0
            for oneValueUserIds in userIds  {
                output += "\(indent) userIds[\(userIdsElementIndex)]: \(oneValueUserIds)\n"
                userIdsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                for oneValueUserIds in userIds {
                    hashCode = (hashCode &* 31) &+ oneValueUserIds.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.AddGroupMembersRequest"
        }
        override public func className() -> String {
            return "Present.AddGroupMembersRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.AddGroupMembersRequest = Present.AddGroupMembersRequest()
            public func getMessage() -> Present.AddGroupMembersRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.AddGroupMembersRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.AddGroupMembersRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            public var userIds:Array<String> {
                get {
                    return builderResult.userIds
                }
                set (array) {
                    builderResult.userIds = array
                }
            }
            @discardableResult
            public func setUserIds(_ value:Array<String>) -> Present.AddGroupMembersRequest.Builder {
                self.userIds = value
                return self
            }
            @discardableResult
            public func clearUserIds() -> Present.AddGroupMembersRequest.Builder {
                builderResult.userIds.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.AddGroupMembersRequest.Builder {
                builderResult = Present.AddGroupMembersRequest()
                return self
            }
            override public func clone() throws -> Present.AddGroupMembersRequest.Builder {
                return try Present.AddGroupMembersRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.AddGroupMembersRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.AddGroupMembersRequest {
                let returnMe:Present.AddGroupMembersRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.AddGroupMembersRequest) throws -> Present.AddGroupMembersRequest.Builder {
                if other == Present.AddGroupMembersRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if !other.userIds.isEmpty {
                    builderResult.userIds += other.userIds
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.AddGroupMembersRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddGroupMembersRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    case 18:
                        userIds += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.AddGroupMembersRequest.Builder {
                let resultDecodedBuilder = Present.AddGroupMembersRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueUserIds = jsonMap["userIds"] as? Array<String> {
                    var jsonArrayUserIds:Array<String> = []
                    for oneValueUserIds in jsonValueUserIds {
                        jsonArrayUserIds.append(oneValueUserIds)
                    }
                    resultDecodedBuilder.userIds = jsonArrayUserIds
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.AddGroupMembersRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.AddGroupMembersRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MembersRequest : GeneratedMessage {

        public static func == (lhs: Present.MembersRequest, rhs: Present.MembersRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.userIds == rhs.userIds)
            fieldCheck = fieldCheck && (lhs.phoneNumbers == rhs.phoneNumbers)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var userIds:Array<String> = Array<String>()
        public fileprivate(set) var phoneNumbers:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            if !userIds.isEmpty {
                for oneValueuserIds in userIds {
                    try codedOutputStream.writeString(fieldNumber: 2, value:oneValueuserIds)
                }
            }
            if !phoneNumbers.isEmpty {
                for oneValuephoneNumbers in phoneNumbers {
                    try codedOutputStream.writeString(fieldNumber: 3, value:oneValuephoneNumbers)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            var dataSizeUserIds:Int32 = 0
            for oneValueuserIds in userIds {
                dataSizeUserIds += oneValueuserIds.computeStringSizeNoTag()
            }
            serialize_size += dataSizeUserIds
            serialize_size += 1 * Int32(userIds.count)
            var dataSizePhoneNumbers:Int32 = 0
            for oneValuephoneNumbers in phoneNumbers {
                dataSizePhoneNumbers += oneValuephoneNumbers.computeStringSizeNoTag()
            }
            serialize_size += dataSizePhoneNumbers
            serialize_size += 1 * Int32(phoneNumbers.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.MembersRequest.Builder {
            return Present.MembersRequest.classBuilder() as! Present.MembersRequest.Builder
        }
        public func getBuilder() -> Present.MembersRequest.Builder {
            return classBuilder() as! Present.MembersRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MembersRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MembersRequest.Builder()
        }
        public func toBuilder() throws -> Present.MembersRequest.Builder {
            return try Present.MembersRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.MembersRequest) throws -> Present.MembersRequest.Builder {
            return try Present.MembersRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if !userIds.isEmpty {
                var jsonArrayUserIds:Array<String> = []
                for oneValueUserIds in userIds {
                    jsonArrayUserIds.append(oneValueUserIds)
                }
                jsonMap["userIds"] = jsonArrayUserIds
            }
            if !phoneNumbers.isEmpty {
                var jsonArrayPhoneNumbers:Array<String> = []
                for oneValuePhoneNumbers in phoneNumbers {
                    jsonArrayPhoneNumbers.append(oneValuePhoneNumbers)
                }
                jsonMap["phoneNumbers"] = jsonArrayPhoneNumbers
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.MembersRequest {
            return try Present.MembersRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.MembersRequest {
            return try Present.MembersRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            var userIdsElementIndex:Int = 0
            for oneValueUserIds in userIds  {
                output += "\(indent) userIds[\(userIdsElementIndex)]: \(oneValueUserIds)\n"
                userIdsElementIndex += 1
            }
            var phoneNumbersElementIndex:Int = 0
            for oneValuePhoneNumbers in phoneNumbers  {
                output += "\(indent) phoneNumbers[\(phoneNumbersElementIndex)]: \(oneValuePhoneNumbers)\n"
                phoneNumbersElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                for oneValueUserIds in userIds {
                    hashCode = (hashCode &* 31) &+ oneValueUserIds.hashValue
                }
                for oneValuePhoneNumbers in phoneNumbers {
                    hashCode = (hashCode &* 31) &+ oneValuePhoneNumbers.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.MembersRequest"
        }
        override public func className() -> String {
            return "Present.MembersRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.MembersRequest = Present.MembersRequest()
            public func getMessage() -> Present.MembersRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.MembersRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.MembersRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            public var userIds:Array<String> {
                get {
                    return builderResult.userIds
                }
                set (array) {
                    builderResult.userIds = array
                }
            }
            @discardableResult
            public func setUserIds(_ value:Array<String>) -> Present.MembersRequest.Builder {
                self.userIds = value
                return self
            }
            @discardableResult
            public func clearUserIds() -> Present.MembersRequest.Builder {
                builderResult.userIds.removeAll(keepingCapacity: false)
                return self
            }
            public var phoneNumbers:Array<String> {
                get {
                    return builderResult.phoneNumbers
                }
                set (array) {
                    builderResult.phoneNumbers = array
                }
            }
            @discardableResult
            public func setPhoneNumbers(_ value:Array<String>) -> Present.MembersRequest.Builder {
                self.phoneNumbers = value
                return self
            }
            @discardableResult
            public func clearPhoneNumbers() -> Present.MembersRequest.Builder {
                builderResult.phoneNumbers.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.MembersRequest.Builder {
                builderResult = Present.MembersRequest()
                return self
            }
            override public func clone() throws -> Present.MembersRequest.Builder {
                return try Present.MembersRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.MembersRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.MembersRequest {
                let returnMe:Present.MembersRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.MembersRequest) throws -> Present.MembersRequest.Builder {
                if other == Present.MembersRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if !other.userIds.isEmpty {
                    builderResult.userIds += other.userIds
                }
                if !other.phoneNumbers.isEmpty {
                    builderResult.phoneNumbers += other.phoneNumbers
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.MembersRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembersRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    case 18:
                        userIds += [try codedInputStream.readString()]

                    case 26:
                        phoneNumbers += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.MembersRequest.Builder {
                let resultDecodedBuilder = Present.MembersRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueUserIds = jsonMap["userIds"] as? Array<String> {
                    var jsonArrayUserIds:Array<String> = []
                    for oneValueUserIds in jsonValueUserIds {
                        jsonArrayUserIds.append(oneValueUserIds)
                    }
                    resultDecodedBuilder.userIds = jsonArrayUserIds
                }
                if let jsonValuePhoneNumbers = jsonMap["phoneNumbers"] as? Array<String> {
                    var jsonArrayPhoneNumbers:Array<String> = []
                    for oneValuePhoneNumbers in jsonValuePhoneNumbers {
                        jsonArrayPhoneNumbers.append(oneValuePhoneNumbers)
                    }
                    resultDecodedBuilder.phoneNumbers = jsonArrayPhoneNumbers
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.MembersRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.MembersRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MembershipRequestsRequest : GeneratedMessage {

        public static func == (lhs: Present.MembershipRequestsRequest, rhs: Present.MembershipRequestsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.MembershipRequestsRequest.Builder {
            return Present.MembershipRequestsRequest.classBuilder() as! Present.MembershipRequestsRequest.Builder
        }
        public func getBuilder() -> Present.MembershipRequestsRequest.Builder {
            return classBuilder() as! Present.MembershipRequestsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MembershipRequestsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MembershipRequestsRequest.Builder()
        }
        public func toBuilder() throws -> Present.MembershipRequestsRequest.Builder {
            return try Present.MembershipRequestsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.MembershipRequestsRequest) throws -> Present.MembershipRequestsRequest.Builder {
            return try Present.MembershipRequestsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.MembershipRequestsRequest {
            return try Present.MembershipRequestsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.MembershipRequestsRequest {
            return try Present.MembershipRequestsRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.MembershipRequestsRequest"
        }
        override public func className() -> String {
            return "Present.MembershipRequestsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.MembershipRequestsRequest = Present.MembershipRequestsRequest()
            public func getMessage() -> Present.MembershipRequestsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.MembershipRequestsRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.MembershipRequestsRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.MembershipRequestsRequest.Builder {
                builderResult = Present.MembershipRequestsRequest()
                return self
            }
            override public func clone() throws -> Present.MembershipRequestsRequest.Builder {
                return try Present.MembershipRequestsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.MembershipRequestsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.MembershipRequestsRequest {
                let returnMe:Present.MembershipRequestsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.MembershipRequestsRequest) throws -> Present.MembershipRequestsRequest.Builder {
                if other == Present.MembershipRequestsRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.MembershipRequestsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequestsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.MembershipRequestsRequest.Builder {
                let resultDecodedBuilder = Present.MembershipRequestsRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.MembershipRequestsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.MembershipRequestsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MembershipRequest : GeneratedMessage {

        public static func == (lhs: Present.MembershipRequest, rhs: Present.MembershipRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
            fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var user:Present.UserResponse!
        public fileprivate(set) var hasUser:Bool = false
        public fileprivate(set) var timestamp:UInt64 = UInt64(0)
        public fileprivate(set) var hasTimestamp:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUser {
                return false
            }
            if !hasTimestamp {
                return false
            }
            if !user.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUser {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:user)
            }
            if hasTimestamp {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:timestamp)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUser {
                if let varSizeuser = user?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeuser
                }
            }
            if hasTimestamp {
                serialize_size += timestamp.computeUInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.MembershipRequest.Builder {
            return Present.MembershipRequest.classBuilder() as! Present.MembershipRequest.Builder
        }
        public func getBuilder() -> Present.MembershipRequest.Builder {
            return classBuilder() as! Present.MembershipRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MembershipRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MembershipRequest.Builder()
        }
        public func toBuilder() throws -> Present.MembershipRequest.Builder {
            return try Present.MembershipRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.MembershipRequest) throws -> Present.MembershipRequest.Builder {
            return try Present.MembershipRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUser {
                jsonMap["user"] = try user.encode()
            }
            if hasTimestamp {
                jsonMap["timestamp"] = "\(timestamp)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.MembershipRequest {
            return try Present.MembershipRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.MembershipRequest {
            return try Present.MembershipRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUser {
                output += "\(indent) user {\n"
                if let outDescUser = user {
                    output += try outDescUser.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTimestamp {
                output += "\(indent) timestamp: \(timestamp) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUser {
                    if let hashValueuser = user?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuser
                    }
                }
                if hasTimestamp {
                    hashCode = (hashCode &* 31) &+ timestamp.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.MembershipRequest"
        }
        override public func className() -> String {
            return "Present.MembershipRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.MembershipRequest = Present.MembershipRequest()
            public func getMessage() -> Present.MembershipRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var user:Present.UserResponse! {
                get {
                    if userBuilder_ != nil {
                        builderResult.user = userBuilder_.getMessage()
                    }
                    return builderResult.user
                }
                set (value) {
                    builderResult.hasUser = true
                    builderResult.user = value
                }
            }
            public var hasUser:Bool {
                get {
                    return builderResult.hasUser
                }
            }
            fileprivate var userBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasUser = true
                }
            }
            public func getUserBuilder() -> Present.UserResponse.Builder {
                if userBuilder_ == nil {
                    userBuilder_ = Present.UserResponse.Builder()
                    builderResult.user = userBuilder_.getMessage()
                    if user != nil {
                        try! userBuilder_.mergeFrom(other: user)
                    }
                }
                return userBuilder_
            }
            @discardableResult
            public func setUser(_ value:Present.UserResponse!) -> Present.MembershipRequest.Builder {
                self.user = value
                return self
            }
            @discardableResult
            public func mergeUser(value:Present.UserResponse) throws -> Present.MembershipRequest.Builder {
                if builderResult.hasUser {
                    builderResult.user = try Present.UserResponse.builderWithPrototype(prototype:builderResult.user).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.user = value
                }
                builderResult.hasUser = true
                return self
            }
            @discardableResult
            public func clearUser() -> Present.MembershipRequest.Builder {
                userBuilder_ = nil
                builderResult.hasUser = false
                builderResult.user = nil
                return self
            }
            public var timestamp:UInt64 {
                get {
                    return builderResult.timestamp
                }
                set (value) {
                    builderResult.hasTimestamp = true
                    builderResult.timestamp = value
                }
            }
            public var hasTimestamp:Bool {
                get {
                    return builderResult.hasTimestamp
                }
            }
            @discardableResult
            public func setTimestamp(_ value:UInt64) -> Present.MembershipRequest.Builder {
                self.timestamp = value
                return self
            }
            @discardableResult
            public func clearTimestamp() -> Present.MembershipRequest.Builder{
                builderResult.hasTimestamp = false
                builderResult.timestamp = UInt64(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.MembershipRequest.Builder {
                builderResult = Present.MembershipRequest()
                return self
            }
            override public func clone() throws -> Present.MembershipRequest.Builder {
                return try Present.MembershipRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.MembershipRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.MembershipRequest {
                let returnMe:Present.MembershipRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.MembershipRequest) throws -> Present.MembershipRequest.Builder {
                if other == Present.MembershipRequest() {
                    return self
                }
                if (other.hasUser) {
                    try mergeUser(value: other.user)
                }
                if other.hasTimestamp {
                    timestamp = other.timestamp
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.MembershipRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasUser {
                            try subBuilder.mergeFrom(other: user)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        user = subBuilder.buildPartial()

                    case 16:
                        timestamp = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.MembershipRequest.Builder {
                let resultDecodedBuilder = Present.MembershipRequest.Builder()
                if let jsonValueUser = jsonMap["user"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.user = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueUser).build()

                }
                if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
                } else if let jsonValueTimestamp = jsonMap["timestamp"] as? UInt {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.MembershipRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.MembershipRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MembershipRequestsResponse : GeneratedMessage {

        public static func == (lhs: Present.MembershipRequestsResponse, rhs: Present.MembershipRequestsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.requests == rhs.requests)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var requests:Array<Present.MembershipRequest>  = Array<Present.MembershipRequest>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitRequests:Bool = true
            for oneElementRequests in requests {
                if !oneElementRequests.isInitialized() {
                    isInitRequests = false
                    break 
                }
            }
            if !isInitRequests {
                return isInitRequests
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementRequests in requests {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementRequests)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementRequests in requests {
                serialize_size += oneElementRequests.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.MembershipRequestsResponse.Builder {
            return Present.MembershipRequestsResponse.classBuilder() as! Present.MembershipRequestsResponse.Builder
        }
        public func getBuilder() -> Present.MembershipRequestsResponse.Builder {
            return classBuilder() as! Present.MembershipRequestsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MembershipRequestsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MembershipRequestsResponse.Builder()
        }
        public func toBuilder() throws -> Present.MembershipRequestsResponse.Builder {
            return try Present.MembershipRequestsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.MembershipRequestsResponse) throws -> Present.MembershipRequestsResponse.Builder {
            return try Present.MembershipRequestsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !requests.isEmpty {
                var jsonArrayRequests:Array<Dictionary<String,Any>> = []
                for oneValueRequests in requests {
                    let ecodedMessageRequests = try oneValueRequests.encode()
                    jsonArrayRequests.append(ecodedMessageRequests)
                }
                jsonMap["requests"] = jsonArrayRequests
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.MembershipRequestsResponse {
            return try Present.MembershipRequestsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.MembershipRequestsResponse {
            return try Present.MembershipRequestsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var requestsElementIndex:Int = 0
            for oneElementRequests in requests {
                output += "\(indent) requests[\(requestsElementIndex)] {\n"
                output += try oneElementRequests.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                requestsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementRequests in requests {
                    hashCode = (hashCode &* 31) &+ oneElementRequests.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.MembershipRequestsResponse"
        }
        override public func className() -> String {
            return "Present.MembershipRequestsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.MembershipRequestsResponse = Present.MembershipRequestsResponse()
            public func getMessage() -> Present.MembershipRequestsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var requests:Array<Present.MembershipRequest> {
                get {
                    return builderResult.requests
                }
                set (value) {
                    builderResult.requests = value
                }
            }
            @discardableResult
            public func setRequests(_ value:Array<Present.MembershipRequest>) -> Present.MembershipRequestsResponse.Builder {
                self.requests = value
                return self
            }
            @discardableResult
            public func clearRequests() -> Present.MembershipRequestsResponse.Builder {
                builderResult.requests.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.MembershipRequestsResponse.Builder {
                builderResult = Present.MembershipRequestsResponse()
                return self
            }
            override public func clone() throws -> Present.MembershipRequestsResponse.Builder {
                return try Present.MembershipRequestsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.MembershipRequestsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.MembershipRequestsResponse {
                let returnMe:Present.MembershipRequestsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.MembershipRequestsResponse) throws -> Present.MembershipRequestsResponse.Builder {
                if other == Present.MembershipRequestsResponse() {
                    return self
                }
                if !other.requests.isEmpty  {
                     builderResult.requests += other.requests
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.MembershipRequestsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequestsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.MembershipRequest.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        requests.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.MembershipRequestsResponse.Builder {
                let resultDecodedBuilder = Present.MembershipRequestsResponse.Builder()
                if let jsonValueRequests = jsonMap["requests"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayRequests:Array<Present.MembershipRequest> = []
                    for oneValueRequests in jsonValueRequests {
                        let messageFromStringRequests = try Present.MembershipRequest.Builder.decodeToBuilder(jsonMap:oneValueRequests).build()

                        jsonArrayRequests.append(messageFromStringRequests)
                    }
                    resultDecodedBuilder.requests = jsonArrayRequests
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.MembershipRequestsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.MembershipRequestsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class InviteFriendsRequest : GeneratedMessage {

        public static func == (lhs: Present.InviteFriendsRequest, rhs: Present.InviteFriendsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.userIds == rhs.userIds)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var userIds:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            if !userIds.isEmpty {
                for oneValueuserIds in userIds {
                    try codedOutputStream.writeString(fieldNumber: 2, value:oneValueuserIds)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            var dataSizeUserIds:Int32 = 0
            for oneValueuserIds in userIds {
                dataSizeUserIds += oneValueuserIds.computeStringSizeNoTag()
            }
            serialize_size += dataSizeUserIds
            serialize_size += 1 * Int32(userIds.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.InviteFriendsRequest.Builder {
            return Present.InviteFriendsRequest.classBuilder() as! Present.InviteFriendsRequest.Builder
        }
        public func getBuilder() -> Present.InviteFriendsRequest.Builder {
            return classBuilder() as! Present.InviteFriendsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.InviteFriendsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.InviteFriendsRequest.Builder()
        }
        public func toBuilder() throws -> Present.InviteFriendsRequest.Builder {
            return try Present.InviteFriendsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.InviteFriendsRequest) throws -> Present.InviteFriendsRequest.Builder {
            return try Present.InviteFriendsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if !userIds.isEmpty {
                var jsonArrayUserIds:Array<String> = []
                for oneValueUserIds in userIds {
                    jsonArrayUserIds.append(oneValueUserIds)
                }
                jsonMap["userIds"] = jsonArrayUserIds
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.InviteFriendsRequest {
            return try Present.InviteFriendsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.InviteFriendsRequest {
            return try Present.InviteFriendsRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            var userIdsElementIndex:Int = 0
            for oneValueUserIds in userIds  {
                output += "\(indent) userIds[\(userIdsElementIndex)]: \(oneValueUserIds)\n"
                userIdsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                for oneValueUserIds in userIds {
                    hashCode = (hashCode &* 31) &+ oneValueUserIds.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.InviteFriendsRequest"
        }
        override public func className() -> String {
            return "Present.InviteFriendsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.InviteFriendsRequest = Present.InviteFriendsRequest()
            public func getMessage() -> Present.InviteFriendsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.InviteFriendsRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.InviteFriendsRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            public var userIds:Array<String> {
                get {
                    return builderResult.userIds
                }
                set (array) {
                    builderResult.userIds = array
                }
            }
            @discardableResult
            public func setUserIds(_ value:Array<String>) -> Present.InviteFriendsRequest.Builder {
                self.userIds = value
                return self
            }
            @discardableResult
            public func clearUserIds() -> Present.InviteFriendsRequest.Builder {
                builderResult.userIds.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.InviteFriendsRequest.Builder {
                builderResult = Present.InviteFriendsRequest()
                return self
            }
            override public func clone() throws -> Present.InviteFriendsRequest.Builder {
                return try Present.InviteFriendsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.InviteFriendsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.InviteFriendsRequest {
                let returnMe:Present.InviteFriendsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.InviteFriendsRequest) throws -> Present.InviteFriendsRequest.Builder {
                if other == Present.InviteFriendsRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if !other.userIds.isEmpty {
                    builderResult.userIds += other.userIds
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.InviteFriendsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.InviteFriendsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    case 18:
                        userIds += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.InviteFriendsRequest.Builder {
                let resultDecodedBuilder = Present.InviteFriendsRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueUserIds = jsonMap["userIds"] as? Array<String> {
                    var jsonArrayUserIds:Array<String> = []
                    for oneValueUserIds in jsonValueUserIds {
                        jsonArrayUserIds.append(oneValueUserIds)
                    }
                    resultDecodedBuilder.userIds = jsonArrayUserIds
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.InviteFriendsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.InviteFriendsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MarkReadRequest : GeneratedMessage {

        public static func == (lhs: Present.MarkReadRequest, rhs: Present.MarkReadRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasLastRead == rhs.hasLastRead) && (!lhs.hasLastRead || lhs.lastRead == rhs.lastRead)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        /// Index of the last comment read, from CommentResponse.index, or -1 if the group contains no
        /// comments.
        public fileprivate(set) var lastRead:Int32 = Int32(0)
        public fileprivate(set) var hasLastRead:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            if !hasLastRead {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            if hasLastRead {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:lastRead)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            if hasLastRead {
                serialize_size += lastRead.computeInt32Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.MarkReadRequest.Builder {
            return Present.MarkReadRequest.classBuilder() as! Present.MarkReadRequest.Builder
        }
        public func getBuilder() -> Present.MarkReadRequest.Builder {
            return classBuilder() as! Present.MarkReadRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MarkReadRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MarkReadRequest.Builder()
        }
        public func toBuilder() throws -> Present.MarkReadRequest.Builder {
            return try Present.MarkReadRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.MarkReadRequest) throws -> Present.MarkReadRequest.Builder {
            return try Present.MarkReadRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if hasLastRead {
                jsonMap["lastRead"] = Int(lastRead)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.MarkReadRequest {
            return try Present.MarkReadRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.MarkReadRequest {
            return try Present.MarkReadRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasLastRead {
                output += "\(indent) lastRead: \(lastRead) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasLastRead {
                    hashCode = (hashCode &* 31) &+ lastRead.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.MarkReadRequest"
        }
        override public func className() -> String {
            return "Present.MarkReadRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.MarkReadRequest = Present.MarkReadRequest()
            public func getMessage() -> Present.MarkReadRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.MarkReadRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.MarkReadRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            /// Index of the last comment read, from CommentResponse.index, or -1 if the group contains no
            /// comments.
            public var lastRead:Int32 {
                get {
                    return builderResult.lastRead
                }
                set (value) {
                    builderResult.hasLastRead = true
                    builderResult.lastRead = value
                }
            }
            public var hasLastRead:Bool {
                get {
                    return builderResult.hasLastRead
                }
            }
            @discardableResult
            public func setLastRead(_ value:Int32) -> Present.MarkReadRequest.Builder {
                self.lastRead = value
                return self
            }
            @discardableResult
            public func clearLastRead() -> Present.MarkReadRequest.Builder{
                builderResult.hasLastRead = false
                builderResult.lastRead = Int32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.MarkReadRequest.Builder {
                builderResult = Present.MarkReadRequest()
                return self
            }
            override public func clone() throws -> Present.MarkReadRequest.Builder {
                return try Present.MarkReadRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.MarkReadRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.MarkReadRequest {
                let returnMe:Present.MarkReadRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.MarkReadRequest) throws -> Present.MarkReadRequest.Builder {
                if other == Present.MarkReadRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasLastRead {
                    lastRead = other.lastRead
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.MarkReadRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MarkReadRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    case 24:
                        lastRead = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.MarkReadRequest.Builder {
                let resultDecodedBuilder = Present.MarkReadRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueLastRead = jsonMap["lastRead"] as? Int {
                    resultDecodedBuilder.lastRead = Int32(jsonValueLastRead)
                } else if let jsonValueLastRead = jsonMap["lastRead"] as? String {
                    resultDecodedBuilder.lastRead = Int32(jsonValueLastRead)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.MarkReadRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.MarkReadRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Deprecated. Use GroupResponse.muted instead.
    final public class MutedGroupsResponse : GeneratedMessage {

        public static func == (lhs: Present.MutedGroupsResponse, rhs: Present.MutedGroupsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.groupIds == rhs.groupIds)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupIds:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !groupIds.isEmpty {
                for oneValuegroupIds in groupIds {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuegroupIds)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeGroupIds:Int32 = 0
            for oneValuegroupIds in groupIds {
                dataSizeGroupIds += oneValuegroupIds.computeStringSizeNoTag()
            }
            serialize_size += dataSizeGroupIds
            serialize_size += 1 * Int32(groupIds.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.MutedGroupsResponse.Builder {
            return Present.MutedGroupsResponse.classBuilder() as! Present.MutedGroupsResponse.Builder
        }
        public func getBuilder() -> Present.MutedGroupsResponse.Builder {
            return classBuilder() as! Present.MutedGroupsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MutedGroupsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.MutedGroupsResponse.Builder()
        }
        public func toBuilder() throws -> Present.MutedGroupsResponse.Builder {
            return try Present.MutedGroupsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.MutedGroupsResponse) throws -> Present.MutedGroupsResponse.Builder {
            return try Present.MutedGroupsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !groupIds.isEmpty {
                var jsonArrayGroupIds:Array<String> = []
                for oneValueGroupIds in groupIds {
                    jsonArrayGroupIds.append(oneValueGroupIds)
                }
                jsonMap["groupIds"] = jsonArrayGroupIds
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.MutedGroupsResponse {
            return try Present.MutedGroupsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.MutedGroupsResponse {
            return try Present.MutedGroupsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var groupIdsElementIndex:Int = 0
            for oneValueGroupIds in groupIds  {
                output += "\(indent) groupIds[\(groupIdsElementIndex)]: \(oneValueGroupIds)\n"
                groupIdsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueGroupIds in groupIds {
                    hashCode = (hashCode &* 31) &+ oneValueGroupIds.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.MutedGroupsResponse"
        }
        override public func className() -> String {
            return "Present.MutedGroupsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.MutedGroupsResponse = Present.MutedGroupsResponse()
            public func getMessage() -> Present.MutedGroupsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupIds:Array<String> {
                get {
                    return builderResult.groupIds
                }
                set (array) {
                    builderResult.groupIds = array
                }
            }
            @discardableResult
            public func setGroupIds(_ value:Array<String>) -> Present.MutedGroupsResponse.Builder {
                self.groupIds = value
                return self
            }
            @discardableResult
            public func clearGroupIds() -> Present.MutedGroupsResponse.Builder {
                builderResult.groupIds.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.MutedGroupsResponse.Builder {
                builderResult = Present.MutedGroupsResponse()
                return self
            }
            override public func clone() throws -> Present.MutedGroupsResponse.Builder {
                return try Present.MutedGroupsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.MutedGroupsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.MutedGroupsResponse {
                let returnMe:Present.MutedGroupsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.MutedGroupsResponse) throws -> Present.MutedGroupsResponse.Builder {
                if other == Present.MutedGroupsResponse() {
                    return self
                }
                if !other.groupIds.isEmpty {
                    builderResult.groupIds += other.groupIds
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.MutedGroupsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MutedGroupsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupIds += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.MutedGroupsResponse.Builder {
                let resultDecodedBuilder = Present.MutedGroupsResponse.Builder()
                if let jsonValueGroupIds = jsonMap["groupIds"] as? Array<String> {
                    var jsonArrayGroupIds:Array<String> = []
                    for oneValueGroupIds in jsonValueGroupIds {
                        jsonArrayGroupIds.append(oneValueGroupIds)
                    }
                    resultDecodedBuilder.groupIds = jsonArrayGroupIds
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.MutedGroupsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.MutedGroupsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Defines a group and user referred by the current user.
    final public class GroupReferralResponse : GeneratedMessage {

        public static func == (lhs: Present.GroupReferralResponse, rhs: Present.GroupReferralResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
            fieldCheck = fieldCheck && (lhs.hasGroup == rhs.hasGroup) && (!lhs.hasGroup || lhs.group == rhs.group)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var user:Present.UserResponse!
        public fileprivate(set) var hasUser:Bool = false
        public fileprivate(set) var group:Present.GroupResponse!
        public fileprivate(set) var hasGroup:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUser {
                return false
            }
            if !hasGroup {
                return false
            }
            if !user.isInitialized() {
                return false
            }
            if !group.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUser {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:user)
            }
            if hasGroup {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:group)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUser {
                if let varSizeuser = user?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeuser
                }
            }
            if hasGroup {
                if let varSizegroup = group?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizegroup
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.GroupReferralResponse.Builder {
            return Present.GroupReferralResponse.classBuilder() as! Present.GroupReferralResponse.Builder
        }
        public func getBuilder() -> Present.GroupReferralResponse.Builder {
            return classBuilder() as! Present.GroupReferralResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupReferralResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupReferralResponse.Builder()
        }
        public func toBuilder() throws -> Present.GroupReferralResponse.Builder {
            return try Present.GroupReferralResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.GroupReferralResponse) throws -> Present.GroupReferralResponse.Builder {
            return try Present.GroupReferralResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUser {
                jsonMap["user"] = try user.encode()
            }
            if hasGroup {
                jsonMap["group"] = try group.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.GroupReferralResponse {
            return try Present.GroupReferralResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.GroupReferralResponse {
            return try Present.GroupReferralResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUser {
                output += "\(indent) user {\n"
                if let outDescUser = user {
                    output += try outDescUser.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasGroup {
                output += "\(indent) group {\n"
                if let outDescGroup = group {
                    output += try outDescGroup.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUser {
                    if let hashValueuser = user?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuser
                    }
                }
                if hasGroup {
                    if let hashValuegroup = group?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegroup
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.GroupReferralResponse"
        }
        override public func className() -> String {
            return "Present.GroupReferralResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.GroupReferralResponse = Present.GroupReferralResponse()
            public func getMessage() -> Present.GroupReferralResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var user:Present.UserResponse! {
                get {
                    if userBuilder_ != nil {
                        builderResult.user = userBuilder_.getMessage()
                    }
                    return builderResult.user
                }
                set (value) {
                    builderResult.hasUser = true
                    builderResult.user = value
                }
            }
            public var hasUser:Bool {
                get {
                    return builderResult.hasUser
                }
            }
            fileprivate var userBuilder_:Present.UserResponse.Builder! {
                didSet {
                    builderResult.hasUser = true
                }
            }
            public func getUserBuilder() -> Present.UserResponse.Builder {
                if userBuilder_ == nil {
                    userBuilder_ = Present.UserResponse.Builder()
                    builderResult.user = userBuilder_.getMessage()
                    if user != nil {
                        try! userBuilder_.mergeFrom(other: user)
                    }
                }
                return userBuilder_
            }
            @discardableResult
            public func setUser(_ value:Present.UserResponse!) -> Present.GroupReferralResponse.Builder {
                self.user = value
                return self
            }
            @discardableResult
            public func mergeUser(value:Present.UserResponse) throws -> Present.GroupReferralResponse.Builder {
                if builderResult.hasUser {
                    builderResult.user = try Present.UserResponse.builderWithPrototype(prototype:builderResult.user).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.user = value
                }
                builderResult.hasUser = true
                return self
            }
            @discardableResult
            public func clearUser() -> Present.GroupReferralResponse.Builder {
                userBuilder_ = nil
                builderResult.hasUser = false
                builderResult.user = nil
                return self
            }
            public var group:Present.GroupResponse! {
                get {
                    if groupBuilder_ != nil {
                        builderResult.group = groupBuilder_.getMessage()
                    }
                    return builderResult.group
                }
                set (value) {
                    builderResult.hasGroup = true
                    builderResult.group = value
                }
            }
            public var hasGroup:Bool {
                get {
                    return builderResult.hasGroup
                }
            }
            fileprivate var groupBuilder_:Present.GroupResponse.Builder! {
                didSet {
                    builderResult.hasGroup = true
                }
            }
            public func getGroupBuilder() -> Present.GroupResponse.Builder {
                if groupBuilder_ == nil {
                    groupBuilder_ = Present.GroupResponse.Builder()
                    builderResult.group = groupBuilder_.getMessage()
                    if group != nil {
                        try! groupBuilder_.mergeFrom(other: group)
                    }
                }
                return groupBuilder_
            }
            @discardableResult
            public func setGroup(_ value:Present.GroupResponse!) -> Present.GroupReferralResponse.Builder {
                self.group = value
                return self
            }
            @discardableResult
            public func mergeGroup(value:Present.GroupResponse) throws -> Present.GroupReferralResponse.Builder {
                if builderResult.hasGroup {
                    builderResult.group = try Present.GroupResponse.builderWithPrototype(prototype:builderResult.group).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.group = value
                }
                builderResult.hasGroup = true
                return self
            }
            @discardableResult
            public func clearGroup() -> Present.GroupReferralResponse.Builder {
                groupBuilder_ = nil
                builderResult.hasGroup = false
                builderResult.group = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.GroupReferralResponse.Builder {
                builderResult = Present.GroupReferralResponse()
                return self
            }
            override public func clone() throws -> Present.GroupReferralResponse.Builder {
                return try Present.GroupReferralResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.GroupReferralResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.GroupReferralResponse {
                let returnMe:Present.GroupReferralResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.GroupReferralResponse) throws -> Present.GroupReferralResponse.Builder {
                if other == Present.GroupReferralResponse() {
                    return self
                }
                if (other.hasUser) {
                    try mergeUser(value: other.user)
                }
                if (other.hasGroup) {
                    try mergeGroup(value: other.group)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.GroupReferralResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupReferralResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.UserResponse.Builder = Present.UserResponse.Builder()
                        if hasUser {
                            try subBuilder.mergeFrom(other: user)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        user = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Present.GroupResponse.Builder = Present.GroupResponse.Builder()
                        if hasGroup {
                            try subBuilder.mergeFrom(other: group)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        group = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.GroupReferralResponse.Builder {
                let resultDecodedBuilder = Present.GroupReferralResponse.Builder()
                if let jsonValueUser = jsonMap["user"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.user = try Present.UserResponse.Builder.decodeToBuilder(jsonMap:jsonValueUser).build()

                }
                if let jsonValueGroup = jsonMap["group"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.group = try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:jsonValueGroup).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.GroupReferralResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.GroupReferralResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GroupReferralsResponse : GeneratedMessage {

        public static func == (lhs: Present.GroupReferralsResponse, rhs: Present.GroupReferralsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.referrals == rhs.referrals)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var referrals:Array<Present.GroupReferralResponse>  = Array<Present.GroupReferralResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitReferrals:Bool = true
            for oneElementReferrals in referrals {
                if !oneElementReferrals.isInitialized() {
                    isInitReferrals = false
                    break 
                }
            }
            if !isInitReferrals {
                return isInitReferrals
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementReferrals in referrals {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementReferrals)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementReferrals in referrals {
                serialize_size += oneElementReferrals.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.GroupReferralsResponse.Builder {
            return Present.GroupReferralsResponse.classBuilder() as! Present.GroupReferralsResponse.Builder
        }
        public func getBuilder() -> Present.GroupReferralsResponse.Builder {
            return classBuilder() as! Present.GroupReferralsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupReferralsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupReferralsResponse.Builder()
        }
        public func toBuilder() throws -> Present.GroupReferralsResponse.Builder {
            return try Present.GroupReferralsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.GroupReferralsResponse) throws -> Present.GroupReferralsResponse.Builder {
            return try Present.GroupReferralsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !referrals.isEmpty {
                var jsonArrayReferrals:Array<Dictionary<String,Any>> = []
                for oneValueReferrals in referrals {
                    let ecodedMessageReferrals = try oneValueReferrals.encode()
                    jsonArrayReferrals.append(ecodedMessageReferrals)
                }
                jsonMap["referrals"] = jsonArrayReferrals
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.GroupReferralsResponse {
            return try Present.GroupReferralsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.GroupReferralsResponse {
            return try Present.GroupReferralsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var referralsElementIndex:Int = 0
            for oneElementReferrals in referrals {
                output += "\(indent) referrals[\(referralsElementIndex)] {\n"
                output += try oneElementReferrals.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                referralsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementReferrals in referrals {
                    hashCode = (hashCode &* 31) &+ oneElementReferrals.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.GroupReferralsResponse"
        }
        override public func className() -> String {
            return "Present.GroupReferralsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.GroupReferralsResponse = Present.GroupReferralsResponse()
            public func getMessage() -> Present.GroupReferralsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var referrals:Array<Present.GroupReferralResponse> {
                get {
                    return builderResult.referrals
                }
                set (value) {
                    builderResult.referrals = value
                }
            }
            @discardableResult
            public func setReferrals(_ value:Array<Present.GroupReferralResponse>) -> Present.GroupReferralsResponse.Builder {
                self.referrals = value
                return self
            }
            @discardableResult
            public func clearReferrals() -> Present.GroupReferralsResponse.Builder {
                builderResult.referrals.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.GroupReferralsResponse.Builder {
                builderResult = Present.GroupReferralsResponse()
                return self
            }
            override public func clone() throws -> Present.GroupReferralsResponse.Builder {
                return try Present.GroupReferralsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.GroupReferralsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.GroupReferralsResponse {
                let returnMe:Present.GroupReferralsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.GroupReferralsResponse) throws -> Present.GroupReferralsResponse.Builder {
                if other == Present.GroupReferralsResponse() {
                    return self
                }
                if !other.referrals.isEmpty  {
                     builderResult.referrals += other.referrals
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.GroupReferralsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupReferralsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.GroupReferralResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        referrals.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.GroupReferralsResponse.Builder {
                let resultDecodedBuilder = Present.GroupReferralsResponse.Builder()
                if let jsonValueReferrals = jsonMap["referrals"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayReferrals:Array<Present.GroupReferralResponse> = []
                    for oneValueReferrals in jsonValueReferrals {
                        let messageFromStringReferrals = try Present.GroupReferralResponse.Builder.decodeToBuilder(jsonMap:oneValueReferrals).build()

                        jsonArrayReferrals.append(messageFromStringReferrals)
                    }
                    resultDecodedBuilder.referrals = jsonArrayReferrals
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.GroupReferralsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.GroupReferralsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CountGroupReferralsResponse : GeneratedMessage {

        public static func == (lhs: Present.CountGroupReferralsResponse, rhs: Present.CountGroupReferralsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMembersReferred == rhs.hasMembersReferred) && (!lhs.hasMembersReferred || lhs.membersReferred == rhs.membersReferred)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var membersReferred:UInt32 = UInt32(0)
        public fileprivate(set) var hasMembersReferred:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasMembersReferred {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMembersReferred {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:membersReferred)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMembersReferred {
                serialize_size += membersReferred.computeUInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.CountGroupReferralsResponse.Builder {
            return Present.CountGroupReferralsResponse.classBuilder() as! Present.CountGroupReferralsResponse.Builder
        }
        public func getBuilder() -> Present.CountGroupReferralsResponse.Builder {
            return classBuilder() as! Present.CountGroupReferralsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CountGroupReferralsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CountGroupReferralsResponse.Builder()
        }
        public func toBuilder() throws -> Present.CountGroupReferralsResponse.Builder {
            return try Present.CountGroupReferralsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.CountGroupReferralsResponse) throws -> Present.CountGroupReferralsResponse.Builder {
            return try Present.CountGroupReferralsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMembersReferred {
                jsonMap["membersReferred"] = UInt(membersReferred)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.CountGroupReferralsResponse {
            return try Present.CountGroupReferralsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.CountGroupReferralsResponse {
            return try Present.CountGroupReferralsResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMembersReferred {
                output += "\(indent) membersReferred: \(membersReferred) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMembersReferred {
                    hashCode = (hashCode &* 31) &+ membersReferred.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.CountGroupReferralsResponse"
        }
        override public func className() -> String {
            return "Present.CountGroupReferralsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.CountGroupReferralsResponse = Present.CountGroupReferralsResponse()
            public func getMessage() -> Present.CountGroupReferralsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var membersReferred:UInt32 {
                get {
                    return builderResult.membersReferred
                }
                set (value) {
                    builderResult.hasMembersReferred = true
                    builderResult.membersReferred = value
                }
            }
            public var hasMembersReferred:Bool {
                get {
                    return builderResult.hasMembersReferred
                }
            }
            @discardableResult
            public func setMembersReferred(_ value:UInt32) -> Present.CountGroupReferralsResponse.Builder {
                self.membersReferred = value
                return self
            }
            @discardableResult
            public func clearMembersReferred() -> Present.CountGroupReferralsResponse.Builder{
                builderResult.hasMembersReferred = false
                builderResult.membersReferred = UInt32(0)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.CountGroupReferralsResponse.Builder {
                builderResult = Present.CountGroupReferralsResponse()
                return self
            }
            override public func clone() throws -> Present.CountGroupReferralsResponse.Builder {
                return try Present.CountGroupReferralsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.CountGroupReferralsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.CountGroupReferralsResponse {
                let returnMe:Present.CountGroupReferralsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.CountGroupReferralsResponse) throws -> Present.CountGroupReferralsResponse.Builder {
                if other == Present.CountGroupReferralsResponse() {
                    return self
                }
                if other.hasMembersReferred {
                    membersReferred = other.membersReferred
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.CountGroupReferralsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CountGroupReferralsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        membersReferred = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.CountGroupReferralsResponse.Builder {
                let resultDecodedBuilder = Present.CountGroupReferralsResponse.Builder()
                if let jsonValueMembersReferred = jsonMap["membersReferred"] as? UInt {
                    resultDecodedBuilder.membersReferred = UInt32(jsonValueMembersReferred)
                } else if let jsonValueMembersReferred = jsonMap["membersReferred"] as? String {
                    resultDecodedBuilder.membersReferred = UInt32(jsonValueMembersReferred)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.CountGroupReferralsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.CountGroupReferralsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CitiesResponse : GeneratedMessage {

        public static func == (lhs: Present.CitiesResponse, rhs: Present.CitiesResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.cities == rhs.cities)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var cities:Array<Present.City>  = Array<Present.City>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitCities:Bool = true
            for oneElementCities in cities {
                if !oneElementCities.isInitialized() {
                    isInitCities = false
                    break 
                }
            }
            if !isInitCities {
                return isInitCities
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementCities in cities {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementCities)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementCities in cities {
                serialize_size += oneElementCities.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.CitiesResponse.Builder {
            return Present.CitiesResponse.classBuilder() as! Present.CitiesResponse.Builder
        }
        public func getBuilder() -> Present.CitiesResponse.Builder {
            return classBuilder() as! Present.CitiesResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CitiesResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.CitiesResponse.Builder()
        }
        public func toBuilder() throws -> Present.CitiesResponse.Builder {
            return try Present.CitiesResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.CitiesResponse) throws -> Present.CitiesResponse.Builder {
            return try Present.CitiesResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !cities.isEmpty {
                var jsonArrayCities:Array<Dictionary<String,Any>> = []
                for oneValueCities in cities {
                    let ecodedMessageCities = try oneValueCities.encode()
                    jsonArrayCities.append(ecodedMessageCities)
                }
                jsonMap["cities"] = jsonArrayCities
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.CitiesResponse {
            return try Present.CitiesResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.CitiesResponse {
            return try Present.CitiesResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var citiesElementIndex:Int = 0
            for oneElementCities in cities {
                output += "\(indent) cities[\(citiesElementIndex)] {\n"
                output += try oneElementCities.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                citiesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementCities in cities {
                    hashCode = (hashCode &* 31) &+ oneElementCities.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.CitiesResponse"
        }
        override public func className() -> String {
            return "Present.CitiesResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.CitiesResponse = Present.CitiesResponse()
            public func getMessage() -> Present.CitiesResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var cities:Array<Present.City> {
                get {
                    return builderResult.cities
                }
                set (value) {
                    builderResult.cities = value
                }
            }
            @discardableResult
            public func setCities(_ value:Array<Present.City>) -> Present.CitiesResponse.Builder {
                self.cities = value
                return self
            }
            @discardableResult
            public func clearCities() -> Present.CitiesResponse.Builder {
                builderResult.cities.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.CitiesResponse.Builder {
                builderResult = Present.CitiesResponse()
                return self
            }
            override public func clone() throws -> Present.CitiesResponse.Builder {
                return try Present.CitiesResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.CitiesResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.CitiesResponse {
                let returnMe:Present.CitiesResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.CitiesResponse) throws -> Present.CitiesResponse.Builder {
                if other == Present.CitiesResponse() {
                    return self
                }
                if !other.cities.isEmpty  {
                     builderResult.cities += other.cities
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.CitiesResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CitiesResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.City.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        cities.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.CitiesResponse.Builder {
                let resultDecodedBuilder = Present.CitiesResponse.Builder()
                if let jsonValueCities = jsonMap["cities"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayCities:Array<Present.City> = []
                    for oneValueCities in jsonValueCities {
                        let messageFromStringCities = try Present.City.Builder.decodeToBuilder(jsonMap:oneValueCities).build()

                        jsonArrayCities.append(messageFromStringCities)
                    }
                    resultDecodedBuilder.cities = jsonArrayCities
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.CitiesResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.CitiesResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ReassignGroupRequest : GeneratedMessage {

        public static func == (lhs: Present.ReassignGroupRequest, rhs: Present.ReassignGroupRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasOwnerId == rhs.hasOwnerId) && (!lhs.hasOwnerId || lhs.ownerId == rhs.ownerId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:String = ""
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var ownerId:String = ""
        public fileprivate(set) var hasOwnerId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            if !hasOwnerId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeString(fieldNumber: 1, value:groupId)
            }
            if hasOwnerId {
                try codedOutputStream.writeString(fieldNumber: 2, value:ownerId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeStringSize(fieldNumber: 1)
            }
            if hasOwnerId {
                serialize_size += ownerId.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.ReassignGroupRequest.Builder {
            return Present.ReassignGroupRequest.classBuilder() as! Present.ReassignGroupRequest.Builder
        }
        public func getBuilder() -> Present.ReassignGroupRequest.Builder {
            return classBuilder() as! Present.ReassignGroupRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ReassignGroupRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ReassignGroupRequest.Builder()
        }
        public func toBuilder() throws -> Present.ReassignGroupRequest.Builder {
            return try Present.ReassignGroupRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.ReassignGroupRequest) throws -> Present.ReassignGroupRequest.Builder {
            return try Present.ReassignGroupRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = groupId
            }
            if hasOwnerId {
                jsonMap["ownerId"] = ownerId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.ReassignGroupRequest {
            return try Present.ReassignGroupRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.ReassignGroupRequest {
            return try Present.ReassignGroupRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasOwnerId {
                output += "\(indent) ownerId: \(ownerId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasOwnerId {
                    hashCode = (hashCode &* 31) &+ ownerId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.ReassignGroupRequest"
        }
        override public func className() -> String {
            return "Present.ReassignGroupRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.ReassignGroupRequest = Present.ReassignGroupRequest()
            public func getMessage() -> Present.ReassignGroupRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:String {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:String) -> Present.ReassignGroupRequest.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Present.ReassignGroupRequest.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = ""
                return self
            }
            public var ownerId:String {
                get {
                    return builderResult.ownerId
                }
                set (value) {
                    builderResult.hasOwnerId = true
                    builderResult.ownerId = value
                }
            }
            public var hasOwnerId:Bool {
                get {
                    return builderResult.hasOwnerId
                }
            }
            @discardableResult
            public func setOwnerId(_ value:String) -> Present.ReassignGroupRequest.Builder {
                self.ownerId = value
                return self
            }
            @discardableResult
            public func clearOwnerId() -> Present.ReassignGroupRequest.Builder{
                builderResult.hasOwnerId = false
                builderResult.ownerId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.ReassignGroupRequest.Builder {
                builderResult = Present.ReassignGroupRequest()
                return self
            }
            override public func clone() throws -> Present.ReassignGroupRequest.Builder {
                return try Present.ReassignGroupRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.ReassignGroupRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.ReassignGroupRequest {
                let returnMe:Present.ReassignGroupRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.ReassignGroupRequest) throws -> Present.ReassignGroupRequest.Builder {
                if other == Present.ReassignGroupRequest() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasOwnerId {
                    ownerId = other.ownerId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.ReassignGroupRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ReassignGroupRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        groupId = try codedInputStream.readString()

                    case 18:
                        ownerId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.ReassignGroupRequest.Builder {
                let resultDecodedBuilder = Present.ReassignGroupRequest.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = jsonValueGroupId
                }
                if let jsonValueOwnerId = jsonMap["ownerId"] as? String {
                    resultDecodedBuilder.ownerId = jsonValueOwnerId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.ReassignGroupRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.ReassignGroupRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class HtmlResponse : GeneratedMessage {

        public static func == (lhs: Present.HtmlResponse, rhs: Present.HtmlResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHtml == rhs.hasHtml) && (!lhs.hasHtml || lhs.html == rhs.html)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var html:String = ""
        public fileprivate(set) var hasHtml:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasHtml {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHtml {
                try codedOutputStream.writeString(fieldNumber: 1, value:html)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHtml {
                serialize_size += html.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.HtmlResponse.Builder {
            return Present.HtmlResponse.classBuilder() as! Present.HtmlResponse.Builder
        }
        public func getBuilder() -> Present.HtmlResponse.Builder {
            return classBuilder() as! Present.HtmlResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.HtmlResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.HtmlResponse.Builder()
        }
        public func toBuilder() throws -> Present.HtmlResponse.Builder {
            return try Present.HtmlResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.HtmlResponse) throws -> Present.HtmlResponse.Builder {
            return try Present.HtmlResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHtml {
                jsonMap["html"] = html
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.HtmlResponse {
            return try Present.HtmlResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.HtmlResponse {
            return try Present.HtmlResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHtml {
                output += "\(indent) html: \(html) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHtml {
                    hashCode = (hashCode &* 31) &+ html.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.HtmlResponse"
        }
        override public func className() -> String {
            return "Present.HtmlResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.HtmlResponse = Present.HtmlResponse()
            public func getMessage() -> Present.HtmlResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var html:String {
                get {
                    return builderResult.html
                }
                set (value) {
                    builderResult.hasHtml = true
                    builderResult.html = value
                }
            }
            public var hasHtml:Bool {
                get {
                    return builderResult.hasHtml
                }
            }
            @discardableResult
            public func setHtml(_ value:String) -> Present.HtmlResponse.Builder {
                self.html = value
                return self
            }
            @discardableResult
            public func clearHtml() -> Present.HtmlResponse.Builder{
                builderResult.hasHtml = false
                builderResult.html = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.HtmlResponse.Builder {
                builderResult = Present.HtmlResponse()
                return self
            }
            override public func clone() throws -> Present.HtmlResponse.Builder {
                return try Present.HtmlResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.HtmlResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.HtmlResponse {
                let returnMe:Present.HtmlResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.HtmlResponse) throws -> Present.HtmlResponse.Builder {
                if other == Present.HtmlResponse() {
                    return self
                }
                if other.hasHtml {
                    html = other.html
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.HtmlResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.HtmlResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        html = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.HtmlResponse.Builder {
                let resultDecodedBuilder = Present.HtmlResponse.Builder()
                if let jsonValueHtml = jsonMap["html"] as? String {
                    resultDecodedBuilder.html = jsonValueHtml
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.HtmlResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.HtmlResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FeedRequest : GeneratedMessage {

        public static func == (lhs: Present.FeedRequest, rhs: Present.FeedRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSpaceId == rhs.hasSpaceId) && (!lhs.hasSpaceId || lhs.spaceId == rhs.spaceId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Each space has its own feed. Takes precedence over spaceId in headers.
        public fileprivate(set) var spaceId:String = ""
        public fileprivate(set) var hasSpaceId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasSpaceId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSpaceId {
                try codedOutputStream.writeString(fieldNumber: 1, value:spaceId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSpaceId {
                serialize_size += spaceId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.FeedRequest.Builder {
            return Present.FeedRequest.classBuilder() as! Present.FeedRequest.Builder
        }
        public func getBuilder() -> Present.FeedRequest.Builder {
            return classBuilder() as! Present.FeedRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FeedRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FeedRequest.Builder()
        }
        public func toBuilder() throws -> Present.FeedRequest.Builder {
            return try Present.FeedRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.FeedRequest) throws -> Present.FeedRequest.Builder {
            return try Present.FeedRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSpaceId {
                jsonMap["spaceId"] = spaceId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.FeedRequest {
            return try Present.FeedRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.FeedRequest {
            return try Present.FeedRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSpaceId {
                output += "\(indent) spaceId: \(spaceId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSpaceId {
                    hashCode = (hashCode &* 31) &+ spaceId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.FeedRequest"
        }
        override public func className() -> String {
            return "Present.FeedRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.FeedRequest = Present.FeedRequest()
            public func getMessage() -> Present.FeedRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Each space has its own feed. Takes precedence over spaceId in headers.
            public var spaceId:String {
                get {
                    return builderResult.spaceId
                }
                set (value) {
                    builderResult.hasSpaceId = true
                    builderResult.spaceId = value
                }
            }
            public var hasSpaceId:Bool {
                get {
                    return builderResult.hasSpaceId
                }
            }
            @discardableResult
            public func setSpaceId(_ value:String) -> Present.FeedRequest.Builder {
                self.spaceId = value
                return self
            }
            @discardableResult
            public func clearSpaceId() -> Present.FeedRequest.Builder{
                builderResult.hasSpaceId = false
                builderResult.spaceId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.FeedRequest.Builder {
                builderResult = Present.FeedRequest()
                return self
            }
            override public func clone() throws -> Present.FeedRequest.Builder {
                return try Present.FeedRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.FeedRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.FeedRequest {
                let returnMe:Present.FeedRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.FeedRequest) throws -> Present.FeedRequest.Builder {
                if other == Present.FeedRequest() {
                    return self
                }
                if other.hasSpaceId {
                    spaceId = other.spaceId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.FeedRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        spaceId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.FeedRequest.Builder {
                let resultDecodedBuilder = Present.FeedRequest.Builder()
                if let jsonValueSpaceId = jsonMap["spaceId"] as? String {
                    resultDecodedBuilder.spaceId = jsonValueSpaceId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.FeedRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.FeedRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// One or more comments and their corresponding group.
    final public class GroupComments : GeneratedMessage {

        public static func == (lhs: Present.GroupComments, rhs: Present.GroupComments) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroup == rhs.hasGroup) && (!lhs.hasGroup || lhs.group == rhs.group)
            fieldCheck = fieldCheck && (lhs.comments == rhs.comments)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var group:Present.GroupResponse!
        public fileprivate(set) var hasGroup:Bool = false
        public fileprivate(set) var comments:Array<Present.CommentResponse>  = Array<Present.CommentResponse>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroup {
                return false
            }
            if !group.isInitialized() {
                return false
            }
            var isInitComments:Bool = true
            for oneElementComments in comments {
                if !oneElementComments.isInitialized() {
                    isInitComments = false
                    break 
                }
            }
            if !isInitComments {
                return isInitComments
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroup {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:group)
            }
            for oneElementComments in comments {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementComments)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroup {
                if let varSizegroup = group?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizegroup
                }
            }
            for oneElementComments in comments {
                serialize_size += oneElementComments.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.GroupComments.Builder {
            return Present.GroupComments.classBuilder() as! Present.GroupComments.Builder
        }
        public func getBuilder() -> Present.GroupComments.Builder {
            return classBuilder() as! Present.GroupComments.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupComments.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.GroupComments.Builder()
        }
        public func toBuilder() throws -> Present.GroupComments.Builder {
            return try Present.GroupComments.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.GroupComments) throws -> Present.GroupComments.Builder {
            return try Present.GroupComments.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroup {
                jsonMap["group"] = try group.encode()
            }
            if !comments.isEmpty {
                var jsonArrayComments:Array<Dictionary<String,Any>> = []
                for oneValueComments in comments {
                    let ecodedMessageComments = try oneValueComments.encode()
                    jsonArrayComments.append(ecodedMessageComments)
                }
                jsonMap["comments"] = jsonArrayComments
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.GroupComments {
            return try Present.GroupComments.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.GroupComments {
            return try Present.GroupComments.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroup {
                output += "\(indent) group {\n"
                if let outDescGroup = group {
                    output += try outDescGroup.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var commentsElementIndex:Int = 0
            for oneElementComments in comments {
                output += "\(indent) comments[\(commentsElementIndex)] {\n"
                output += try oneElementComments.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                commentsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroup {
                    if let hashValuegroup = group?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegroup
                    }
                }
                for oneElementComments in comments {
                    hashCode = (hashCode &* 31) &+ oneElementComments.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.GroupComments"
        }
        override public func className() -> String {
            return "Present.GroupComments"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.GroupComments = Present.GroupComments()
            public func getMessage() -> Present.GroupComments {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Group the comments were made in.
            public var group:Present.GroupResponse! {
                get {
                    if groupBuilder_ != nil {
                        builderResult.group = groupBuilder_.getMessage()
                    }
                    return builderResult.group
                }
                set (value) {
                    builderResult.hasGroup = true
                    builderResult.group = value
                }
            }
            public var hasGroup:Bool {
                get {
                    return builderResult.hasGroup
                }
            }
            fileprivate var groupBuilder_:Present.GroupResponse.Builder! {
                didSet {
                    builderResult.hasGroup = true
                }
            }
            public func getGroupBuilder() -> Present.GroupResponse.Builder {
                if groupBuilder_ == nil {
                    groupBuilder_ = Present.GroupResponse.Builder()
                    builderResult.group = groupBuilder_.getMessage()
                    if group != nil {
                        try! groupBuilder_.mergeFrom(other: group)
                    }
                }
                return groupBuilder_
            }
            @discardableResult
            public func setGroup(_ value:Present.GroupResponse!) -> Present.GroupComments.Builder {
                self.group = value
                return self
            }
            @discardableResult
            public func mergeGroup(value:Present.GroupResponse) throws -> Present.GroupComments.Builder {
                if builderResult.hasGroup {
                    builderResult.group = try Present.GroupResponse.builderWithPrototype(prototype:builderResult.group).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.group = value
                }
                builderResult.hasGroup = true
                return self
            }
            @discardableResult
            public func clearGroup() -> Present.GroupComments.Builder {
                groupBuilder_ = nil
                builderResult.hasGroup = false
                builderResult.group = nil
                return self
            }
            /// Comments in chronological order.
            public var comments:Array<Present.CommentResponse> {
                get {
                    return builderResult.comments
                }
                set (value) {
                    builderResult.comments = value
                }
            }
            @discardableResult
            public func setComments(_ value:Array<Present.CommentResponse>) -> Present.GroupComments.Builder {
                self.comments = value
                return self
            }
            @discardableResult
            public func clearComments() -> Present.GroupComments.Builder {
                builderResult.comments.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.GroupComments.Builder {
                builderResult = Present.GroupComments()
                return self
            }
            override public func clone() throws -> Present.GroupComments.Builder {
                return try Present.GroupComments.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.GroupComments {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.GroupComments {
                let returnMe:Present.GroupComments = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.GroupComments) throws -> Present.GroupComments.Builder {
                if other == Present.GroupComments() {
                    return self
                }
                if (other.hasGroup) {
                    try mergeGroup(value: other.group)
                }
                if !other.comments.isEmpty  {
                     builderResult.comments += other.comments
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.GroupComments.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupComments.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.GroupResponse.Builder = Present.GroupResponse.Builder()
                        if hasGroup {
                            try subBuilder.mergeFrom(other: group)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        group = subBuilder.buildPartial()

                    case 18:
                        let subBuilder = Present.CommentResponse.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        comments.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.GroupComments.Builder {
                let resultDecodedBuilder = Present.GroupComments.Builder()
                if let jsonValueGroup = jsonMap["group"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.group = try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:jsonValueGroup).build()

                }
                if let jsonValueComments = jsonMap["comments"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayComments:Array<Present.CommentResponse> = []
                    for oneValueComments in jsonValueComments {
                        let messageFromStringComments = try Present.CommentResponse.Builder.decodeToBuilder(jsonMap:oneValueComments).build()

                        jsonArrayComments.append(messageFromStringComments)
                    }
                    resultDecodedBuilder.comments = jsonArrayComments
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.GroupComments.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.GroupComments.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FeedEntry : GeneratedMessage {

        public static func == (lhs: Present.FeedEntry, rhs: Present.FeedEntry) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupComments == rhs.hasGroupComments) && (!lhs.hasGroupComments || lhs.groupComments == rhs.groupComments)
            fieldCheck = fieldCheck && (lhs.hasGroupCreation == rhs.hasGroupCreation) && (!lhs.hasGroupCreation || lhs.groupCreation == rhs.groupCreation)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        /// Entry contents. Clients should ignore entry types they don't recognize.
        /// Possible future entry types: https://goo.gl/dJHyWR
        public enum Contents {
            case OneOfContentsNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfContentsNotSet: return false
                default: return true
                }
            }
            case GroupComments(Present.GroupComments)

            public static func getGroupComments(_ value:Contents) -> Present.GroupComments? {
                switch value {
                case .GroupComments(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case GroupCreation(Present.GroupResponse)

            public static func getGroupCreation(_ value:Contents) -> Present.GroupResponse? {
                switch value {
                case .GroupCreation(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageContents:FeedEntry.Contents =  FeedEntry.Contents.OneOfContentsNotSet
        public func getOneOfContents() ->  FeedEntry.Contents {
            let copyObjectContents = storageContents
            return copyObjectContents
        }
        public fileprivate(set) var groupComments:Present.GroupComments!{
            get {
                return FeedEntry.Contents.getGroupComments(storageContents)
            }
            set (newvalue) {
                storageContents = FeedEntry.Contents.GroupComments(newvalue)
            }
        }
        public fileprivate(set) var hasGroupComments:Bool {
            get {
                guard let _ = FeedEntry.Contents.getGroupComments(storageContents) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var groupCreation:Present.GroupResponse!{
            get {
                return FeedEntry.Contents.getGroupCreation(storageContents)
            }
            set (newvalue) {
                storageContents = FeedEntry.Contents.GroupCreation(newvalue)
            }
        }
        public fileprivate(set) var hasGroupCreation:Bool {
            get {
                guard let _ = FeedEntry.Contents.getGroupCreation(storageContents) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if hasGroupComments {
                if !groupComments.isInitialized() {
                    return false
                }
            }
            if hasGroupCreation {
                if !groupCreation.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupComments {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:groupComments)
            }
            if hasGroupCreation {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:groupCreation)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupComments {
                if let varSizegroupComments = groupComments?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizegroupComments
                }
            }
            if hasGroupCreation {
                if let varSizegroupCreation = groupCreation?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizegroupCreation
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.FeedEntry.Builder {
            return Present.FeedEntry.classBuilder() as! Present.FeedEntry.Builder
        }
        public func getBuilder() -> Present.FeedEntry.Builder {
            return classBuilder() as! Present.FeedEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FeedEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FeedEntry.Builder()
        }
        public func toBuilder() throws -> Present.FeedEntry.Builder {
            return try Present.FeedEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.FeedEntry) throws -> Present.FeedEntry.Builder {
            return try Present.FeedEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupComments {
                jsonMap["groupComments"] = try groupComments.encode()
            }
            if hasGroupCreation {
                jsonMap["groupCreation"] = try groupCreation.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.FeedEntry {
            return try Present.FeedEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.FeedEntry {
            return try Present.FeedEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupComments {
                output += "\(indent) groupComments {\n"
                if let outDescGroupComments = groupComments {
                    output += try outDescGroupComments.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasGroupCreation {
                output += "\(indent) groupCreation {\n"
                if let outDescGroupCreation = groupCreation {
                    output += try outDescGroupCreation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupComments {
                    if let hashValuegroupComments = groupComments?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegroupComments
                    }
                }
                if hasGroupCreation {
                    if let hashValuegroupCreation = groupCreation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegroupCreation
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.FeedEntry"
        }
        override public func className() -> String {
            return "Present.FeedEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.FeedEntry = Present.FeedEntry()
            public func getMessage() -> Present.FeedEntry {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Comment[s] made in a group.
            public var groupComments:Present.GroupComments! {
                get {
                    if groupCommentsBuilder_ != nil {
                        builderResult.groupComments = groupCommentsBuilder_.getMessage()
                    }
                    return builderResult.groupComments
                }
                set (value) {
                    builderResult.hasGroupComments = true
                    builderResult.groupComments = value
                }
            }
            public var hasGroupComments:Bool {
                get {
                    return builderResult.hasGroupComments
                }
            }
            fileprivate var groupCommentsBuilder_:Present.GroupComments.Builder! {
                didSet {
                    builderResult.hasGroupComments = true
                }
            }
            public func getGroupCommentsBuilder() -> Present.GroupComments.Builder {
                if groupCommentsBuilder_ == nil {
                    groupCommentsBuilder_ = Present.GroupComments.Builder()
                    builderResult.groupComments = groupCommentsBuilder_.getMessage()
                    if groupComments != nil {
                        try! groupCommentsBuilder_.mergeFrom(other: groupComments)
                    }
                }
                return groupCommentsBuilder_
            }
            @discardableResult
            public func setGroupComments(_ value:Present.GroupComments!) -> Present.FeedEntry.Builder {
                self.groupComments = value
                return self
            }
            @discardableResult
            public func mergeGroupComments(value:Present.GroupComments) throws -> Present.FeedEntry.Builder {
                if builderResult.hasGroupComments {
                    builderResult.groupComments = try Present.GroupComments.builderWithPrototype(prototype:builderResult.groupComments).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.groupComments = value
                }
                builderResult.hasGroupComments = true
                return self
            }
            @discardableResult
            public func clearGroupComments() -> Present.FeedEntry.Builder {
                groupCommentsBuilder_ = nil
                builderResult.hasGroupComments = false
                builderResult.groupComments = nil
                return self
            }
            /// A group was created.
            public var groupCreation:Present.GroupResponse! {
                get {
                    if groupCreationBuilder_ != nil {
                        builderResult.groupCreation = groupCreationBuilder_.getMessage()
                    }
                    return builderResult.groupCreation
                }
                set (value) {
                    builderResult.hasGroupCreation = true
                    builderResult.groupCreation = value
                }
            }
            public var hasGroupCreation:Bool {
                get {
                    return builderResult.hasGroupCreation
                }
            }
            fileprivate var groupCreationBuilder_:Present.GroupResponse.Builder! {
                didSet {
                    builderResult.hasGroupCreation = true
                }
            }
            public func getGroupCreationBuilder() -> Present.GroupResponse.Builder {
                if groupCreationBuilder_ == nil {
                    groupCreationBuilder_ = Present.GroupResponse.Builder()
                    builderResult.groupCreation = groupCreationBuilder_.getMessage()
                    if groupCreation != nil {
                        try! groupCreationBuilder_.mergeFrom(other: groupCreation)
                    }
                }
                return groupCreationBuilder_
            }
            @discardableResult
            public func setGroupCreation(_ value:Present.GroupResponse!) -> Present.FeedEntry.Builder {
                self.groupCreation = value
                return self
            }
            @discardableResult
            public func mergeGroupCreation(value:Present.GroupResponse) throws -> Present.FeedEntry.Builder {
                if builderResult.hasGroupCreation {
                    builderResult.groupCreation = try Present.GroupResponse.builderWithPrototype(prototype:builderResult.groupCreation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.groupCreation = value
                }
                builderResult.hasGroupCreation = true
                return self
            }
            @discardableResult
            public func clearGroupCreation() -> Present.FeedEntry.Builder {
                groupCreationBuilder_ = nil
                builderResult.hasGroupCreation = false
                builderResult.groupCreation = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.FeedEntry.Builder {
                builderResult = Present.FeedEntry()
                return self
            }
            override public func clone() throws -> Present.FeedEntry.Builder {
                return try Present.FeedEntry.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.FeedEntry {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.FeedEntry {
                let returnMe:Present.FeedEntry = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.FeedEntry) throws -> Present.FeedEntry.Builder {
                if other == Present.FeedEntry() {
                    return self
                }
                if (other.hasGroupComments) {
                    try mergeGroupComments(value: other.groupComments)
                }
                if (other.hasGroupCreation) {
                    try mergeGroupCreation(value: other.groupCreation)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.FeedEntry.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedEntry.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Present.GroupComments.Builder = Present.GroupComments.Builder()
                        if hasGroupComments {
                            try subBuilder.mergeFrom(other: groupComments)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        groupComments = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Present.GroupResponse.Builder = Present.GroupResponse.Builder()
                        if hasGroupCreation {
                            try subBuilder.mergeFrom(other: groupCreation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        groupCreation = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.FeedEntry.Builder {
                let resultDecodedBuilder = Present.FeedEntry.Builder()
                if let jsonValueGroupComments = jsonMap["groupComments"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.groupComments = try Present.GroupComments.Builder.decodeToBuilder(jsonMap:jsonValueGroupComments).build()

                }
                if let jsonValueGroupCreation = jsonMap["groupCreation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.groupCreation = try Present.GroupResponse.Builder.decodeToBuilder(jsonMap:jsonValueGroupCreation).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.FeedEntry.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.FeedEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FeedResponse : GeneratedMessage {

        public static func == (lhs: Present.FeedResponse, rhs: Present.FeedResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.entries == rhs.entries)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var entries:Array<Present.FeedEntry>  = Array<Present.FeedEntry>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitEntries:Bool = true
            for oneElementEntries in entries {
                if !oneElementEntries.isInitialized() {
                    isInitEntries = false
                    break 
                }
            }
            if !isInitEntries {
                return isInitEntries
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementEntries in entries {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementEntries)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementEntries in entries {
                serialize_size += oneElementEntries.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.FeedResponse.Builder {
            return Present.FeedResponse.classBuilder() as! Present.FeedResponse.Builder
        }
        public func getBuilder() -> Present.FeedResponse.Builder {
            return classBuilder() as! Present.FeedResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FeedResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FeedResponse.Builder()
        }
        public func toBuilder() throws -> Present.FeedResponse.Builder {
            return try Present.FeedResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.FeedResponse) throws -> Present.FeedResponse.Builder {
            return try Present.FeedResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !entries.isEmpty {
                var jsonArrayEntries:Array<Dictionary<String,Any>> = []
                for oneValueEntries in entries {
                    let ecodedMessageEntries = try oneValueEntries.encode()
                    jsonArrayEntries.append(ecodedMessageEntries)
                }
                jsonMap["entries"] = jsonArrayEntries
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.FeedResponse {
            return try Present.FeedResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.FeedResponse {
            return try Present.FeedResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var entriesElementIndex:Int = 0
            for oneElementEntries in entries {
                output += "\(indent) entries[\(entriesElementIndex)] {\n"
                output += try oneElementEntries.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                entriesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementEntries in entries {
                    hashCode = (hashCode &* 31) &+ oneElementEntries.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.FeedResponse"
        }
        override public func className() -> String {
            return "Present.FeedResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.FeedResponse = Present.FeedResponse()
            public func getMessage() -> Present.FeedResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Ordered feed entries.
            public var entries:Array<Present.FeedEntry> {
                get {
                    return builderResult.entries
                }
                set (value) {
                    builderResult.entries = value
                }
            }
            @discardableResult
            public func setEntries(_ value:Array<Present.FeedEntry>) -> Present.FeedResponse.Builder {
                self.entries = value
                return self
            }
            @discardableResult
            public func clearEntries() -> Present.FeedResponse.Builder {
                builderResult.entries.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.FeedResponse.Builder {
                builderResult = Present.FeedResponse()
                return self
            }
            override public func clone() throws -> Present.FeedResponse.Builder {
                return try Present.FeedResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.FeedResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.FeedResponse {
                let returnMe:Present.FeedResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.FeedResponse) throws -> Present.FeedResponse.Builder {
                if other == Present.FeedResponse() {
                    return self
                }
                if !other.entries.isEmpty  {
                     builderResult.entries += other.entries
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.FeedResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Present.FeedEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        entries.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.FeedResponse.Builder {
                let resultDecodedBuilder = Present.FeedResponse.Builder()
                if let jsonValueEntries = jsonMap["entries"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayEntries:Array<Present.FeedEntry> = []
                    for oneValueEntries in jsonValueEntries {
                        let messageFromStringEntries = try Present.FeedEntry.Builder.decodeToBuilder(jsonMap:oneValueEntries).build()

                        jsonArrayEntries.append(messageFromStringEntries)
                    }
                    resultDecodedBuilder.entries = jsonArrayEntries
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.FeedResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.FeedResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ExploreHtmlRequest : GeneratedMessage {

        public static func == (lhs: Present.ExploreHtmlRequest, rhs: Present.ExploreHtmlRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSpaceId == rhs.hasSpaceId) && (!lhs.hasSpaceId || lhs.spaceId == rhs.spaceId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var spaceId:String = ""
        public fileprivate(set) var hasSpaceId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSpaceId {
                try codedOutputStream.writeString(fieldNumber: 1, value:spaceId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSpaceId {
                serialize_size += spaceId.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.ExploreHtmlRequest.Builder {
            return Present.ExploreHtmlRequest.classBuilder() as! Present.ExploreHtmlRequest.Builder
        }
        public func getBuilder() -> Present.ExploreHtmlRequest.Builder {
            return classBuilder() as! Present.ExploreHtmlRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ExploreHtmlRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.ExploreHtmlRequest.Builder()
        }
        public func toBuilder() throws -> Present.ExploreHtmlRequest.Builder {
            return try Present.ExploreHtmlRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.ExploreHtmlRequest) throws -> Present.ExploreHtmlRequest.Builder {
            return try Present.ExploreHtmlRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSpaceId {
                jsonMap["spaceId"] = spaceId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.ExploreHtmlRequest {
            return try Present.ExploreHtmlRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.ExploreHtmlRequest {
            return try Present.ExploreHtmlRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSpaceId {
                output += "\(indent) spaceId: \(spaceId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSpaceId {
                    hashCode = (hashCode &* 31) &+ spaceId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.ExploreHtmlRequest"
        }
        override public func className() -> String {
            return "Present.ExploreHtmlRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.ExploreHtmlRequest = Present.ExploreHtmlRequest()
            public func getMessage() -> Present.ExploreHtmlRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var spaceId:String {
                get {
                    return builderResult.spaceId
                }
                set (value) {
                    builderResult.hasSpaceId = true
                    builderResult.spaceId = value
                }
            }
            public var hasSpaceId:Bool {
                get {
                    return builderResult.hasSpaceId
                }
            }
            @discardableResult
            public func setSpaceId(_ value:String) -> Present.ExploreHtmlRequest.Builder {
                self.spaceId = value
                return self
            }
            @discardableResult
            public func clearSpaceId() -> Present.ExploreHtmlRequest.Builder{
                builderResult.hasSpaceId = false
                builderResult.spaceId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.ExploreHtmlRequest.Builder {
                builderResult = Present.ExploreHtmlRequest()
                return self
            }
            override public func clone() throws -> Present.ExploreHtmlRequest.Builder {
                return try Present.ExploreHtmlRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.ExploreHtmlRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.ExploreHtmlRequest {
                let returnMe:Present.ExploreHtmlRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.ExploreHtmlRequest) throws -> Present.ExploreHtmlRequest.Builder {
                if other == Present.ExploreHtmlRequest() {
                    return self
                }
                if other.hasSpaceId {
                    spaceId = other.spaceId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.ExploreHtmlRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ExploreHtmlRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        spaceId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.ExploreHtmlRequest.Builder {
                let resultDecodedBuilder = Present.ExploreHtmlRequest.Builder()
                if let jsonValueSpaceId = jsonMap["spaceId"] as? String {
                    resultDecodedBuilder.spaceId = jsonValueSpaceId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.ExploreHtmlRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.ExploreHtmlRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FeedHtmlRequest : GeneratedMessage {

        public static func == (lhs: Present.FeedHtmlRequest, rhs: Present.FeedHtmlRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSpaceId == rhs.hasSpaceId) && (!lhs.hasSpaceId || lhs.spaceId == rhs.spaceId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var spaceId:String = ""
        public fileprivate(set) var hasSpaceId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSpaceId {
                try codedOutputStream.writeString(fieldNumber: 2, value:spaceId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSpaceId {
                serialize_size += spaceId.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Present.FeedHtmlRequest.Builder {
            return Present.FeedHtmlRequest.classBuilder() as! Present.FeedHtmlRequest.Builder
        }
        public func getBuilder() -> Present.FeedHtmlRequest.Builder {
            return classBuilder() as! Present.FeedHtmlRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FeedHtmlRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Present.FeedHtmlRequest.Builder()
        }
        public func toBuilder() throws -> Present.FeedHtmlRequest.Builder {
            return try Present.FeedHtmlRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Present.FeedHtmlRequest) throws -> Present.FeedHtmlRequest.Builder {
            return try Present.FeedHtmlRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSpaceId {
                jsonMap["spaceId"] = spaceId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Present.FeedHtmlRequest {
            return try Present.FeedHtmlRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Present.FeedHtmlRequest {
            return try Present.FeedHtmlRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSpaceId {
                output += "\(indent) spaceId: \(spaceId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSpaceId {
                    hashCode = (hashCode &* 31) &+ spaceId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Present.FeedHtmlRequest"
        }
        override public func className() -> String {
            return "Present.FeedHtmlRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Present.FeedHtmlRequest = Present.FeedHtmlRequest()
            public func getMessage() -> Present.FeedHtmlRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var spaceId:String {
                get {
                    return builderResult.spaceId
                }
                set (value) {
                    builderResult.hasSpaceId = true
                    builderResult.spaceId = value
                }
            }
            public var hasSpaceId:Bool {
                get {
                    return builderResult.hasSpaceId
                }
            }
            @discardableResult
            public func setSpaceId(_ value:String) -> Present.FeedHtmlRequest.Builder {
                self.spaceId = value
                return self
            }
            @discardableResult
            public func clearSpaceId() -> Present.FeedHtmlRequest.Builder{
                builderResult.hasSpaceId = false
                builderResult.spaceId = ""
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Present.FeedHtmlRequest.Builder {
                builderResult = Present.FeedHtmlRequest()
                return self
            }
            override public func clone() throws -> Present.FeedHtmlRequest.Builder {
                return try Present.FeedHtmlRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Present.FeedHtmlRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Present.FeedHtmlRequest {
                let returnMe:Present.FeedHtmlRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Present.FeedHtmlRequest) throws -> Present.FeedHtmlRequest.Builder {
                if other == Present.FeedHtmlRequest() {
                    return self
                }
                if other.hasSpaceId {
                    spaceId = other.spaceId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Present.FeedHtmlRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedHtmlRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        spaceId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Present.FeedHtmlRequest.Builder {
                let resultDecodedBuilder = Present.FeedHtmlRequest.Builder()
                if let jsonValueSpaceId = jsonMap["spaceId"] as? String {
                    resultDecodedBuilder.spaceId = jsonValueSpaceId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Present.FeedHtmlRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Present.FeedHtmlRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Present.CommentResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.CommentResponse> {
        var mergedArray = Array<Present.CommentResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.CommentResponse? {
        return try Present.CommentResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.CommentResponse {
        return try Present.CommentResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.CommentResponse {
        return try Present.CommentResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.CommentResponse {
        return try Present.CommentResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CommentResponse {
        return try Present.CommentResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.CommentResponse {
        return try Present.CommentResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CommentResponse {
        return try Present.CommentResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "uuid": return self.uuid
        case "groupId": return self.groupId
        case "author": return self.author
        case "creationTime": return self.creationTime
        case "comment": return self.comment
        case "likes": return self.likes
        case "content": return self.content
        case "deleted": return self.deleted
        case "index": return self.index
        default: return nil
        }
    }
}
extension Present.CommentResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "uuid": return self.uuid
            case "groupId": return self.groupId
            case "author": return self.author
            case "creationTime": return self.creationTime
            case "comment": return self.comment
            case "likes": return self.likes
            case "content": return self.content
            case "deleted": return self.deleted
            case "index": return self.index
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "uuid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.uuid = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "author":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.author = newSubscriptValue
            case "creationTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.creationTime = newSubscriptValue
            case "comment":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.comment = newSubscriptValue
            case "likes":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.likes = newSubscriptValue
            case "content":
                guard let newSubscriptValue = newSubscriptValue as? Present.ContentResponse else {
                    return
                }
                self.content = newSubscriptValue
            case "deleted":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.deleted = newSubscriptValue
            case "index":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.index = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.GroupResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.GroupResponse> {
        var mergedArray = Array<Present.GroupResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.GroupResponse? {
        return try Present.GroupResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.GroupResponse {
        return try Present.GroupResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.GroupResponse {
        return try Present.GroupResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.GroupResponse {
        return try Present.GroupResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupResponse {
        return try Present.GroupResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.GroupResponse {
        return try Present.GroupResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupResponse {
        return try Present.GroupResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "uuid": return self.uuid
        case "type": return self.type
        case "space": return self.space
        case "creationTime": return self.creationTime
        case "memberCount": return self.memberCount
        case "commentCount": return self.commentCount
        case "lastCommentTime": return self.lastCommentTime
        case "url": return self.url
        case "title": return self.title
        case "owner": return self.owner
        case "location": return self.location
        case "locationName": return self.locationName
        case "radius": return self.radius
        case "cover": return self.cover
        case "categories": return self.categories
        case "description_": return self.description_
        case "schedule": return self.schedule
        case "joinRequests": return self.joinRequests
        case "unread": return self.unread
        case "lastRead": return self.lastRead
        case "muted": return self.muted
        case "saved": return self.saved
        case "membershipState": return self.membershipState
        case "newlyCreated": return self.newlyCreated
        case "preapprove": return self.preapprove
        case "discoverable": return self.discoverable
        case "deleted": return self.deleted
        default: return nil
        }
    }
}
extension Present.GroupResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "uuid": return self.uuid
            case "type": return self.type
            case "space": return self.space
            case "creationTime": return self.creationTime
            case "memberCount": return self.memberCount
            case "commentCount": return self.commentCount
            case "lastCommentTime": return self.lastCommentTime
            case "url": return self.url
            case "title": return self.title
            case "owner": return self.owner
            case "location": return self.location
            case "locationName": return self.locationName
            case "radius": return self.radius
            case "cover": return self.cover
            case "categories": return self.categories
            case "description_": return self.description_
            case "schedule": return self.schedule
            case "joinRequests": return self.joinRequests
            case "unread": return self.unread
            case "lastRead": return self.lastRead
            case "muted": return self.muted
            case "saved": return self.saved
            case "membershipState": return self.membershipState
            case "newlyCreated": return self.newlyCreated
            case "preapprove": return self.preapprove
            case "discoverable": return self.discoverable
            case "deleted": return self.deleted
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "uuid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.uuid = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupResponse.ProtoType else {
                    return
                }
                self.type = newSubscriptValue
            case "space":
                guard let newSubscriptValue = newSubscriptValue as? Present.SpaceResponse else {
                    return
                }
                self.space = newSubscriptValue
            case "creationTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.creationTime = newSubscriptValue
            case "memberCount":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.memberCount = newSubscriptValue
            case "commentCount":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.commentCount = newSubscriptValue
            case "lastCommentTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.lastCommentTime = newSubscriptValue
            case "url":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.url = newSubscriptValue
            case "title":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.title = newSubscriptValue
            case "owner":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.owner = newSubscriptValue
            case "location":
                guard let newSubscriptValue = newSubscriptValue as? Present.Coordinates else {
                    return
                }
                self.location = newSubscriptValue
            case "locationName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.locationName = newSubscriptValue
            case "radius":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.radius = newSubscriptValue
            case "cover":
                guard let newSubscriptValue = newSubscriptValue as? Present.ContentResponse else {
                    return
                }
                self.cover = newSubscriptValue
            case "categories":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.categories = newSubscriptValue
            case "description_":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.description_ = newSubscriptValue
            case "schedule":
                guard let newSubscriptValue = newSubscriptValue as? Present.Schedule else {
                    return
                }
                self.schedule = newSubscriptValue
            case "joinRequests":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.joinRequests = newSubscriptValue
            case "unread":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.unread = newSubscriptValue
            case "lastRead":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.lastRead = newSubscriptValue
            case "muted":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.muted = newSubscriptValue
            case "saved":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.saved = newSubscriptValue
            case "membershipState":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupMembershipState else {
                    return
                }
                self.membershipState = newSubscriptValue
            case "newlyCreated":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.newlyCreated = newSubscriptValue
            case "preapprove":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupMemberPreapproval else {
                    return
                }
                self.preapprove = newSubscriptValue
            case "discoverable":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.discoverable = newSubscriptValue
            case "deleted":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.deleted = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.GroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.GroupRequest> {
        var mergedArray = Array<Present.GroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.GroupRequest? {
        return try Present.GroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.GroupRequest {
        return try Present.GroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.GroupRequest {
        return try Present.GroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.GroupRequest {
        return try Present.GroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupRequest {
        return try Present.GroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.GroupRequest {
        return try Present.GroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupRequest {
        return try Present.GroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        default: return nil
        }
    }
}
extension Present.GroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.NearbyGroupsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.NearbyGroupsRequest> {
        var mergedArray = Array<Present.NearbyGroupsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.NearbyGroupsRequest? {
        return try Present.NearbyGroupsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.NearbyGroupsRequest {
        return try Present.NearbyGroupsRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.NearbyGroupsRequest {
        return try Present.NearbyGroupsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.NearbyGroupsRequest {
        return try Present.NearbyGroupsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.NearbyGroupsRequest {
        return try Present.NearbyGroupsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.NearbyGroupsRequest {
        return try Present.NearbyGroupsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.NearbyGroupsRequest {
        return try Present.NearbyGroupsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "location": return self.location
        case "spaceId": return self.spaceId
        default: return nil
        }
    }
}
extension Present.NearbyGroupsRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "location": return self.location
            case "spaceId": return self.spaceId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "location":
                guard let newSubscriptValue = newSubscriptValue as? Present.Coordinates else {
                    return
                }
                self.location = newSubscriptValue
            case "spaceId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.spaceId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.NearbyGroupsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.NearbyGroupsResponse> {
        var mergedArray = Array<Present.NearbyGroupsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.NearbyGroupsResponse? {
        return try Present.NearbyGroupsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.NearbyGroupsResponse {
        return try Present.NearbyGroupsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.NearbyGroupsResponse {
        return try Present.NearbyGroupsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.NearbyGroupsResponse {
        return try Present.NearbyGroupsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.NearbyGroupsResponse {
        return try Present.NearbyGroupsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.NearbyGroupsResponse {
        return try Present.NearbyGroupsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.NearbyGroupsResponse {
        return try Present.NearbyGroupsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nearbyGroups": return self.nearbyGroups
        case "mutedGroups": return self.mutedGroups
        default: return nil
        }
    }
}
extension Present.NearbyGroupsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nearbyGroups": return self.nearbyGroups
            case "mutedGroups": return self.mutedGroups
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nearbyGroups":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.GroupResponse> else {
                    return
                }
                self.nearbyGroups = newSubscriptValue
            case "mutedGroups":
                guard let newSubscriptValue = newSubscriptValue as? Present.MutedGroupsResponse else {
                    return
                }
                self.mutedGroups = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.DirectGroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.DirectGroupRequest> {
        var mergedArray = Array<Present.DirectGroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.DirectGroupRequest? {
        return try Present.DirectGroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.DirectGroupRequest {
        return try Present.DirectGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.DirectGroupRequest {
        return try Present.DirectGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.DirectGroupRequest {
        return try Present.DirectGroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DirectGroupRequest {
        return try Present.DirectGroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.DirectGroupRequest {
        return try Present.DirectGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DirectGroupRequest {
        return try Present.DirectGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "recipients": return self.recipients
        default: return nil
        }
    }
}
extension Present.DirectGroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "recipients": return self.recipients
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "recipients":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.recipients = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.DirectGroupsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.DirectGroupsResponse> {
        var mergedArray = Array<Present.DirectGroupsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.DirectGroupsResponse? {
        return try Present.DirectGroupsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.DirectGroupsResponse {
        return try Present.DirectGroupsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.DirectGroupsResponse {
        return try Present.DirectGroupsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.DirectGroupsResponse {
        return try Present.DirectGroupsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DirectGroupsResponse {
        return try Present.DirectGroupsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.DirectGroupsResponse {
        return try Present.DirectGroupsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DirectGroupsResponse {
        return try Present.DirectGroupsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groups": return self.groups
        default: return nil
        }
    }
}
extension Present.DirectGroupsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groups": return self.groups
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groups":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.GroupResponse> else {
                    return
                }
                self.groups = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.JoinedGroupsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.JoinedGroupsRequest> {
        var mergedArray = Array<Present.JoinedGroupsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.JoinedGroupsRequest? {
        return try Present.JoinedGroupsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.JoinedGroupsRequest {
        return try Present.JoinedGroupsRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.JoinedGroupsRequest {
        return try Present.JoinedGroupsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.JoinedGroupsRequest {
        return try Present.JoinedGroupsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinedGroupsRequest {
        return try Present.JoinedGroupsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.JoinedGroupsRequest {
        return try Present.JoinedGroupsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinedGroupsRequest {
        return try Present.JoinedGroupsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        default: return nil
        }
    }
}
extension Present.JoinedGroupsRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.JoinedGroupsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.JoinedGroupsResponse> {
        var mergedArray = Array<Present.JoinedGroupsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.JoinedGroupsResponse? {
        return try Present.JoinedGroupsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.JoinedGroupsResponse {
        return try Present.JoinedGroupsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.JoinedGroupsResponse {
        return try Present.JoinedGroupsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.JoinedGroupsResponse {
        return try Present.JoinedGroupsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinedGroupsResponse {
        return try Present.JoinedGroupsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.JoinedGroupsResponse {
        return try Present.JoinedGroupsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinedGroupsResponse {
        return try Present.JoinedGroupsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groups": return self.groups
        case "mutedGroups": return self.mutedGroups
        default: return nil
        }
    }
}
extension Present.JoinedGroupsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groups": return self.groups
            case "mutedGroups": return self.mutedGroups
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groups":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.GroupResponse> else {
                    return
                }
                self.groups = newSubscriptValue
            case "mutedGroups":
                guard let newSubscriptValue = newSubscriptValue as? Present.MutedGroupsResponse else {
                    return
                }
                self.mutedGroups = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.SuggestedLocation: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.SuggestedLocation> {
        var mergedArray = Array<Present.SuggestedLocation>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.SuggestedLocation? {
        return try Present.SuggestedLocation.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.SuggestedLocation {
        return try Present.SuggestedLocation.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.SuggestedLocation {
        return try Present.SuggestedLocation.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.SuggestedLocation {
        return try Present.SuggestedLocation.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SuggestedLocation {
        return try Present.SuggestedLocation.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.SuggestedLocation {
        return try Present.SuggestedLocation.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.SuggestedLocation {
        return try Present.SuggestedLocation.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "location": return self.location
        case "radius": return self.radius
        case "source": return self.source
        default: return nil
        }
    }
}
extension Present.SuggestedLocation.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "location": return self.location
            case "radius": return self.radius
            case "source": return self.source
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "location":
                guard let newSubscriptValue = newSubscriptValue as? Present.Coordinates else {
                    return
                }
                self.location = newSubscriptValue
            case "radius":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.radius = newSubscriptValue
            case "source":
                guard let newSubscriptValue = newSubscriptValue as? Present.SuggestedLocation.Source else {
                    return
                }
                self.source = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.Schedule: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.Schedule> {
        var mergedArray = Array<Present.Schedule>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.Schedule? {
        return try Present.Schedule.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.Schedule {
        return try Present.Schedule.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.Schedule {
        return try Present.Schedule.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.Schedule {
        return try Present.Schedule.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Schedule {
        return try Present.Schedule.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.Schedule {
        return try Present.Schedule.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.Schedule {
        return try Present.Schedule.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "startTime": return self.startTime
        case "endTime": return self.endTime
        default: return nil
        }
    }
}
extension Present.Schedule.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "startTime": return self.startTime
            case "endTime": return self.endTime
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "startTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.startTime = newSubscriptValue
            case "endTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.endTime = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.PutGroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PutGroupRequest> {
        var mergedArray = Array<Present.PutGroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PutGroupRequest? {
        return try Present.PutGroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PutGroupRequest {
        return try Present.PutGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PutGroupRequest {
        return try Present.PutGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PutGroupRequest {
        return try Present.PutGroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutGroupRequest {
        return try Present.PutGroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PutGroupRequest {
        return try Present.PutGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutGroupRequest {
        return try Present.PutGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "uuid": return self.uuid
        case "spaceId": return self.spaceId
        case "location": return self.location
        case "locationName": return self.locationName
        case "title": return self.title
        case "createdFrom": return self.createdFrom
        case "suggestedLocation": return self.suggestedLocation
        case "cover": return self.cover
        case "description_": return self.description_
        case "categories": return self.categories
        case "schedule": return self.schedule
        case "preapprove": return self.preapprove
        case "discoverable": return self.discoverable
        default: return nil
        }
    }
}
extension Present.PutGroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "uuid": return self.uuid
            case "spaceId": return self.spaceId
            case "location": return self.location
            case "locationName": return self.locationName
            case "title": return self.title
            case "createdFrom": return self.createdFrom
            case "suggestedLocation": return self.suggestedLocation
            case "cover": return self.cover
            case "description_": return self.description_
            case "categories": return self.categories
            case "schedule": return self.schedule
            case "preapprove": return self.preapprove
            case "discoverable": return self.discoverable
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "uuid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.uuid = newSubscriptValue
            case "spaceId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.spaceId = newSubscriptValue
            case "location":
                guard let newSubscriptValue = newSubscriptValue as? Present.Coordinates else {
                    return
                }
                self.location = newSubscriptValue
            case "locationName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.locationName = newSubscriptValue
            case "title":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.title = newSubscriptValue
            case "createdFrom":
                guard let newSubscriptValue = newSubscriptValue as? Present.Coordinates else {
                    return
                }
                self.createdFrom = newSubscriptValue
            case "suggestedLocation":
                guard let newSubscriptValue = newSubscriptValue as? Present.SuggestedLocation else {
                    return
                }
                self.suggestedLocation = newSubscriptValue
            case "cover":
                guard let newSubscriptValue = newSubscriptValue as? Present.ContentReferenceRequest else {
                    return
                }
                self.cover = newSubscriptValue
            case "description_":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.description_ = newSubscriptValue
            case "categories":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.categories = newSubscriptValue
            case "schedule":
                guard let newSubscriptValue = newSubscriptValue as? Present.Schedule else {
                    return
                }
                self.schedule = newSubscriptValue
            case "preapprove":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupMemberPreapproval else {
                    return
                }
                self.preapprove = newSubscriptValue
            case "discoverable":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.discoverable = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.PutGroupResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PutGroupResponse> {
        var mergedArray = Array<Present.PutGroupResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PutGroupResponse? {
        return try Present.PutGroupResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PutGroupResponse {
        return try Present.PutGroupResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PutGroupResponse {
        return try Present.PutGroupResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PutGroupResponse {
        return try Present.PutGroupResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutGroupResponse {
        return try Present.PutGroupResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PutGroupResponse {
        return try Present.PutGroupResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutGroupResponse {
        return try Present.PutGroupResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "group": return self.group
        default: return nil
        }
    }
}
extension Present.PutGroupResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "group": return self.group
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "group":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupResponse else {
                    return
                }
                self.group = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.PastCommentsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PastCommentsRequest> {
        var mergedArray = Array<Present.PastCommentsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PastCommentsRequest? {
        return try Present.PastCommentsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PastCommentsRequest {
        return try Present.PastCommentsRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PastCommentsRequest {
        return try Present.PastCommentsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PastCommentsRequest {
        return try Present.PastCommentsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastCommentsRequest {
        return try Present.PastCommentsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PastCommentsRequest {
        return try Present.PastCommentsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastCommentsRequest {
        return try Present.PastCommentsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        default: return nil
        }
    }
}
extension Present.PastCommentsRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.PastCommentsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PastCommentsResponse> {
        var mergedArray = Array<Present.PastCommentsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PastCommentsResponse? {
        return try Present.PastCommentsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PastCommentsResponse {
        return try Present.PastCommentsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PastCommentsResponse {
        return try Present.PastCommentsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PastCommentsResponse {
        return try Present.PastCommentsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastCommentsResponse {
        return try Present.PastCommentsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PastCommentsResponse {
        return try Present.PastCommentsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PastCommentsResponse {
        return try Present.PastCommentsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "comments": return self.comments
        default: return nil
        }
    }
}
extension Present.PastCommentsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "comments": return self.comments
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "comments":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.CommentResponse> else {
                    return
                }
                self.comments = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.CommentRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.CommentRequest> {
        var mergedArray = Array<Present.CommentRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.CommentRequest? {
        return try Present.CommentRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.CommentRequest {
        return try Present.CommentRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.CommentRequest {
        return try Present.CommentRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.CommentRequest {
        return try Present.CommentRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CommentRequest {
        return try Present.CommentRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.CommentRequest {
        return try Present.CommentRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CommentRequest {
        return try Present.CommentRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "commentId": return self.commentId
        default: return nil
        }
    }
}
extension Present.CommentRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "commentId": return self.commentId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "commentId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.commentId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.PutCommentRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.PutCommentRequest> {
        var mergedArray = Array<Present.PutCommentRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.PutCommentRequest? {
        return try Present.PutCommentRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.PutCommentRequest {
        return try Present.PutCommentRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.PutCommentRequest {
        return try Present.PutCommentRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.PutCommentRequest {
        return try Present.PutCommentRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutCommentRequest {
        return try Present.PutCommentRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.PutCommentRequest {
        return try Present.PutCommentRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.PutCommentRequest {
        return try Present.PutCommentRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "uuid": return self.uuid
        case "groupId": return self.groupId
        case "comment": return self.comment
        case "content": return self.content
        default: return nil
        }
    }
}
extension Present.PutCommentRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "uuid": return self.uuid
            case "groupId": return self.groupId
            case "comment": return self.comment
            case "content": return self.content
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "uuid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.uuid = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "comment":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.comment = newSubscriptValue
            case "content":
                guard let newSubscriptValue = newSubscriptValue as? Present.ContentReferenceRequest else {
                    return
                }
                self.content = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.FindLiveServerRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.FindLiveServerRequest> {
        var mergedArray = Array<Present.FindLiveServerRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.FindLiveServerRequest? {
        return try Present.FindLiveServerRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.FindLiveServerRequest {
        return try Present.FindLiveServerRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.FindLiveServerRequest {
        return try Present.FindLiveServerRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.FindLiveServerRequest {
        return try Present.FindLiveServerRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FindLiveServerRequest {
        return try Present.FindLiveServerRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.FindLiveServerRequest {
        return try Present.FindLiveServerRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FindLiveServerRequest {
        return try Present.FindLiveServerRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        default: return nil
        }
    }
}
extension Present.FindLiveServerRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.FindLiveServerResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.FindLiveServerResponse> {
        var mergedArray = Array<Present.FindLiveServerResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.FindLiveServerResponse? {
        return try Present.FindLiveServerResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.FindLiveServerResponse {
        return try Present.FindLiveServerResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.FindLiveServerResponse {
        return try Present.FindLiveServerResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.FindLiveServerResponse {
        return try Present.FindLiveServerResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FindLiveServerResponse {
        return try Present.FindLiveServerResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.FindLiveServerResponse {
        return try Present.FindLiveServerResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FindLiveServerResponse {
        return try Present.FindLiveServerResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "host": return self.host
        case "port": return self.port
        default: return nil
        }
    }
}
extension Present.FindLiveServerResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "host": return self.host
            case "port": return self.port
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "host":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.host = newSubscriptValue
            case "port":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.port = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.JoinGroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.JoinGroupRequest> {
        var mergedArray = Array<Present.JoinGroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.JoinGroupRequest? {
        return try Present.JoinGroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.JoinGroupRequest {
        return try Present.JoinGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.JoinGroupRequest {
        return try Present.JoinGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.JoinGroupRequest {
        return try Present.JoinGroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinGroupRequest {
        return try Present.JoinGroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.JoinGroupRequest {
        return try Present.JoinGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinGroupRequest {
        return try Present.JoinGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "ignoreDeletions": return self.ignoreDeletions
        default: return nil
        }
    }
}
extension Present.JoinGroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "ignoreDeletions": return self.ignoreDeletions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "ignoreDeletions":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.ignoreDeletions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.JoinGroupResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.JoinGroupResponse> {
        var mergedArray = Array<Present.JoinGroupResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.JoinGroupResponse? {
        return try Present.JoinGroupResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.JoinGroupResponse {
        return try Present.JoinGroupResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.JoinGroupResponse {
        return try Present.JoinGroupResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.JoinGroupResponse {
        return try Present.JoinGroupResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinGroupResponse {
        return try Present.JoinGroupResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.JoinGroupResponse {
        return try Present.JoinGroupResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.JoinGroupResponse {
        return try Present.JoinGroupResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "result": return self.result
        default: return nil
        }
    }
}
extension Present.JoinGroupResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "result": return self.result
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "result":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupMembershipState else {
                    return
                }
                self.result = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.LeaveGroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.LeaveGroupRequest> {
        var mergedArray = Array<Present.LeaveGroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.LeaveGroupRequest? {
        return try Present.LeaveGroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.LeaveGroupRequest {
        return try Present.LeaveGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.LeaveGroupRequest {
        return try Present.LeaveGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.LeaveGroupRequest {
        return try Present.LeaveGroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LeaveGroupRequest {
        return try Present.LeaveGroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.LeaveGroupRequest {
        return try Present.LeaveGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.LeaveGroupRequest {
        return try Present.LeaveGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        default: return nil
        }
    }
}
extension Present.LeaveGroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.FlagGroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.FlagGroupRequest> {
        var mergedArray = Array<Present.FlagGroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.FlagGroupRequest? {
        return try Present.FlagGroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.FlagGroupRequest {
        return try Present.FlagGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.FlagGroupRequest {
        return try Present.FlagGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.FlagGroupRequest {
        return try Present.FlagGroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FlagGroupRequest {
        return try Present.FlagGroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.FlagGroupRequest {
        return try Present.FlagGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FlagGroupRequest {
        return try Present.FlagGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "reason": return self.reason
        case "customReason": return self.customReason
        default: return nil
        }
    }
}
extension Present.FlagGroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "reason": return self.reason
            case "customReason": return self.customReason
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "reason":
                guard let newSubscriptValue = newSubscriptValue as? Present.FlagReason else {
                    return
                }
                self.reason = newSubscriptValue
            case "customReason":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.customReason = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.FlagCommentRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.FlagCommentRequest> {
        var mergedArray = Array<Present.FlagCommentRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.FlagCommentRequest? {
        return try Present.FlagCommentRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.FlagCommentRequest {
        return try Present.FlagCommentRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.FlagCommentRequest {
        return try Present.FlagCommentRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.FlagCommentRequest {
        return try Present.FlagCommentRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FlagCommentRequest {
        return try Present.FlagCommentRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.FlagCommentRequest {
        return try Present.FlagCommentRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FlagCommentRequest {
        return try Present.FlagCommentRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "commentId": return self.commentId
        case "reason": return self.reason
        case "customReason": return self.customReason
        default: return nil
        }
    }
}
extension Present.FlagCommentRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "commentId": return self.commentId
            case "reason": return self.reason
            case "customReason": return self.customReason
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "commentId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.commentId = newSubscriptValue
            case "reason":
                guard let newSubscriptValue = newSubscriptValue as? Present.FlagReason else {
                    return
                }
                self.reason = newSubscriptValue
            case "customReason":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.customReason = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.DeleteGroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.DeleteGroupRequest> {
        var mergedArray = Array<Present.DeleteGroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.DeleteGroupRequest? {
        return try Present.DeleteGroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.DeleteGroupRequest {
        return try Present.DeleteGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.DeleteGroupRequest {
        return try Present.DeleteGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.DeleteGroupRequest {
        return try Present.DeleteGroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DeleteGroupRequest {
        return try Present.DeleteGroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.DeleteGroupRequest {
        return try Present.DeleteGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DeleteGroupRequest {
        return try Present.DeleteGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        default: return nil
        }
    }
}
extension Present.DeleteGroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.DeleteCommentRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.DeleteCommentRequest> {
        var mergedArray = Array<Present.DeleteCommentRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.DeleteCommentRequest? {
        return try Present.DeleteCommentRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.DeleteCommentRequest {
        return try Present.DeleteCommentRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.DeleteCommentRequest {
        return try Present.DeleteCommentRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.DeleteCommentRequest {
        return try Present.DeleteCommentRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DeleteCommentRequest {
        return try Present.DeleteCommentRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.DeleteCommentRequest {
        return try Present.DeleteCommentRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.DeleteCommentRequest {
        return try Present.DeleteCommentRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "commentId": return self.commentId
        default: return nil
        }
    }
}
extension Present.DeleteCommentRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "commentId": return self.commentId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "commentId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.commentId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.MuteGroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.MuteGroupRequest> {
        var mergedArray = Array<Present.MuteGroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.MuteGroupRequest? {
        return try Present.MuteGroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.MuteGroupRequest {
        return try Present.MuteGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.MuteGroupRequest {
        return try Present.MuteGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.MuteGroupRequest {
        return try Present.MuteGroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MuteGroupRequest {
        return try Present.MuteGroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.MuteGroupRequest {
        return try Present.MuteGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MuteGroupRequest {
        return try Present.MuteGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        default: return nil
        }
    }
}
extension Present.MuteGroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.UnmuteGroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.UnmuteGroupRequest> {
        var mergedArray = Array<Present.UnmuteGroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.UnmuteGroupRequest? {
        return try Present.UnmuteGroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.UnmuteGroupRequest {
        return try Present.UnmuteGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.UnmuteGroupRequest {
        return try Present.UnmuteGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.UnmuteGroupRequest {
        return try Present.UnmuteGroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UnmuteGroupRequest {
        return try Present.UnmuteGroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.UnmuteGroupRequest {
        return try Present.UnmuteGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.UnmuteGroupRequest {
        return try Present.UnmuteGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        default: return nil
        }
    }
}
extension Present.UnmuteGroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.GroupMembersRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.GroupMembersRequest> {
        var mergedArray = Array<Present.GroupMembersRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.GroupMembersRequest? {
        return try Present.GroupMembersRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.GroupMembersRequest {
        return try Present.GroupMembersRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.GroupMembersRequest {
        return try Present.GroupMembersRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.GroupMembersRequest {
        return try Present.GroupMembersRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupMembersRequest {
        return try Present.GroupMembersRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.GroupMembersRequest {
        return try Present.GroupMembersRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupMembersRequest {
        return try Present.GroupMembersRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        default: return nil
        }
    }
}
extension Present.GroupMembersRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.GroupMembersResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.GroupMembersResponse> {
        var mergedArray = Array<Present.GroupMembersResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.GroupMembersResponse? {
        return try Present.GroupMembersResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.GroupMembersResponse {
        return try Present.GroupMembersResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.GroupMembersResponse {
        return try Present.GroupMembersResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.GroupMembersResponse {
        return try Present.GroupMembersResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupMembersResponse {
        return try Present.GroupMembersResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.GroupMembersResponse {
        return try Present.GroupMembersResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupMembersResponse {
        return try Present.GroupMembersResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "members": return self.members
        default: return nil
        }
    }
}
extension Present.GroupMembersResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "members": return self.members
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "members":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.UserResponse> else {
                    return
                }
                self.members = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.AddGroupMembersRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.AddGroupMembersRequest> {
        var mergedArray = Array<Present.AddGroupMembersRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.AddGroupMembersRequest? {
        return try Present.AddGroupMembersRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.AddGroupMembersRequest {
        return try Present.AddGroupMembersRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.AddGroupMembersRequest {
        return try Present.AddGroupMembersRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.AddGroupMembersRequest {
        return try Present.AddGroupMembersRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddGroupMembersRequest {
        return try Present.AddGroupMembersRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.AddGroupMembersRequest {
        return try Present.AddGroupMembersRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.AddGroupMembersRequest {
        return try Present.AddGroupMembersRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "userIds": return self.userIds
        default: return nil
        }
    }
}
extension Present.AddGroupMembersRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "userIds": return self.userIds
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "userIds":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.userIds = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.MembersRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.MembersRequest> {
        var mergedArray = Array<Present.MembersRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.MembersRequest? {
        return try Present.MembersRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.MembersRequest {
        return try Present.MembersRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.MembersRequest {
        return try Present.MembersRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.MembersRequest {
        return try Present.MembersRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembersRequest {
        return try Present.MembersRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.MembersRequest {
        return try Present.MembersRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembersRequest {
        return try Present.MembersRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "userIds": return self.userIds
        case "phoneNumbers": return self.phoneNumbers
        default: return nil
        }
    }
}
extension Present.MembersRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "userIds": return self.userIds
            case "phoneNumbers": return self.phoneNumbers
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "userIds":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.userIds = newSubscriptValue
            case "phoneNumbers":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.phoneNumbers = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.MembershipRequestsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.MembershipRequestsRequest> {
        var mergedArray = Array<Present.MembershipRequestsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.MembershipRequestsRequest? {
        return try Present.MembershipRequestsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.MembershipRequestsRequest {
        return try Present.MembershipRequestsRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequestsRequest {
        return try Present.MembershipRequestsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.MembershipRequestsRequest {
        return try Present.MembershipRequestsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequestsRequest {
        return try Present.MembershipRequestsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.MembershipRequestsRequest {
        return try Present.MembershipRequestsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequestsRequest {
        return try Present.MembershipRequestsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        default: return nil
        }
    }
}
extension Present.MembershipRequestsRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.MembershipRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.MembershipRequest> {
        var mergedArray = Array<Present.MembershipRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.MembershipRequest? {
        return try Present.MembershipRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.MembershipRequest {
        return try Present.MembershipRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequest {
        return try Present.MembershipRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.MembershipRequest {
        return try Present.MembershipRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequest {
        return try Present.MembershipRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.MembershipRequest {
        return try Present.MembershipRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequest {
        return try Present.MembershipRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "user": return self.user
        case "timestamp": return self.timestamp
        default: return nil
        }
    }
}
extension Present.MembershipRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "user": return self.user
            case "timestamp": return self.timestamp
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "user":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.user = newSubscriptValue
            case "timestamp":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.timestamp = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.MembershipRequestsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.MembershipRequestsResponse> {
        var mergedArray = Array<Present.MembershipRequestsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.MembershipRequestsResponse? {
        return try Present.MembershipRequestsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.MembershipRequestsResponse {
        return try Present.MembershipRequestsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequestsResponse {
        return try Present.MembershipRequestsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.MembershipRequestsResponse {
        return try Present.MembershipRequestsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequestsResponse {
        return try Present.MembershipRequestsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.MembershipRequestsResponse {
        return try Present.MembershipRequestsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MembershipRequestsResponse {
        return try Present.MembershipRequestsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "requests": return self.requests
        default: return nil
        }
    }
}
extension Present.MembershipRequestsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "requests": return self.requests
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "requests":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.MembershipRequest> else {
                    return
                }
                self.requests = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.InviteFriendsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.InviteFriendsRequest> {
        var mergedArray = Array<Present.InviteFriendsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.InviteFriendsRequest? {
        return try Present.InviteFriendsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.InviteFriendsRequest {
        return try Present.InviteFriendsRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.InviteFriendsRequest {
        return try Present.InviteFriendsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.InviteFriendsRequest {
        return try Present.InviteFriendsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.InviteFriendsRequest {
        return try Present.InviteFriendsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.InviteFriendsRequest {
        return try Present.InviteFriendsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.InviteFriendsRequest {
        return try Present.InviteFriendsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "userIds": return self.userIds
        default: return nil
        }
    }
}
extension Present.InviteFriendsRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "userIds": return self.userIds
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "userIds":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.userIds = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.MarkReadRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.MarkReadRequest> {
        var mergedArray = Array<Present.MarkReadRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.MarkReadRequest? {
        return try Present.MarkReadRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.MarkReadRequest {
        return try Present.MarkReadRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.MarkReadRequest {
        return try Present.MarkReadRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.MarkReadRequest {
        return try Present.MarkReadRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MarkReadRequest {
        return try Present.MarkReadRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.MarkReadRequest {
        return try Present.MarkReadRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MarkReadRequest {
        return try Present.MarkReadRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "lastRead": return self.lastRead
        default: return nil
        }
    }
}
extension Present.MarkReadRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "lastRead": return self.lastRead
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "lastRead":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.lastRead = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.MutedGroupsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.MutedGroupsResponse> {
        var mergedArray = Array<Present.MutedGroupsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.MutedGroupsResponse? {
        return try Present.MutedGroupsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.MutedGroupsResponse {
        return try Present.MutedGroupsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.MutedGroupsResponse {
        return try Present.MutedGroupsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.MutedGroupsResponse {
        return try Present.MutedGroupsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MutedGroupsResponse {
        return try Present.MutedGroupsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.MutedGroupsResponse {
        return try Present.MutedGroupsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.MutedGroupsResponse {
        return try Present.MutedGroupsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupIds": return self.groupIds
        default: return nil
        }
    }
}
extension Present.MutedGroupsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupIds": return self.groupIds
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupIds":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.groupIds = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.GroupReferralResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.GroupReferralResponse> {
        var mergedArray = Array<Present.GroupReferralResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.GroupReferralResponse? {
        return try Present.GroupReferralResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.GroupReferralResponse {
        return try Present.GroupReferralResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.GroupReferralResponse {
        return try Present.GroupReferralResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.GroupReferralResponse {
        return try Present.GroupReferralResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupReferralResponse {
        return try Present.GroupReferralResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.GroupReferralResponse {
        return try Present.GroupReferralResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupReferralResponse {
        return try Present.GroupReferralResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "user": return self.user
        case "group": return self.group
        default: return nil
        }
    }
}
extension Present.GroupReferralResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "user": return self.user
            case "group": return self.group
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "user":
                guard let newSubscriptValue = newSubscriptValue as? Present.UserResponse else {
                    return
                }
                self.user = newSubscriptValue
            case "group":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupResponse else {
                    return
                }
                self.group = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.GroupReferralsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.GroupReferralsResponse> {
        var mergedArray = Array<Present.GroupReferralsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.GroupReferralsResponse? {
        return try Present.GroupReferralsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.GroupReferralsResponse {
        return try Present.GroupReferralsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.GroupReferralsResponse {
        return try Present.GroupReferralsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.GroupReferralsResponse {
        return try Present.GroupReferralsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupReferralsResponse {
        return try Present.GroupReferralsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.GroupReferralsResponse {
        return try Present.GroupReferralsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupReferralsResponse {
        return try Present.GroupReferralsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "referrals": return self.referrals
        default: return nil
        }
    }
}
extension Present.GroupReferralsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "referrals": return self.referrals
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "referrals":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.GroupReferralResponse> else {
                    return
                }
                self.referrals = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.CountGroupReferralsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.CountGroupReferralsResponse> {
        var mergedArray = Array<Present.CountGroupReferralsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.CountGroupReferralsResponse? {
        return try Present.CountGroupReferralsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.CountGroupReferralsResponse {
        return try Present.CountGroupReferralsResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.CountGroupReferralsResponse {
        return try Present.CountGroupReferralsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.CountGroupReferralsResponse {
        return try Present.CountGroupReferralsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CountGroupReferralsResponse {
        return try Present.CountGroupReferralsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.CountGroupReferralsResponse {
        return try Present.CountGroupReferralsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CountGroupReferralsResponse {
        return try Present.CountGroupReferralsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "membersReferred": return self.membersReferred
        default: return nil
        }
    }
}
extension Present.CountGroupReferralsResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "membersReferred": return self.membersReferred
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "membersReferred":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.membersReferred = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.CitiesResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.CitiesResponse> {
        var mergedArray = Array<Present.CitiesResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.CitiesResponse? {
        return try Present.CitiesResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.CitiesResponse {
        return try Present.CitiesResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.CitiesResponse {
        return try Present.CitiesResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.CitiesResponse {
        return try Present.CitiesResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CitiesResponse {
        return try Present.CitiesResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.CitiesResponse {
        return try Present.CitiesResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.CitiesResponse {
        return try Present.CitiesResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "cities": return self.cities
        default: return nil
        }
    }
}
extension Present.CitiesResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "cities": return self.cities
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "cities":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.City> else {
                    return
                }
                self.cities = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.ReassignGroupRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.ReassignGroupRequest> {
        var mergedArray = Array<Present.ReassignGroupRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.ReassignGroupRequest? {
        return try Present.ReassignGroupRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.ReassignGroupRequest {
        return try Present.ReassignGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.ReassignGroupRequest {
        return try Present.ReassignGroupRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.ReassignGroupRequest {
        return try Present.ReassignGroupRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ReassignGroupRequest {
        return try Present.ReassignGroupRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.ReassignGroupRequest {
        return try Present.ReassignGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ReassignGroupRequest {
        return try Present.ReassignGroupRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "ownerId": return self.ownerId
        default: return nil
        }
    }
}
extension Present.ReassignGroupRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "ownerId": return self.ownerId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupId = newSubscriptValue
            case "ownerId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.ownerId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.HtmlResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.HtmlResponse> {
        var mergedArray = Array<Present.HtmlResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.HtmlResponse? {
        return try Present.HtmlResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.HtmlResponse {
        return try Present.HtmlResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.HtmlResponse {
        return try Present.HtmlResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.HtmlResponse {
        return try Present.HtmlResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.HtmlResponse {
        return try Present.HtmlResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.HtmlResponse {
        return try Present.HtmlResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.HtmlResponse {
        return try Present.HtmlResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "html": return self.html
        default: return nil
        }
    }
}
extension Present.HtmlResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "html": return self.html
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "html":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.html = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.FeedRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.FeedRequest> {
        var mergedArray = Array<Present.FeedRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.FeedRequest? {
        return try Present.FeedRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.FeedRequest {
        return try Present.FeedRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.FeedRequest {
        return try Present.FeedRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.FeedRequest {
        return try Present.FeedRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedRequest {
        return try Present.FeedRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.FeedRequest {
        return try Present.FeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedRequest {
        return try Present.FeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "spaceId": return self.spaceId
        default: return nil
        }
    }
}
extension Present.FeedRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "spaceId": return self.spaceId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "spaceId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.spaceId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.GroupComments: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.GroupComments> {
        var mergedArray = Array<Present.GroupComments>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.GroupComments? {
        return try Present.GroupComments.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.GroupComments {
        return try Present.GroupComments.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.GroupComments {
        return try Present.GroupComments.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.GroupComments {
        return try Present.GroupComments.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupComments {
        return try Present.GroupComments.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.GroupComments {
        return try Present.GroupComments.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.GroupComments {
        return try Present.GroupComments.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "group": return self.group
        case "comments": return self.comments
        default: return nil
        }
    }
}
extension Present.GroupComments.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "group": return self.group
            case "comments": return self.comments
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "group":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupResponse else {
                    return
                }
                self.group = newSubscriptValue
            case "comments":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.CommentResponse> else {
                    return
                }
                self.comments = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.FeedEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.FeedEntry> {
        var mergedArray = Array<Present.FeedEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.FeedEntry? {
        return try Present.FeedEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.FeedEntry {
        return try Present.FeedEntry.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.FeedEntry {
        return try Present.FeedEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.FeedEntry {
        return try Present.FeedEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedEntry {
        return try Present.FeedEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.FeedEntry {
        return try Present.FeedEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedEntry {
        return try Present.FeedEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupComments": return self.groupComments
        case "groupCreation": return self.groupCreation
        default: return nil
        }
    }
}
extension Present.FeedEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupComments": return self.groupComments
            case "groupCreation": return self.groupCreation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupComments":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupComments else {
                    return
                }
                self.groupComments = newSubscriptValue
            case "groupCreation":
                guard let newSubscriptValue = newSubscriptValue as? Present.GroupResponse else {
                    return
                }
                self.groupCreation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.FeedResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.FeedResponse> {
        var mergedArray = Array<Present.FeedResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.FeedResponse? {
        return try Present.FeedResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.FeedResponse {
        return try Present.FeedResponse.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.FeedResponse {
        return try Present.FeedResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.FeedResponse {
        return try Present.FeedResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedResponse {
        return try Present.FeedResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.FeedResponse {
        return try Present.FeedResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedResponse {
        return try Present.FeedResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "entries": return self.entries
        default: return nil
        }
    }
}
extension Present.FeedResponse.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "entries": return self.entries
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "entries":
                guard let newSubscriptValue = newSubscriptValue as? Array<Present.FeedEntry> else {
                    return
                }
                self.entries = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.ExploreHtmlRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.ExploreHtmlRequest> {
        var mergedArray = Array<Present.ExploreHtmlRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.ExploreHtmlRequest? {
        return try Present.ExploreHtmlRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.ExploreHtmlRequest {
        return try Present.ExploreHtmlRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.ExploreHtmlRequest {
        return try Present.ExploreHtmlRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.ExploreHtmlRequest {
        return try Present.ExploreHtmlRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ExploreHtmlRequest {
        return try Present.ExploreHtmlRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.ExploreHtmlRequest {
        return try Present.ExploreHtmlRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.ExploreHtmlRequest {
        return try Present.ExploreHtmlRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "spaceId": return self.spaceId
        default: return nil
        }
    }
}
extension Present.ExploreHtmlRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "spaceId": return self.spaceId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "spaceId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.spaceId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Present.FeedHtmlRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Present.FeedHtmlRequest> {
        var mergedArray = Array<Present.FeedHtmlRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Present.FeedHtmlRequest? {
        return try Present.FeedHtmlRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Present.FeedHtmlRequest {
        return try Present.FeedHtmlRequest.Builder().mergeFrom(data: data, extensionRegistry:Present.GroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Present.FeedHtmlRequest {
        return try Present.FeedHtmlRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Present.FeedHtmlRequest {
        return try Present.FeedHtmlRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedHtmlRequest {
        return try Present.FeedHtmlRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Present.FeedHtmlRequest {
        return try Present.FeedHtmlRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Present.FeedHtmlRequest {
        return try Present.FeedHtmlRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "spaceId": return self.spaceId
        default: return nil
        }
    }
}
extension Present.FeedHtmlRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "spaceId": return self.spaceId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "spaceId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.spaceId = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
